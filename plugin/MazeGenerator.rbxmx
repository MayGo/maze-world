<roblox version="4">
  <Item class="Folder" referent="0">
    <Properties>
      <string name="Name">MazeGenerator</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">MazeGeneratorPlugin</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">Fmt</string>
          <string name="Source">--[[
	This library describes a formatting mechanism akin to Rust's std::fmt.

	It has a couple building blocks:

	* A new syntax for formatting strings, taken verbatim from Rust. It'd also
	  be possible to use printf-style formatting specifiers to integrate with
	  the existing string.format utility.

	* An equivalent to Rust's `Display` trait. We're mapping the semantics of
	  tostring and the __tostring metamethod onto this trait. A lot of types
	  should already have __tostring implementations, too!

	* An equivalent to Rust's `Debug` trait. This library Lua-ifies that idea by
	  inventing a new metamethod, `__fmtDebug`. We pass along the "extended
	  form" attribute which is the equivalent of the "alternate mode" in Rust's
	  Debug trait since it's the author's opinion that treating it as a
	  verbosity flag is semantically accurate.
]]

--[[
	The default implementation of __fmtDebug for tables when the extended option
	is not set.
]]
local function defaultTableDebug(buffer, input)
	buffer:writeRaw("{")

	for key, value in pairs(input) do
		buffer:write("[{:?}] = {:?}", key, value)

		if next(input, key) ~= nil then
			buffer:writeRaw(", ")
		end
	end

	buffer:writeRaw("}")
end

--[[
	The default implementation of __fmtDebug for tables with the extended option
	set.
]]
local function defaultTableDebugExtended(buffer, input)
	-- Special case for empty tables.
	if next(input) == nil then
		buffer:writeRaw("{}")
		return
	end

	buffer:writeLineRaw("{")
	buffer:indent()

	for key, value in pairs(input) do
		buffer:writeLine("[{:?}] = {:#?},", key, value)
	end

	buffer:unindent()
	buffer:writeRaw("}")
end

--[[
	The default debug representation for all types.
]]
local function debugImpl(buffer, value, extendedForm)
	local valueType = typeof(value)

	if valueType == "string" then
		local formatted = string.format("%q", value)
		buffer:writeRaw(formatted)
	elseif valueType == "table" then
		local valueMeta = getmetatable(value)

		if valueMeta ~= nil and  valueMeta.__fmtDebug ~= nil then
			-- This type implement's the metamethod we made up to line up with
			-- Rust's 'Debug' trait.

			valueMeta.__fmtDebug(value, buffer, extendedForm)
		else
			if extendedForm then
				defaultTableDebugExtended(buffer, value)
			else
				defaultTableDebug(buffer, value)
			end
		end
	elseif valueType == "Instance" then
		buffer:writeRaw(value:GetFullName())
	else
		buffer:writeRaw(tostring(value))
	end
end

--[[
	Defines and implements the library's template syntax.
]]
local function writeFmt(buffer, template, ...)
	local currentArg = 0
	local i = 1
	local len = #template

	while i &lt;= len do
		local openBrace = template:find("{", i)

		if openBrace == nil then
			-- There are no remaining open braces in this string, so we can
			-- write the rest of the string to the buffer.

			buffer:writeRaw(template:sub(i))
			break
		else
			-- We found an open brace! This could be:
			-- - A literal '{', written as '{{'
			-- - The beginning of an interpolation, like '{}'
			-- - An error, if there's no matching '}'

			local charAfterBrace = template:sub(openBrace + 1, openBrace + 1)
			if charAfterBrace == "{" then
				-- This is a literal brace, so we'll write everything up to this
				-- point (including the first brace), and then skip over the
				-- second brace.

				buffer:writeRaw(template:sub(i, openBrace))
				i = openBrace + 2
			else
				-- This SHOULD be an interpolation. We'll find our matching
				-- brace and treat the contents as the formatting specifier.

				-- If there were any unwritten characters before this
				-- interpolation, write them to the buffer.
				if openBrace - i > 0 then
					buffer:writeRaw(template:sub(i, openBrace - 1))
				end

				local closeBrace = template:find("}", openBrace + 1)
				assert(closeBrace ~= nil, "Unclosed formatting specifier. Use '{{' to write an open brace.")

				local formatSpecifier = template:sub(openBrace + 1, closeBrace - 1)
				currentArg = currentArg + 1
				local arg = select(currentArg, ...)

				if formatSpecifier == "" then
					-- This should use the equivalent of Rust's 'Display', ie
					-- tostring and the __tostring metamethod.

					buffer:writeRaw(tostring(arg))
				elseif formatSpecifier == ":?" then
					-- This should use the equivalent of Rust's 'Debug',
					-- invented for this library as __fmtDebug.

					debugImpl(buffer, arg, false)
				elseif formatSpecifier == ":#?" then
					-- This should use the equivlant of Rust's 'Debug' with the
					-- 'alternate' (ie expanded) flag set.

					debugImpl(buffer, arg, true)
				else
					error("unsupported format specifier " .. formatSpecifier, 2)
				end

				i = closeBrace + 1
			end
		end
	end
end

local function debugOutputBuffer()
	local buffer = {}
	local startOfLine = true
	local indentLevel = 0
	local indentation = ""

	function buffer:writeLine(template, ...)
		writeFmt(self, template, ...)
		self:nextLine()
	end

	function buffer:writeLineRaw(value)
		self:writeRaw(value)
		self:nextLine()
	end

	function buffer:write(template, ...)
		return writeFmt(self, template, ...)
	end

	function buffer:writeRaw(value)
		if #value > 0 then
			if startOfLine and #indentation > 0 then
				startOfLine = false
				table.insert(self, indentation)
			end

			table.insert(self, value)
			startOfLine = false
		end
	end

	function buffer:nextLine()
		table.insert(self, "\n")
		startOfLine = true
	end

	function buffer:indent()
		indentLevel = indentLevel + 1
		indentation = string.rep("    ", indentLevel)
	end

	function buffer:unindent()
		indentLevel = math.max(0, indentLevel - 1)
		indentation = string.rep("    ", indentLevel)
	end

	function buffer:finish()
		return table.concat(self, "")
	end

	return buffer
end

local function fmt(template, ...)
	local buffer = debugOutputBuffer()
	writeFmt(buffer, template, ...)
	return buffer:finish()
end

--[[
	Wrap the given object in a type that implements the given function as its
	Debug implementation, and forwards __tostring to the type's underlying
	tostring implementation.
]]
local function debugify(object, fmtFunc)
	return setmetatable({}, {
		__fmtDebug = function(_, ...)
			return fmtFunc(object, ...)
		end,
		__tostring = function()
			return tostring(object)
		end,
	})
end

return {
	debugOutputBuffer = debugOutputBuffer,
	fmt = fmt,
	debugify = debugify,
}</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">Log</string>
          <string name="Source">local Fmt = require(script.Parent.Fmt)

local Level = {
	Error = 0,
	Warning = 1,
	Info = 2,
	Debug = 3,
	Trace = 4,
}

local function getLogLevel()
	return Level.Info
end

local function addTags(tag, message)
	return tag .. message:gsub('\n', '\n' .. tag)
end

local TRACE_TAG = (' '):rep(15) .. '[MazeGenerator-Trace] '
local INFO_TAG = (' '):rep(15) .. '[MazeGenerator-Info] '
local DEBUG_TAG = (' '):rep(15) .. '[MazeGenerator-Debug] '
local WARN_TAG = '[MazeGenerator-Warn] '

local Log = {}

Log.Level = Level

function Log.setLogLevelThunk(thunk)
	getLogLevel = thunk
end

function Log.trace(template, ...)
	if getLogLevel() >= Level.Trace then
		print(addTags(TRACE_TAG, Fmt.fmt(template, ...)))
	end
end

function Log.info(template, ...)
	if getLogLevel() >= Level.Info then
		print(addTags(INFO_TAG, Fmt.fmt(template, ...)))
	end
end

function Log.debug(template, ...)
	if getLogLevel() >= Level.Debug then
		print(addTags(DEBUG_TAG, Fmt.fmt(template, ...)))
	end
end

function Log.warn(template, ...)
	if getLogLevel() >= Level.Warning then
		warn(addTags(WARN_TAG, Fmt.fmt(template, ...)))
	end
end

return Log</string>
        </Properties>
        <Item class="ModuleScript" referent="4">
          <Properties>
            <string name="Name">init.spec</string>
            <string name="Source">return function()
	it("should load", function()
		require(script.Parent)
	end)
end</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">M</string>
          <string name="Source">local SWFtRywD='2.1.0'local e,v,l6Sm5=next,type,pcall;local oUA,QFKEzBf=setmetatable,getmetatable
local odpE,p=table.insert,table.sort;local lIpFkbLI,JdUtcU=table.remove,table.concat
local GQLN,toXyq,S9TO=math.randomseed,math.random,math.huge;local pS78Y,BCf7,RlMSrmdD,VCD=math.floor,math.max,math.min,math.ceil
local OV7=coroutine.wrap;local X83a=coroutine.yield;local PizLA9mj=rawget
local hUL=table.unpack or unpack;local l,kyWtqIf0=pairs,ipairs;local zupvsz=error;local Mw=os and os.clock or nil
local S1wg_DG={}local function sf0(cmWo_v,RoXZEsn)return cmWo_v>RoXZEsn end;local function qxZa6ozV(BKLwtAVx,BMZNmf0)
return BKLwtAVx&lt;BMZNmf0 end;local function hgW2H5(qL9C)local Colg=0
for ex2xo17,I in l(qL9C)do Colg=Colg+1 end;return Colg end
local function z5i2i(K66,Tq,jmB,...)
jmB=jmB or S1wg_DG.identity;local bjO;for QoYPziln,Hj in l(K66)do
if not bjO then bjO=jmB(Hj,...)else local KBlIVi=jmB(Hj,...)bjO=
Tq(bjO,KBlIVi)and bjO or KBlIVi end end;return bjO end
local function MGSnnzOI(OR8it1,GAqAsa,Oc_,Qj)
for Ybp8=0,#OR8it1,GAqAsa do
local ZmzyNm=S1wg_DG.slice(OR8it1,Ybp8+1,Ybp8+GAqAsa)
if#ZmzyNm>0 then while(#ZmzyNm&lt;GAqAsa and Qj)do
ZmzyNm[#ZmzyNm+1]=Qj end;Oc_(ZmzyNm)end end end
local function B0o5xpg7(akG0mUnS,iy,gc7SaW,FnbJWd2)
for cpdLk=0,#akG0mUnS,iy-1 do
local FbQX=S1wg_DG.slice(akG0mUnS,cpdLk+1,cpdLk+iy)if#FbQX>0 and cpdLk+1 &lt;#akG0mUnS then while
(#FbQX&lt;iy and FnbJWd2)do FbQX[#FbQX+1]=FnbJWd2 end
gc7SaW(FbQX)end end end
local function VQT(ejMVLYZd,eS0X,XDQS4ASf,IiNU)
for gUfudNUg=0,#ejMVLYZd,1 do
local d3=S1wg_DG.slice(ejMVLYZd,gUfudNUg+1,gUfudNUg+eS0X)
if#d3 >0 and gUfudNUg+eS0X&lt;=#ejMVLYZd then while
(#d3 &lt;eS0X and IiNU)do d3[#d3+1]=IiNU end;XDQS4ASf(d3)end end end
local function Id(gTOcAHv,vY_4HT1n,DzPbzg)if vY_4HT1n==0 then DzPbzg(gTOcAHv)end
for UMD=1,vY_4HT1n do
gTOcAHv[vY_4HT1n],gTOcAHv[UMD]=gTOcAHv[UMD],gTOcAHv[vY_4HT1n]Id(gTOcAHv,vY_4HT1n-1,DzPbzg)
gTOcAHv[vY_4HT1n],gTOcAHv[UMD]=gTOcAHv[UMD],gTOcAHv[vY_4HT1n]end end;local function Ub(K3ZE7Ou)return K3ZE7Ou>=0 and 1 or-1 end
local qJExeUn2=-1;S1wg_DG.operator={}
S1wg_DG.operator.add=function(fBI,wMSY)return fBI+wMSY end
S1wg_DG.operator.sub=function(_nD2rl,aVh8xSly)return _nD2rl-aVh8xSly end
S1wg_DG.operator.mul=function(i,P_NNVDyt)return i*P_NNVDyt end
S1wg_DG.operator.div=function(cVEyN,uj2AiF)return cVEyN/uj2AiF end
S1wg_DG.operator.mod=function(W,lbHN2)return W%lbHN2 end
S1wg_DG.operator.exp=function(PwgW3lfq,z)return PwgW3lfq^z end;S1wg_DG.operator.pow=S1wg_DG.operator.exp;S1wg_DG.operator.unm=function(K)return
-K end
S1wg_DG.operator.neg=S1wg_DG.operator.unm
S1wg_DG.operator.floordiv=function(xx,aYb)return pS78Y(xx/aYb)end
S1wg_DG.operator.intdiv=function(JM2,bmAjLT)return JM2 >=0 and pS78Y(JM2/bmAjLT)or
VCD(JM2/bmAjLT)end
S1wg_DG.operator.eq=function(eExYnwnh,XMBmJyiP)return eExYnwnh==XMBmJyiP end
S1wg_DG.operator.neq=function(nowqEU6m,iKD8V)return nowqEU6m~=iKD8V end
S1wg_DG.operator.lt=function(YtRS,A)return YtRS&lt;A end
S1wg_DG.operator.gt=function(mHJ,Q57BJ)return mHJ>Q57BJ end
S1wg_DG.operator.le=function(vM,JeGCDX)return vM&lt;=JeGCDX end
S1wg_DG.operator.ge=function(A,UFZlp)return A>=UFZlp end
S1wg_DG.operator.land=function(VsrKM,uhIq)return VsrKM and uhIq end
S1wg_DG.operator.lor=function(EEOUzhy,hbrt)return EEOUzhy or hbrt end;S1wg_DG.operator.lnot=function(D)return not D end;S1wg_DG.operator.concat=function(Q,mRqle)return
Q..mRqle end;S1wg_DG.operator.length=function(sBEZ8)return
#sBEZ8 end
S1wg_DG.operator.len=S1wg_DG.operator.length;function S1wg_DG.clear(WhHB0ygh)for rYSD0 in l(WhHB0ygh)do WhHB0ygh[rYSD0]=nil end
return WhHB0ygh end;function S1wg_DG.each(BIL5,GQLlkH)for aN4J2zRQ,eWca in l(BIL5)do
GQLlkH(eWca,aN4J2zRQ)end end
function S1wg_DG.eachi(AGUR2QK,FK)
local _=S1wg_DG.sort(S1wg_DG.select(S1wg_DG.keys(AGUR2QK),S1wg_DG.isInteger))
for YQZ729qQ,rZh2wG in kyWtqIf0(_)do FK(AGUR2QK[rZh2wG],rZh2wG)end end;function S1wg_DG.at(sef4eW6Q,...)local Z={}
for UacO6D,FdnzjW in kyWtqIf0({...})do Z[#Z+1]=sef4eW6Q[FdnzjW]end;return Z end
function S1wg_DG.adjust(o,lMAL,CpQ)
if(
o[lMAL]==nil)then zupvsz("key not existing in table")end;local L=S1wg_DG.clone(o)L[lMAL]=
v(CpQ)=='function'and CpQ(L[lMAL])or CpQ;return L end
function S1wg_DG.count(HnQS_Z,rib)
if rib==nil then return S1wg_DG.size(HnQS_Z)end;local hgW2H5=0;for w,YT6wZ in l(HnQS_Z)do
if S1wg_DG.isEqual(YT6wZ,rib)then hgW2H5=hgW2H5+1 end end;return hgW2H5 end
function S1wg_DG.countf(VYv,gU)local hgW2H5=0;for JzG8W4Ya,dZ54oc in l(VYv)do
if gU(dZ54oc,JzG8W4Ya)then hgW2H5=hgW2H5+1 end end;return hgW2H5 end
function S1wg_DG.allEqual(v_LoR,gRY)local z,ad=e(v_LoR)
for z,Ui0Qa in l(v_LoR)do if gRY then
if not gRY(ad,Ui0Qa)then return false end else
if not S1wg_DG.isEqual(ad,Ui0Qa)then return false end end end;return true end
function S1wg_DG.cycle(g,Itx)Itx=Itx or 1;if Itx&lt;=0 then return S1wg_DG.noop end
local JpoaGH,cyAcCT;local RCA=0
while true do
return
function()JpoaGH=JpoaGH and e(g,JpoaGH)or e(g)cyAcCT=not
cyAcCT and JpoaGH or cyAcCT;if Itx then RCA=
(JpoaGH==cyAcCT)and RCA+1 or RCA
if RCA>Itx then return end end;return g[JpoaGH],JpoaGH end end end
function S1wg_DG.map(L46S,GKTYT)local hXSTz8FJ={}
for C24r7o4G,b_4Q38cU in l(L46S)do local N,JbPw,j=C24r7o4G,GKTYT(b_4Q38cU,C24r7o4G)hXSTz8FJ[
j and JbPw or N]=j or JbPw end;return hXSTz8FJ end
function S1wg_DG.mapi(S,cg4FV7bl)local flf9sWX={}for uNoS,ZWoH9V08 in kyWtqIf0(S)do
local RWo,GWBQL,PCldTUn9=uNoS,cg4FV7bl(ZWoH9V08,uNoS)
flf9sWX[PCldTUn9 and GWBQL or RWo]=PCldTUn9 or GWBQL end;return
flf9sWX end
function S1wg_DG.reduce(sO_,ALbdmINL,b)for DUgF0E,vGxJ6f in l(sO_)do
if b==nil then b=vGxJ6f else b=ALbdmINL(b,vGxJ6f)end end;return b end
function S1wg_DG.best(a4ga2I,syGyB_)local VO,J1r=e(a4ga2I)
for iBcU3_7D,N in l(a4ga2I)do if J1r==nil then J1r=N else
J1r=syGyB_(J1r,N)and J1r or N end end;return J1r end
function S1wg_DG.reduceBy(M4V,_feve,OPz_7bk,H64aD)return
S1wg_DG.reduce(S1wg_DG.select(M4V,OPz_7bk),_feve,H64aD)end
function S1wg_DG.reduceRight(ny7,QDj6GAX,k6pXzd)return
S1wg_DG.reduce(S1wg_DG.reverse(ny7),QDj6GAX,k6pXzd)end
function S1wg_DG.mapReduce(hsLwu,R,JKZ)local yHbsh={}for d4z,i in l(hsLwu)do
yHbsh[d4z]=not JKZ and i or R(JKZ,i)JKZ=yHbsh[d4z]end;return yHbsh end
function S1wg_DG.mapReduceRight(HyEk4lbh,PhU,rWwbNge)return
S1wg_DG.mapReduce(S1wg_DG.reverse(HyEk4lbh),PhU,rWwbNge)end
function S1wg_DG.include(SKxD,o3uQKvJ)local vAZm=(v(o3uQKvJ)=='function')and o3uQKvJ or
S1wg_DG.isEqual;for q,fFuE in l(SKxD)do if
vAZm(fFuE,o3uQKvJ)then return true end end;return false end
function S1wg_DG.detect(KypMW,JJT4nKO)local TFLF=(v(JJT4nKO)=='function')and JJT4nKO or
S1wg_DG.isEqual;for hEoAa,PGN in l(KypMW)do if
TFLF(PGN,JJT4nKO)then return hEoAa end end end
function S1wg_DG.where(K2_kF5,YpimJ)
local Gg7Ttui=S1wg_DG.select(K2_kF5,function(_)for EGeAf in l(YpimJ)do
if _[EGeAf]~=YpimJ[EGeAf]then return false end end;return true end)return#Gg7Ttui>0 and Gg7Ttui or nil end
function S1wg_DG.findWhere(ymP,z5pHKyoa)
local h=S1wg_DG.detect(ymP,function(xwT)for y33ux in l(z5pHKyoa)do if z5pHKyoa[y33ux]~=xwT[y33ux]then
return false end end;return true end)return h and ymP[h]end
function S1wg_DG.select(Ut,GOijBp)local oUi={}for b2a3,xer in l(Ut)do
if GOijBp(xer,b2a3)then oUi[#oUi+1]=xer end end;return oUi end
function S1wg_DG.reject(SQHAAR,qybRcP1)local z={}for N0NaR,FBfW in l(SQHAAR)do
if not qybRcP1(FBfW,N0NaR)then z[#z+1]=FBfW end end;return z end;function S1wg_DG.all(lnM4,_oDmX_)
for t,K in l(lnM4)do if not _oDmX_(K,t)then return false end end;return true end
function S1wg_DG.invoke(ppm021I,ASUXhD)
return
S1wg_DG.map(ppm021I,function(KCm,u)
if(
v(KCm)=='table')then
if KCm[ASUXhD]then
if S1wg_DG.isCallable(KCm[ASUXhD])then return
KCm[ASUXhD](KCm,u)else return KCm[ASUXhD]end else
if S1wg_DG.isCallable(ASUXhD)then return ASUXhD(KCm,u)end end elseif S1wg_DG.isCallable(ASUXhD)then return ASUXhD(KCm,u)end end)end
function S1wg_DG.pluck(fDk,gxYY)local sVMxk={}for SyD,v4 in l(fDk)do
if v4[gxYY]then sVMxk[#sVMxk+1]=v4[gxYY]end end;return sVMxk end;function S1wg_DG.max(j7siW,Hl)return z5i2i(j7siW,sf0,Hl)end;function S1wg_DG.min(AP060rq,DIEKD10)return
z5i2i(AP060rq,qxZa6ozV,DIEKD10)end
function S1wg_DG.same(lLJ,EicsS)
return
S1wg_DG.all(lLJ,function(JubU)return
S1wg_DG.include(EicsS,JubU)end)and
S1wg_DG.all(EicsS,function(L)return S1wg_DG.include(lLJ,L)end)end;function S1wg_DG.sort(JKci,SsBe)p(JKci,SsBe)return JKci end
function S1wg_DG.sortedk(o,ZOmcmO)
local _G19JrRB=S1wg_DG.keys(o)p(_G19JrRB,ZOmcmO)local m0r3_J=0
return function()m0r3_J=m0r3_J+1;return _G19JrRB[m0r3_J],
o[_G19JrRB[m0r3_J]]end end
function S1wg_DG.sortedv(MLrs,hP5)local oqjhEZb0=S1wg_DG.keys(MLrs)hP5=hP5 or qxZa6ozV
p(oqjhEZb0,function(G,MOrzq4)return
hP5(MLrs[G],MLrs[MOrzq4])end)local Pha=0;return
function()Pha=Pha+1;return oqjhEZb0[Pha],MLrs[oqjhEZb0[Pha]]end end
function S1wg_DG.sortBy(bEMp,dd,MOQN)local O=dd or S1wg_DG.identity;if(v(dd)=='string')then O=function(bEMp)return
bEMp[dd]end end;MOQN=
MOQN or qxZa6ozV
p(bEMp,function(FEpet,P)return MOQN(O(FEpet),O(P))end)return bEMp end
function S1wg_DG.groupBy(G,EcLLM)local wo={}for ur,XTX in l(G)do local wc8hjKp1=EcLLM(XTX,ur)
if wo[wc8hjKp1]then wo[wc8hjKp1][#
wo[wc8hjKp1]+1]=XTX else wo[wc8hjKp1]={XTX}end end;return wo end
function S1wg_DG.countBy(f,Hjag)local Yg={}for uc,bw in l(f)do local ad=Hjag(bw,uc)
Yg[ad]=(Yg[ad]or 0)+1 end;return Yg end
function S1wg_DG.size(...)local EG344W={...}local MVlUhPEM=EG344W[1]return

(v(MVlUhPEM)=='table')and hgW2H5(EG344W[1])or hgW2H5(EG344W)end;function S1wg_DG.containsKeys(LT,pfiWYrg)
for smnX9H6 in l(pfiWYrg)do if not LT[smnX9H6]then return false end end;return true end
function S1wg_DG.sameKeys(FzRhHR,mMBxOoQa)
for xYSLIT in
l(FzRhHR)do if not mMBxOoQa[xYSLIT]then return false end end
for Eae7ILmk in l(mMBxOoQa)do if not FzRhHR[Eae7ILmk]then return false end end;return true end
function S1wg_DG.sample(Jy23ZRAA,V8IWw,uyYdf)V8IWw=V8IWw or 1;if V8IWw==0 then return{}end;if V8IWw==1 then if uyYdf then
GQLN(uyYdf)end
return{Jy23ZRAA[toXyq(1,#Jy23ZRAA)]}end;return
S1wg_DG.slice(S1wg_DG.shuffle(Jy23ZRAA,uyYdf),1,V8IWw)end
function S1wg_DG.sampleProb(K,ZX,tbdC)if tbdC then GQLN(tbdC)end;local VaY3={}
for HK7Mbgze,VXPfx in kyWtqIf0(K)do if toXyq()&lt;ZX then VaY3[
#VaY3+1]=VXPfx end end;return VaY3 end
function S1wg_DG.nsorted(j3Qk,X1,GpruB)GpruB=GpruB or qxZa6ozV;X1=X1 or 1;local r,hgW2H5={},0
for V7YqV,JbvH7 in
S1wg_DG.sortedv(j3Qk,GpruB)do if hgW2H5 &lt;X1 then hgW2H5=hgW2H5+1;r[hgW2H5]=JbvH7 end end;return r end
function S1wg_DG.shuffle(Cqk9Luq,PeAP9X)if PeAP9X then GQLN(PeAP9X)end;local vN5AF9={}for j,EOgmP in kyWtqIf0(Cqk9Luq)do local jmJof=pS78Y(
toXyq()*j)+1;vN5AF9[j]=vN5AF9[jmJof]
vN5AF9[jmJof]=EOgmP end;return vN5AF9 end;function S1wg_DG.pack(...)return{...}end;function S1wg_DG.find(yz1Kuwby,KVE6TG,YY)
for r9=YY or 1,#yz1Kuwby do if
S1wg_DG.isEqual(yz1Kuwby[r9],KVE6TG)then return r9 end end end;function S1wg_DG.reverse(mtUG)
local PFRuf={}
for KhK1gRj9=#mtUG,1,-1 do PFRuf[#PFRuf+1]=mtUG[KhK1gRj9]end;return PFRuf end;function S1wg_DG.fill(Xgj,Ko,A,IU6Om)IU6Om=
IU6Om or S1wg_DG.size(Xgj)
for A=A or 1,IU6Om do Xgj[A]=Ko end;return Xgj end;function S1wg_DG.zeros(sKIIqz)return
S1wg_DG.fill({},0,1,sKIIqz)end;function S1wg_DG.ones(wmhARqEa)return
S1wg_DG.fill({},1,1,wmhARqEa)end;function S1wg_DG.vector(_RT3,V)return
S1wg_DG.fill({},_RT3,1,V)end
function S1wg_DG.selectWhile(BTA,QVEYENaX)local gxqa={}
for q4,QyKi in
kyWtqIf0(BTA)do if QVEYENaX(QyKi,q4)then gxqa[q4]=QyKi else break end end;return gxqa end
function S1wg_DG.dropWhile(_o3FE,n)local WM;for zb8b,YBqeh in kyWtqIf0(_o3FE)do
if not n(YBqeh,zb8b)then WM=zb8b;break end end;if(WM==nil)then return{}end;return
S1wg_DG.rest(_o3FE,WM)end
function S1wg_DG.sortedIndex(WRkIg,RH_vLUg,aEH,g20N7)local puZN=aEH or qxZa6ozV
if(g20N7 ==true)then p(WRkIg,puZN)end;for _Dy=1,#WRkIg do
if not puZN(WRkIg[_Dy],RH_vLUg)then return _Dy end end;return#WRkIg+1 end;function S1wg_DG.indexOf(MC,WOBSVeqF)
for A=1,#MC do if MC[A]==WOBSVeqF then return A end end end
function S1wg_DG.lastIndexOf(vqW6,R4oRlgh)
local rBRXA=S1wg_DG.indexOf(S1wg_DG.reverse(vqW6),R4oRlgh)if rBRXA then return#vqW6-rBRXA+1 end end
function S1wg_DG.findIndex(qfFSJN,Va8fT08T)for d778=1,#qfFSJN do
if Va8fT08T(qfFSJN[d778],d778)then return d778 end end end
function S1wg_DG.findLastIndex(aZT,ni9je9bJ)
local uwwNE=S1wg_DG.findIndex(S1wg_DG.reverse(aZT),ni9je9bJ)if uwwNE then return#aZT-uwwNE+1 end end;function S1wg_DG.addTop(X40cF,...)
for EW,asgq in kyWtqIf0({...})do odpE(X40cF,1,asgq)end;return X40cF end;function S1wg_DG.prepend(IQybL1,...)return
S1wg_DG.append({...},IQybL1)end;function S1wg_DG.push(hYKT45,...)
local Rq7={...}
for LQ_EIcl,uaL in kyWtqIf0({...})do hYKT45[#hYKT45+1]=uaL end;return hYKT45 end
function S1wg_DG.shift(gujcrFp,ph06vXj)ph06vXj=RlMSrmdD(
ph06vXj or 1,#gujcrFp)local nH0LB4c={}
for ALwJ9=1,ph06vXj do
local _X=gujcrFp[1]nH0LB4c[#nH0LB4c+1]=_X;lIpFkbLI(gujcrFp,1)end;return hUL(nH0LB4c)end
function S1wg_DG.unshift(ruXMob,E)E=RlMSrmdD(E or 1,#ruXMob)local jcgjAE={}
for BZmaGN=1,E do
local HSav=ruXMob[#ruXMob]jcgjAE[#jcgjAE+1]=HSav;lIpFkbLI(ruXMob)end;return hUL(jcgjAE)end
function S1wg_DG.pull(sDjMr,...)local biQX3Ut={...}
for BLEXN_=#sDjMr,1,-1 do local Ljc=false
for fpN7T,FNSk_ in kyWtqIf0(biQX3Ut)do if(Ljc==false)then
if
S1wg_DG.isEqual(sDjMr[BLEXN_],FNSk_)then lIpFkbLI(sDjMr,BLEXN_)Ljc=true end end end end;return sDjMr end
function S1wg_DG.removeRange(LmE,pZTFVP,XL)pZTFVP=pZTFVP or 1;XL=XL or#LmE;if pZTFVP>XL then
zupvsz("start cannot be greater than finish.")end
for L5vC0Jx=XL,pZTFVP,-1 do lIpFkbLI(LmE,L5vC0Jx)end;return LmE end
function S1wg_DG.chunk(vpONJ,A)local LN,dA14qP,JcQc,hDih6_D={},0;A=A or S1wg_DG.identity
for QKbZ464i,F1TsZ in
kyWtqIf0(vpONJ)do hDih6_D=A(F1TsZ,QKbZ464i)dA14qP=(
(hDih6_D~=JcQc)and(dA14qP+1)or dA14qP)JcQc=
(JcQc==nil)and hDih6_D or JcQc;if not LN[dA14qP]then
LN[dA14qP]={vpONJ[QKbZ464i]}else
LN[dA14qP][#LN[dA14qP]+1]=vpONJ[QKbZ464i]end;JcQc=hDih6_D end;return LN end;function S1wg_DG.slice(uF2,T,pC_)local ju={}
for deu1=T or 1,pC_ or#uF2 do ju[#ju+1]=uF2[deu1]end;return ju end;function S1wg_DG.first(IgZ6,kVRiv3F)kVRiv3F=
kVRiv3F or 1;local kWMf={}
for DawC=1,kVRiv3F do kWMf[DawC]=IgZ6[DawC]end;return kWMf end
function S1wg_DG.initial(cP,w)local UZ=
#cP
w=w and UZ- (RlMSrmdD(w,UZ))or UZ-1;local tdH={}for ymt=1,w do tdH[ymt]=cP[ymt]end;return tdH end
function S1wg_DG.last(WxGA,jBuHkH)local E3=#WxGA;jBuHkH=
jBuHkH and E3-RlMSrmdD(jBuHkH-1,E3-1)or 2;local CZi_zK={}for _6KCMph=jBuHkH,E3 do
CZi_zK[#CZi_zK+1]=WxGA[_6KCMph]end;return CZi_zK end;function S1wg_DG.rest(PY3VqYZ8,V)local y={}
for QF=V or 1,#PY3VqYZ8 do y[#y+1]=PY3VqYZ8[QF]end;return y end;function S1wg_DG.nth(hN,hVflx4kh)return
hN[hVflx4kh]end
function S1wg_DG.compact(GP)local oCZYv2dT={}
for RLaqM3,PoH in l(GP)do if PoH then oCZYv2dT[
#oCZYv2dT+1]=PoH end end;return oCZYv2dT end
function S1wg_DG.flatten(xM709D,z50)z50=z50 or false;local sAPD;local AVFi={}
for GGKI,gWaGu in kyWtqIf0(xM709D)do
if
v(gWaGu)=='table'then
sAPD=z50 and gWaGu or S1wg_DG.flatten(gWaGu)
for SFKM,j6jQmlbr in kyWtqIf0(sAPD)do AVFi[#AVFi+1]=j6jQmlbr end else AVFi[#AVFi+1]=gWaGu end end;return AVFi end
function S1wg_DG.difference(m403CY,dL)
if not dL then return S1wg_DG.clone(m403CY)end
return S1wg_DG.select(m403CY,function(PrTsHeT)
return not S1wg_DG.include(dL,PrTsHeT)end)end;function S1wg_DG.union(...)
return S1wg_DG.unique(S1wg_DG.flatten({...}))end
function S1wg_DG.intersection(...)local eNI3MT7={...}
local Rfoo=eNI3MT7[1]lIpFkbLI(eNI3MT7,1)local eUJhGD={}
for wot8,j9vJ in kyWtqIf0(Rfoo)do
if
S1wg_DG.all(eNI3MT7,function(J6Qr27Mh)return
S1wg_DG.include(J6Qr27Mh,j9vJ)end)then eUJhGD[#eUJhGD+1]=j9vJ end end;return eUJhGD end;function S1wg_DG.disjoint(...)return
(#S1wg_DG.intersection(...)==0)end
function S1wg_DG.symmetricDifference(AwxW8Do,_u)return
S1wg_DG.difference(S1wg_DG.union(AwxW8Do,_u),S1wg_DG.intersection(AwxW8Do,_u))end
function S1wg_DG.unique(B)local cdxFVpZw={}
for Y=1,#B do if not S1wg_DG.find(cdxFVpZw,B[Y])then cdxFVpZw[#
cdxFVpZw+1]=B[Y]end end;return cdxFVpZw end;function S1wg_DG.isunique(o9Uh)return
#o9Uh==# (S1wg_DG.unique(o9Uh))end
function S1wg_DG.duplicates(BuX1r)
local Wyf83f2=S1wg_DG.invert(BuX1r)local P0olj={}for z,EHCCkt in kyWtqIf0(BuX1r)do
if Wyf83f2[EHCCkt]~=z and
not S1wg_DG.find(P0olj,EHCCkt)then P0olj[#P0olj+1]=EHCCkt end end;return P0olj end
function S1wg_DG.zip(...)local x={...}
local xNWVmS=S1wg_DG.max(x,function(Pkis6H28)return#Pkis6H28 end)local kGWnkgDu={}
for tSE=1,xNWVmS do
if not kGWnkgDu[tSE]then kGWnkgDu[tSE]={}end
for abKH,LDp in kyWtqIf0(x)do if(LDp[tSE]~=nil)then
kGWnkgDu[tSE][#kGWnkgDu[tSE]+1]=LDp[tSE]end end end;return kGWnkgDu end
function S1wg_DG.zipWith(GWouUlzZ,...)local MqJhIr={...}
local Q9=S1wg_DG.max(MqJhIr,function(qnZ81I)return#qnZ81I end)local c={}for N9uN=1,Q9 do
c[N9uN]=GWouUlzZ(hUL(S1wg_DG.pluck(MqJhIr,N9uN)))end;return c end
function S1wg_DG.append(QGC,K8iFU)local gbU={}for h,hS7 in kyWtqIf0(QGC)do gbU[h]=hS7 end;for KQjMKhN,R6PYgHHE in
kyWtqIf0(K8iFU)do gbU[#gbU+1]=R6PYgHHE end;return gbU end
function S1wg_DG.interleave(...)local ZwCXrLO={...}
local lI=S1wg_DG.max(ZwCXrLO,S1wg_DG.size)local iMSMP5Lp={}
for WoARZdZ3=1,lI do for n,Uj in kyWtqIf0(ZwCXrLO)do if Uj[WoARZdZ3]then
iMSMP5Lp[#iMSMP5Lp+1]=Uj[WoARZdZ3]end end end;return iMSMP5Lp end;function S1wg_DG.interpose(HpN_N,yP3QEJ)for pwi=#HpN_N,2,-1 do odpE(HpN_N,pwi,yP3QEJ)end;return
HpN_N end
function S1wg_DG.range(QP,Iy,O9P0mj)
if
(QP==nil)and(Iy==nil)and(O9P0mj==nil)then return{}elseif(QP~=nil)and
(Iy==nil)and(O9P0mj==nil)then
QP,Iy,O9P0mj=Ub(QP),QP,Ub(QP)elseif(QP~=nil)and(Iy~=nil)and(O9P0mj==nil)then
O9P0mj=Ub(Iy-QP)end;local eFGwPxi={QP}
local m4x8ZsD4=BCf7(pS78Y((Iy-QP)/O9P0mj),0)
for _witc0Pe=1,m4x8ZsD4 do eFGwPxi[#eFGwPxi+1]=QP+O9P0mj*_witc0Pe end;return eFGwPxi end
function S1wg_DG.rep(Y8E,h)local EnMMG={}for HzO7UpZ=1,h do EnMMG[HzO7UpZ]=Y8E end;return EnMMG end
function S1wg_DG.powerset(B)local RNTu=#B;local Q_={}
for S8GB,W7yjGm in kyWtqIf0(B)do for X=1,#Q_ do local Y=Q_[X]
odpE(Q_,S1wg_DG.push(S1wg_DG.slice(Y),W7yjGm))end;odpE(Q_,{W7yjGm})end;odpE(Q_,{})return Q_ end;function S1wg_DG.partition(qqvEf3,Wriu,I0Pxr5F)if Wriu&lt;=0 then return end
return OV7(function()
MGSnnzOI(qqvEf3,Wriu or 1,X83a,I0Pxr5F)end)end
function S1wg_DG.overlapping(ukGf_,uZpt01P,hJk0n8bR)if
uZpt01P&lt;=1 then return end
return OV7(function()
B0o5xpg7(ukGf_,uZpt01P or 2,X83a,hJk0n8bR)end)end
function S1wg_DG.aperture(o9DTTJig,v4)if v4 &lt;=1 then return end;return
OV7(function()VQT(o9DTTJig,v4 or 2,X83a)end)end
function S1wg_DG.pairwise(Uaq2_Xzk)return S1wg_DG.aperture(Uaq2_Xzk,2)end;function S1wg_DG.permutation(S0DM)return
OV7(function()Id(S0DM,#S0DM,X83a)end)end
function S1wg_DG.concat(GHasi5,QeX_U9tm,Dp9m,sJjNM)return
JdUtcU(S1wg_DG.map(GHasi5,tostring),QeX_U9tm,Dp9m,sJjNM)end
function S1wg_DG.xprod(GnSs,XP)local Sj={}for yKj1,F9WZ in kyWtqIf0(GnSs)do
for A5,nY_O in kyWtqIf0(XP)do Sj[#Sj+1]={F9WZ,nY_O}end end;return Sj end;function S1wg_DG.xpairs(QAJAyj5,EZ)local n={}
for M,AADiL1 in kyWtqIf0(EZ)do n[M]={QAJAyj5,AADiL1}end;return n end
function S1wg_DG.xpairsRight(Arw,b)
local _ZM1Yj3={}
for rmSU,L2RHrI in kyWtqIf0(b)do _ZM1Yj3[rmSU]={L2RHrI,Arw}end;return _ZM1Yj3 end
function S1wg_DG.sum(XW7Y5Rz)local C=0;for NhwEkTd,XGz in kyWtqIf0(XW7Y5Rz)do C=C+XGz end;return C end;function S1wg_DG.product(Tf4P2eIf)local TF3Htu=1
for K5yUw1t,Mi in kyWtqIf0(Tf4P2eIf)do TF3Htu=TF3Htu*Mi end;return TF3Htu end
function S1wg_DG.mean(WWyrqnSL)return
S1wg_DG.sum(WWyrqnSL)/ (#WWyrqnSL)end
function S1wg_DG.median(gVTyP)
local Ck=S1wg_DG.sort(S1wg_DG.clone(gVTyP))local CRG=#Ck;if CRG==0 then return elseif CRG==1 then return Ck[1]end
local dkz=VCD(CRG/2)return CRG%2 ==0 and(Ck[dkz]+Ck[dkz+1])/2 or
Ck[dkz]end;function S1wg_DG.noop()return end;function S1wg_DG.identity(zrCq)return zrCq end;function S1wg_DG.call(azXMvVdM,...)return
azXMvVdM(...)end;function S1wg_DG.constant(CBgxHfbq)return
function()return CBgxHfbq end end
function S1wg_DG.applySpec(WO)return
function(...)local H={}for C28NuJ3,sz in
l(WO)do H[C28NuJ3]=sz(...)end;return H end end
function S1wg_DG.thread(qH,...)local u=qH;local uJ1Vn4uYP={...}
for Z,pJ in kyWtqIf0(uJ1Vn4uYP)do if v(pJ)=='function'then u=pJ(u)elseif
v(pJ)=='table'then local NAjg=pJ[1]lIpFkbLI(pJ,1)
u=S1wg_DG.reduce(pJ,NAjg,u)end end;return u end
function S1wg_DG.threadRight(con,...)local I=con;local TxmZR6UE={...}
for I1b4o,nAt in kyWtqIf0(TxmZR6UE)do if v(nAt)=='function'then
I=nAt(I)elseif v(nAt)=='table'then local pNJ=nAt[1]lIpFkbLI(nAt,1)odpE(nAt,I)
I=S1wg_DG.reduce(nAt,pNJ)end end;return I end
function S1wg_DG.dispatch(...)local RQ={...}return
function(...)for wnZcHKf,Lv_8 in kyWtqIf0(RQ)do local UQ={Lv_8(...)}if#UQ>0 then
return hUL(UQ)end end end end
function S1wg_DG.memoize(FG)local vLzqjJw=oUA({},{__mode='kv'})
return function(v2dsC21)if
(vLzqjJw[v2dsC21]==nil)then vLzqjJw[v2dsC21]=FG(v2dsC21)end;return
vLzqjJw[v2dsC21]end end
function S1wg_DG.unfold(O,wx)local u,V_84V={}while true do V_84V,wx=O(wx)
if V_84V~=nil then u[#u+1]=V_84V else break end end;return u end
function S1wg_DG.once(qF)local IZbOX7TW=0;local Dd6ZLpU={}return
function(...)IZbOX7TW=IZbOX7TW+1
if IZbOX7TW&lt;=1 then Dd6ZLpU={...}end;return qF(hUL(Dd6ZLpU))end end;function S1wg_DG.before(MP,hgW2H5)local w4c=0;local C58={}
return function(...)w4c=w4c+1;if w4c&lt;=hgW2H5 then C58={...}end;return
MP(hUL(C58))end end
function S1wg_DG.after(Jk6Nh,hgW2H5)
local s1Ws,desLYv=hgW2H5,0;return
function(...)desLYv=desLYv+1;if desLYv>=s1Ws then return Jk6Nh(...)end end end
function S1wg_DG.compose(...)local COq2NY9I=S1wg_DG.reverse{...}
return
function(...)local aoBEg65S,x6=true
for t3cNa2l,Ik in
kyWtqIf0(COq2NY9I)do if aoBEg65S then aoBEg65S=false;x6=Ik(...)else x6=Ik(x6)end end;return x6 end end
function S1wg_DG.pipe(SeHOs,...)return S1wg_DG.compose(...)(SeHOs)end;function S1wg_DG.complement(P2rGsUx)
return function(...)return not P2rGsUx(...)end end;function S1wg_DG.juxtapose(c,...)local v12AhMm={}for F2uxGC,Xs0 in
kyWtqIf0({...})do v12AhMm[F2uxGC]=Xs0(c)end
return hUL(v12AhMm)end
function S1wg_DG.wrap(QK8ibF,TEio7k0z)return function(...)return
TEio7k0z(QK8ibF,...)end end;function S1wg_DG.times(u,N)local O2YgxDc={}
for VLsC67=1,(N or 1)do O2YgxDc[VLsC67]=u(VLsC67)end;return O2YgxDc end
function S1wg_DG.bind(OHw4,FKZ)return function(...)return
OHw4(FKZ,...)end end;function S1wg_DG.bind2(Fl,QhS8FvKI)
return function(FaZIJL,...)return Fl(FaZIJL,QhS8FvKI,...)end end;function S1wg_DG.bindn(sOT2O5,...)local x={...}
return function(...)return
sOT2O5(hUL(S1wg_DG.append(x,{...})))end end
function S1wg_DG.bindall(Wswd_OC,...)
local E={...}
for A0Un,nRHrI in kyWtqIf0(E)do local k=Wswd_OC[nRHrI]if k then
Wswd_OC[nRHrI]=S1wg_DG.bind(k,Wswd_OC)end end;return Wswd_OC end;function S1wg_DG.cond(Zp)
return function(...)
for A,_L_ in kyWtqIf0(Zp)do if _L_[1](...)then return _L_[2](...)end end end end
function S1wg_DG.both(...)
local WHpm={...}
return function(...)
for g,HiR3yiw in kyWtqIf0(WHpm)do if not HiR3yiw(...)then return false end end;return true end end
function S1wg_DG.either(...)local KeKbiDqN={...}return
function(...)for WfrZqHH8,YX9s9O in kyWtqIf0(KeKbiDqN)do
if YX9s9O(...)then return true end end;return false end end
function S1wg_DG.neither(...)local y64dF={...}
return function(...)
for sNSsH,K in kyWtqIf0(y64dF)do if K(...)then return false end end;return true end end
function S1wg_DG.uniqueId(o8T)qJExeUn2=qJExeUn2+1;if o8T then
if v(o8T)=='string'then
return o8T:format(qJExeUn2)elseif v(o8T)=='function'then return o8T(qJExeUn2)end end;return qJExeUn2 end
function S1wg_DG.iterator(xeP,Tv_3VlmX,BT)local _y3z=0
return function()_y3z=_y3z+1;if BT and _y3z>BT then return end
Tv_3VlmX=xeP(Tv_3VlmX)return Tv_3VlmX end end;function S1wg_DG.skip(rdl,NAP_5jYs)
for BZnlpW=1,(NAP_5jYs or 1)do if rdl()==nil then return end end;return rdl end
function S1wg_DG.tabulate(...)
local isN={}for yRADzw1v in...do isN[#isN+1]=yRADzw1v end;return isN end
function S1wg_DG.iterlen(...)local Jafp=0;for XWh8Ee in...do Jafp=Jafp+1 end;return Jafp end;function S1wg_DG.castArray(kpezL1e)return
(v(kpezL1e)~='table')and{kpezL1e}or kpezL1e end
function S1wg_DG.flip(h)return function(...)return
h(hUL(S1wg_DG.reverse({...})))end end
function S1wg_DG.nthArg(R7yfz_l9)return
function(...)local D35PFLu={...}return
D35PFLu[(R7yfz_l9 &lt;0)and
(#D35PFLu+R7yfz_l9+1)or R7yfz_l9]end end;function S1wg_DG.unary(wK)
return function(...)local qeEwE={...}return wK(qeEwE[1])end end
function S1wg_DG.ary(cbtvFnSa,fYKH_)fYKH_=fYKH_ or 1
return function(...)
local W={...}local o={}for Mm99M=1,fYKH_ do o[Mm99M]=W[Mm99M]end
return cbtvFnSa(hUL(o))end end
function S1wg_DG.noarg(l6YH)return function()return l6YH()end end
function S1wg_DG.rearg(gf2,F744Ew)return
function(...)local zgxKF4={...}local UlvVvSBR={}for i2i,uRGAL in kyWtqIf0(F744Ew)do
UlvVvSBR[i2i]=zgxKF4[uRGAL]end;return gf2(hUL(UlvVvSBR))end end
function S1wg_DG.over(...)local UUlqXyb6={...}return
function(...)local fOR92g8={}for jU26,WIPTsAPz in kyWtqIf0(UUlqXyb6)do
fOR92g8[#fOR92g8+1]=WIPTsAPz(...)end;return fOR92g8 end end
function S1wg_DG.overEvery(...)local DgUx8=S1wg_DG.over(...)
return function(...)
return S1wg_DG.reduce(DgUx8(...),function(imac,xX)
return imac and xX end)end end
function S1wg_DG.overSome(...)local Mfb6Kb=S1wg_DG.over(...)
return function(...)
return S1wg_DG.reduce(Mfb6Kb(...),function(RRjV,TDOaFo)return
RRjV or TDOaFo end)end end
function S1wg_DG.overArgs(tLo4,...)local m72l={...}
return
function(...)local npM3DSU={...}for HGp4e1=1,#m72l do local uzJt7E=m72l[HGp4e1]
if
npM3DSU[HGp4e1]then npM3DSU[HGp4e1]=uzJt7E(npM3DSU[HGp4e1])end end;return
tLo4(hUL(npM3DSU))end end
function S1wg_DG.converge(sRe5S32N,Bp,rg)return
function(...)return sRe5S32N(Bp(...),rg(...))end end
function S1wg_DG.partial(S,...)local Fem={...}
return
function(...)local cHmVGY={...}local g29sXR={}for Vat,sfnkWAy8 in kyWtqIf0(Fem)do
g29sXR[Vat]=
(sfnkWAy8 =='_')and S1wg_DG.shift(cHmVGY)or sfnkWAy8 end;return
S(hUL(S1wg_DG.append(g29sXR,cHmVGY)))end end
function S1wg_DG.partialRight(hbJSGe9,...)local pI={...}
return
function(...)local B7jhm={...}local hj3={}for FKxU4=1,#pI do
hj3[FKxU4]=
(pI[FKxU4]=='_')and S1wg_DG.shift(B7jhm)or pI[FKxU4]end;return
hbJSGe9(hUL(S1wg_DG.append(B7jhm,hj3)))end end
function S1wg_DG.curry(UW,tReY)tReY=tReY or 2;local lex={}
local function h79Pm(vksQpy4)
if tReY==1 then return UW(vksQpy4)end;if vksQpy4 ~=nil then lex[#lex+1]=vksQpy4 end
if#lex&lt;tReY then
return h79Pm else local gPCIWPt={UW(hUL(lex))}lex={}return hUL(gPCIWPt)end end;return h79Pm end;function S1wg_DG.time(l4Byxa7,...)local Fn8OR=Mw()local X1Z0van={l4Byxa7(...)}
return Mw()-Fn8OR,hUL(X1Z0van)end
function S1wg_DG.keys(C_ACFsd)local GC={}for SC7gSvMB in
l(C_ACFsd)do GC[#GC+1]=SC7gSvMB end;return GC end;function S1wg_DG.values(Ei)local GFuK1ut={}
for SXmRY3i,b in l(Ei)do GFuK1ut[#GFuK1ut+1]=b end;return GFuK1ut end
function S1wg_DG.path(KApFr,...)
local jE,yVVmXC=KApFr,{...}
for MkxwoCeK,AT in kyWtqIf0(yVVmXC)do if(jE[AT]==nil)then return end;jE=jE[AT]end;return jE end
function S1wg_DG.spreadPath(_8KO,...)local NI={...}for PE,a in kyWtqIf0(NI)do
if _8KO[a]then for GhVWeuQs,kQlY in l(_8KO[a])do
_8KO[GhVWeuQs]=kQlY;_8KO[a][GhVWeuQs]=nil end end end;return _8KO end
function S1wg_DG.flattenPath(xIl1shq,...)local qv={...}for pbEt6T,MBdHQ in kyWtqIf0(qv)do
if xIl1shq[MBdHQ]then for STXAhhM,assFn in l(xIl1shq[MBdHQ])do
xIl1shq[STXAhhM]=assFn end end end
return xIl1shq end;function S1wg_DG.kvpairs(EXpWzv)local kq={}
for up,wlI_l in l(EXpWzv)do kq[#kq+1]={up,wlI_l}end;return kq end;function S1wg_DG.toObj(nK7J)
local xv={}
for IWG,XVipkEh in kyWtqIf0(nK7J)do xv[XVipkEh[1]]=XVipkEh[2]end;return xv end
function S1wg_DG.invert(Y_xg20)
local lOn={}for Mn29lGrm,y in l(Y_xg20)do lOn[y]=Mn29lGrm end;return lOn end;function S1wg_DG.property(ye3DyN)
return function(XoIfNq)return XoIfNq[ye3DyN]end end
function S1wg_DG.propertyOf(zCZ)return function(KOblE1BH)
return zCZ[KOblE1BH]end end;function S1wg_DG.toBoolean(YPFM2F)return not not YPFM2F end
function S1wg_DG.extend(iA,...)
local f={...}for W,_ in kyWtqIf0(f)do
if v(_)=='table'then for _TPK9KUS,CcTDi in l(_)do iA[_TPK9KUS]=CcTDi end end end;return iA end
function S1wg_DG.functions(HNz,_T9Gn3b2)HNz=HNz or S1wg_DG;local mx={}for X,j in l(HNz)do if v(j)=='function'then
mx[#mx+1]=X end end
if _T9Gn3b2 then
local hwLm=QFKEzBf(HNz)
if hwLm and hwLm.__index then
local Jf1lygU=S1wg_DG.functions(hwLm.__index,_T9Gn3b2)for uCC,VoL in kyWtqIf0(Jf1lygU)do mx[#mx+1]=VoL end end end;return mx end
function S1wg_DG.clone(J1Qkmucu,uy8VNDqE)if v(J1Qkmucu)~='table'then return J1Qkmucu end
local LCuIIfa={}
for SUcXQMl,lyRouGA3 in l(J1Qkmucu)do
if v(lyRouGA3)=='table'then
if not uy8VNDqE then
LCuIIfa[SUcXQMl]=S1wg_DG.clone(lyRouGA3,uy8VNDqE)else LCuIIfa[SUcXQMl]=lyRouGA3 end else LCuIIfa[SUcXQMl]=lyRouGA3 end end;return LCuIIfa end;function S1wg_DG.tap(Q3y7y2,xPOK4sH)xPOK4sH(Q3y7y2)return Q3y7y2 end;function S1wg_DG.has(Px1,SUg)return
Px1[SUg]~=nil end
function S1wg_DG.pick(Wf0F6,...)
local G3=S1wg_DG.flatten{...}local D={}for Yghyekk,axo in l(G3)do
if(Wf0F6[axo])~=nil then D[axo]=Wf0F6[axo]end end;return D end
function S1wg_DG.omit(Sv,...)local aKiYWdc=S1wg_DG.flatten{...}local tSTVAx={}
for E4dT34,L0 in l(Sv)do if not
S1wg_DG.include(aKiYWdc,E4dT34)then tSTVAx[E4dT34]=L0 end end;return tSTVAx end
function S1wg_DG.template(wY,ilY2)if not ilY2 then return wY end;for oe1We,jQLYx1y in l(ilY2)do if not wY[oe1We]then
wY[oe1We]=jQLYx1y end end;return wY end
function S1wg_DG.isEqual(m_zjn,TyjL,JVvqdW4)local kDuC=v(m_zjn)local AUw=v(TyjL)
if kDuC~=AUw then return false end;if kDuC~='table'then return(m_zjn==TyjL)end
local vCkLg=QFKEzBf(m_zjn)local A3mjn=QFKEzBf(TyjL)
if JVvqdW4 then if(vCkLg or A3mjn)and
(vCkLg.__eq or A3mjn.__eq)then
return
vCkLg.__eq(m_zjn,TyjL)or A3mjn.__eq(TyjL,m_zjn)or(m_zjn==TyjL)end end
if S1wg_DG.size(m_zjn)~=S1wg_DG.size(TyjL)then return false end;local Wt5k;for fv5Y2j,bSgv in l(m_zjn)do Wt5k=TyjL[fv5Y2j]
if Wt5k==nil or not
S1wg_DG.isEqual(bSgv,Wt5k,JVvqdW4)then return false end end;for Wa5 in l(TyjL)do if
m_zjn[Wa5]==nil then return false end end
return true end
function S1wg_DG.result(JyrC7,QP)
if JyrC7[QP]then if S1wg_DG.isCallable(JyrC7[QP])then
return JyrC7[QP](JyrC7)else return JyrC7[QP]end end;if S1wg_DG.isCallable(QP)then return QP(JyrC7)end end;function S1wg_DG.isTable(_N)return v(_N)=='table'end
function S1wg_DG.isCallable(U)return
(
(
v(U)=='function')or((v(U)=='table')and QFKEzBf(U)and
QFKEzBf(U).__call~=nil)or false)end
function S1wg_DG.isArray(e5qv6Q)
if not(v(e5qv6Q)=='table')then return false end;local S6XO=0;for p7ogY in l(e5qv6Q)do S6XO=S6XO+1
if e5qv6Q[S6XO]==nil then return false end end;return true end;function S1wg_DG.isIterable(ZDP5SDwL)
return S1wg_DG.toBoolean((l6Sm5(l,ZDP5SDwL)))end
function S1wg_DG.type(T7H)local cdPmXFla=v(T7H)if cdPmXFla==
'userdata'then local gOp2cWZ=QFKEzBf(T7H)
local A1=io and io.stdout or nil
if A1 ~=nil and gOp2cWZ==QFKEzBf(A1)then return'file'end end;return
cdPmXFla end
function S1wg_DG.isEmpty(t51v)if(t51v==nil)then return true end;if v(t51v)=='string'then return
#t51v==0 end
if v(t51v)=='table'then return e(t51v)==nil end;return true end;function S1wg_DG.isString(Hp)return v(Hp)=='string'end;function S1wg_DG.isFunction(Tee9V)return
v(Tee9V)=='function'end;function S1wg_DG.isNil(znHly)return
znHly==nil end
function S1wg_DG.isNumber(cD)return v(cD)=='number'end
function S1wg_DG.isNaN(I)return v(I)=='number'and I~=I end
function S1wg_DG.isFinite(AN9)if v(AN9)~='number'then return false end;return AN9 >-S9TO and
AN9 &lt;S9TO end;function S1wg_DG.isBoolean(CCI)return v(CCI)=='boolean'end;function S1wg_DG.isInteger(Ax_b)
return
v(Ax_b)=='number'and pS78Y(Ax_b)==Ax_b end
do
S1wg_DG.forEach=S1wg_DG.each;S1wg_DG.forEachi=S1wg_DG.eachi;S1wg_DG.update=S1wg_DG.adjust
S1wg_DG.alleq=S1wg_DG.allEqual;S1wg_DG.loop=S1wg_DG.cycle;S1wg_DG.collect=S1wg_DG.map
S1wg_DG.inject=S1wg_DG.reduce;S1wg_DG.foldl=S1wg_DG.reduce
S1wg_DG.injectr=S1wg_DG.reduceRight;S1wg_DG.foldr=S1wg_DG.reduceRight
S1wg_DG.mapr=S1wg_DG.mapReduce;S1wg_DG.maprr=S1wg_DG.mapReduceRight
S1wg_DG.any=S1wg_DG.include;S1wg_DG.some=S1wg_DG.include;S1wg_DG.contains=S1wg_DG.include
S1wg_DG.filter=S1wg_DG.select;S1wg_DG.discard=S1wg_DG.reject;S1wg_DG.every=S1wg_DG.all
S1wg_DG.takeWhile=S1wg_DG.selectWhile;S1wg_DG.rejectWhile=S1wg_DG.dropWhile;S1wg_DG.pop=S1wg_DG.shift
S1wg_DG.remove=S1wg_DG.pull;S1wg_DG.rmRange=S1wg_DG.removeRange
S1wg_DG.chop=S1wg_DG.removeRange;S1wg_DG.sub=S1wg_DG.slice;S1wg_DG.head=S1wg_DG.first
S1wg_DG.take=S1wg_DG.first;S1wg_DG.tail=S1wg_DG.rest;S1wg_DG.without=S1wg_DG.difference
S1wg_DG.diff=S1wg_DG.difference;S1wg_DG.symdiff=S1wg_DG.symmetricDifference
S1wg_DG.xor=S1wg_DG.symmetricDifference;S1wg_DG.uniq=S1wg_DG.unique;S1wg_DG.isuniq=S1wg_DG.isunique
S1wg_DG.transpose=S1wg_DG.zip;S1wg_DG.part=S1wg_DG.partition;S1wg_DG.perm=S1wg_DG.permutation
S1wg_DG.transposeWith=S1wg_DG.zipWith;S1wg_DG.intersperse=S1wg_DG.interpose
S1wg_DG.sliding=S1wg_DG.aperture;S1wg_DG.mirror=S1wg_DG.invert;S1wg_DG.join=S1wg_DG.concat
S1wg_DG.average=S1wg_DG.mean;S1wg_DG.always=S1wg_DG.constant;S1wg_DG.cache=S1wg_DG.memoize
S1wg_DG.juxt=S1wg_DG.juxtapose;S1wg_DG.uid=S1wg_DG.uniqueId;S1wg_DG.iter=S1wg_DG.iterator
S1wg_DG.nAry=S1wg_DG.ary;S1wg_DG.methods=S1wg_DG.functions;S1wg_DG.choose=S1wg_DG.pick
S1wg_DG.drop=S1wg_DG.omit;S1wg_DG.defaults=S1wg_DG.template
S1wg_DG.compare=S1wg_DG.isEqual;S1wg_DG.matches=S1wg_DG.isEqual end
do local Hgc1S={}local gszf={}gszf.__index=Hgc1S;local function GnYt(L7g)
return oUA({_value=L7g,_wrapped=true},gszf)end
oUA(gszf,{__call=function(_IO9,zcnTZ6pI)return GnYt(zcnTZ6pI)end,__index=function(sIPPW,jrXq,...)return
Hgc1S[jrXq]end})function gszf.chain(T5V8Jm3h)return GnYt(T5V8Jm3h)end;function gszf:value()
return self._value end;Hgc1S.chain,Hgc1S.value=gszf.chain,gszf.value
for yYkU,n0 in
l(S1wg_DG)do
if yYkU~='operator'then
Hgc1S[yYkU]=function(nOa2,...)local r=
v(nOa2)=='table'and PizLA9mj(nOa2,'_wrapped')or false
if r then
local zx=nOa2._value;local crsA2=n0(zx,...)return GnYt(crsA2)else return n0(nOa2,...)end end end end;Hgc1S.operator=S1wg_DG.operator;Hgc1S.op=S1wg_DG.operator
Hgc1S.import=function(uIdK8yDV,e7iD7y21)uIdK8yDV=
uIdK8yDV or _ENV or _G;local ec=S1wg_DG.functions()
for x,Ca in
kyWtqIf0(ec)do if PizLA9mj(uIdK8yDV,Ca)~=nil then if not e7iD7y21 then
rawset(uIdK8yDV,Ca,S1wg_DG[Ca])end else
rawset(uIdK8yDV,Ca,S1wg_DG[Ca])end end;return uIdK8yDV end;gszf._VERSION='Moses v'..SWFtRywD
gszf._URL='http://github.com/Yonaba/Moses'
gszf._LICENSE='MIT &lt;http://raw.githubusercontent.com/Yonaba/Moses/master/LICENSE>'
gszf._DESCRIPTION='utility-belt library for functional programming in Lua'return gszf end</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="6">
        <Properties>
          <string name="Name">Models</string>
        </Properties>
        <Item class="Folder" referent="7">
          <Properties>
            <string name="Name">Collectables</string>
          </Properties>
          <Item class="Model" referent="8">
            <Properties>
              <string name="Name">cherry</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">9</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="9">
              <Properties>
                <string name="Name">cherry</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-3.652835</X>
                  <Y>2.423584</Y>
                  <Z>-541.49744</Z>
                  <R00>0.8660254</R00>
                  <R01>0</R01>
                  <R02>0.5</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>-0.5</R20>
                  <R21>0</R21>
                  <R22>0.8660254</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.899999976158142</X>
                  <Y>2.5999999046325684</Y>
                  <Z>3.9000000953674316</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"><![CDATA[Q29sbGVjdGFibGVCcmljaw==]]></BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="NumberValue" referent="10">
                <Properties>
                  <string name="Name">itemId</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <double name="Value">50000001</double>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="11">
              <Properties>
                <string name="Name">MeshPart</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-3.255158</X>
                  <Y>2.51467</Y>
                  <Z>-540.6712</Z>
                  <R00>0.9353226</R00>
                  <R01>0.013095826</R01>
                  <R02>-0.35355344</R02>
                  <R10>0.14178652</R10>
                  <R11>0.90168136</R11>
                  <R12>0.40849376</R12>
                  <R20>0.32414216</R20>
                  <R21>-0.4322026</R21>
                  <R22>0.84150624</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>27.179000854492188</X>
                  <Y>50</Y>
                  <Z>27.404499053955078</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshID">
                  <url>rbxassetid://5047692843</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://5047692843</url>
                </Content>
                <SharedString name="PhysicalConfigData">QGFPL+mDhuS1jsPoelb+4w==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>1.6307405233383179</X>
                  <Y>3</Y>
                  <Z>1.6442699432373047</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <url>rbxassetid://5047700823</url>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Weld" referent="12">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-1.7394218</X>
                    <Y>0.6453495</Y>
                    <Z>0.16810036</Z>
                    <R00>-0.50000024</R00>
                    <R01>0.7071066</R01>
                    <R02>-0.5000002</R02>
                    <R10>0.49999988</R10>
                    <R11>0.70710707</R11>
                    <R12>0.49999982</R12>
                    <R20>0.70710677</R20>
                    <R21>0.000000014901161</R21>
                    <R22>-0.7071069</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">11</Ref>
                  <Ref name="Part1">13</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="14">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.06871796</X>
                    <Y>0.09108591</Y>
                    <Z>0.9143753</Z>
                    <R00>0.64794207</R00>
                    <R01>0.22744262</R01>
                    <R02>-0.7269394</R02>
                    <R10>0.14178652</R10>
                    <R11>0.90168136</R11>
                    <R12>0.40849376</R12>
                    <R20>0.7483766</R20>
                    <R21>-0.36775053</R21>
                    <R22>0.5519891</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">11</Ref>
                  <Ref name="Part1">9</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="13">
              <Properties>
                <string name="Name">MeshPart</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-4.091921</X>
                  <Y>2.587788</Y>
                  <Z>-542.3339</Z>
                  <R00>-0.28162462</R00>
                  <R01>0.30014467</R01>
                  <R02>0.9113731</R02>
                  <R10>0.36244464</R10>
                  <R11>0.91272545</R11>
                  <R12>-0.18859057</R12>
                  <R20>-0.8884377</R20>
                  <R21>0.2772105</R21>
                  <R22>-0.36583176</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>27.179000854492188</X>
                  <Y>50</Y>
                  <Z>27.404499053955078</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshID">
                  <url>rbxassetid://5047692843</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://5047692843</url>
                </Content>
                <SharedString name="PhysicalConfigData">QGFPL+mDhuS1jsPoelb+4w==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>1.6307405233383179</X>
                  <Y>3</Y>
                  <Z>1.6442699432373047</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <url>rbxassetid://5047700823</url>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="15">
          <Properties>
            <string name="Name">Misc</string>
          </Properties>
          <Item class="MeshPart" referent="16">
            <Properties>
              <string name="Name">Grass1</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>-5.188751</X>
                <Y>31.674847</Y>
                <Z>-575.07654</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">8166507</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <bool name="HasJointOffset">false</bool>
              <bool name="HasSkinnedMesh">false</bool>
              <Vector3 name="InitialSize">
                <X>11.624557495117188</X>
                <Y>7.624223232269287</Y>
                <Z>11.220917701721191</Z>
              </Vector3>
              <Vector3 name="JointOffset">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <BinaryString name="LODData">
              </BinaryString>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">272</token>
              <Content name="MeshID">
                <url>rbxassetid://5631253328</url>
              </Content>
              <Content name="MeshId">
                <url>rbxassetid://5631253328</url>
              </Content>
              <SharedString name="PhysicalConfigData">2f+244QVPupBDvrmXP0cmw==</SharedString>
              <BinaryString name="PhysicsData">
              </BinaryString>
              <float name="Reflectance">0</float>
              <token name="RenderFidelity">0</token>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Vector3 name="size">
                <X>6</X>
                <Y>6</Y>
                <Z>6</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
              <Content name="TextureID">
                <null>
                </null>
              </Content>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">0</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
          </Item>
          <Item class="Model" referent="17">
            <Properties>
              <string name="Name">PalmTree</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">18</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="MeshPart" referent="19">
              <Properties>
                <string name="Name">MeshPart</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>12.073441</X>
                  <Y>51.08132</Y>
                  <Z>-566.1643</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6003276</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>49.36980056762695</X>
                  <Y>13.87887954711914</Y>
                  <Z>50</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshID">
                  <url>rbxassetid://5459061824</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://5459061824</url>
                </Content>
                <SharedString name="PhysicalConfigData">KVKo+PkbhmMH7yw3CVz5Ng==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>13.369800567626953</X>
                  <Y>5.878879547119141</Y>
                  <Z>12</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="MeshPart" referent="18">
              <Properties>
                <string name="Name">MeshPart</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>11.344742</X>
                  <Y>46.41008</Y>
                  <Z>-566.04895</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">5653046</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>12.048471450805664</X>
                  <Y>50</Y>
                  <Z>13.912375450134277</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshID">
                  <url>rbxassetid://5459046563</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://5459046563</url>
                </Content>
                <SharedString name="PhysicalConfigData">OreJJotcO+VtooglIF8RWg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>2.048471450805664</X>
                  <Y>14</Y>
                  <Z>1.9123754501342773</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
          <Item class="Model" referent="20">
            <Properties>
              <string name="Name">Wood Crate</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">21</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="22">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>3.7625613</X>
                  <Y>4.642225</Y>
                  <Z>-570.2173</Z>
                  <R00>0.00014233589</R00>
                  <R01>-0.99999994</R01>
                  <R02>0.000011370143</R02>
                  <R10>-1</R10>
                  <R11>-0.0001505315</R11>
                  <R12>0.000045329325</R12>
                  <R20>-0.000045327823</R20>
                  <R21>-0.000011376782</R21>
                  <R22>-1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>3.4000000953674316</X>
                  <Y>0.6000000238418579</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="23">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>2.062317</X>
                  <Y>6.64203</Y>
                  <Z>-570.2172</Z>
                  <R00>1</R00>
                  <R01>-0.00014624</R01>
                  <R02>-0.000011370157</R02>
                  <R10>0.00015446541</R10>
                  <R11>1</R11>
                  <R12>-0.00004524191</R12>
                  <R20>0.000011376964</R20>
                  <R21>0.000045240362</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.8000001907348633</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="24">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>2.0624843</X>
                  <Y>4.9706717</Y>
                  <Z>-566.8757</Z>
                  <R00>-0.7072091</R00>
                  <R01>-0.7070044</R01>
                  <R02>-0.000010613872</R02>
                  <R10>0.70699865</R10>
                  <R11>-0.70721495</R11>
                  <R12>-0.000045300905</R12>
                  <R20>0.000024521663</R20>
                  <R21>-0.000039541486</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>4.000000476837158</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Weld" referent="25">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>1.166687</X>
                    <Y>-1.1666565</Y>
                    <Z>1.7001104</Z>
                    <R00>-0.4999915</R00>
                    <R01>-0.5000041</R01>
                    <R02>0.7071099</R02>
                    <R10>-0.49999592</R10>
                    <R11>-0.50000846</R11>
                    <R12>-0.7071037</R12>
                    <R20>0.70711565</R20>
                    <R21>-0.70709795</R21>
                    <R22>-0.000000042156756</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">26</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="27">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.000026464462</X>
                    <Y>1.7288558</Y>
                    <Z>3.3416138</Z>
                    <R00>-0.7071117</R00>
                    <R01>-0.70710194</R01>
                    <R02>0.00000075646994</R02>
                    <R10>0.707102</R10>
                    <R11>-0.7071117</R11>
                    <R12>-0.000000059227343</R12>
                    <R20>0.00000057678847</R20>
                    <R21>0.000000493021</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">28</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="29">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.000006198883</X>
                    <Y>0.0287261</Y>
                    <Z>1.6416016</Z>
                    <R00>-0.7071116</R00>
                    <R01>-0.70710194</R01>
                    <R02>0.00000075646466</R02>
                    <R10>0.7071019</R10>
                    <R11>-0.7071117</R11>
                    <R12>-0.000000059221914</R12>
                    <R20>0.00000057678096</R20>
                    <R21>0.0000004930211</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">21</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="30">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-1.166626</X>
                    <Y>-1.166626</Y>
                    <Z>-1.6499635</Z>
                    <R00>0.49999148</R00>
                    <R01>-0.50000554</R01>
                    <R02>-0.707109</R02>
                    <R10>-0.4999952</R10>
                    <R11>0.5000078</R11>
                    <R12>-0.70710474</R12>
                    <R20>0.70711625</R20>
                    <R21>0.70709735</R21>
                    <R22>-0.0000007375715</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">31</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="32">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.32888222</X>
                    <Y>1.6999924</Y>
                    <Z>-3.3416138</Z>
                    <R00>-0.7071051</R00>
                    <R01>0.7071085</R01>
                    <R02>-0.000000028307113</R02>
                    <R10>0.70709676</R10>
                    <R11>0.7071168</R11>
                    <R12>-0.00000075627486</R12>
                    <R20>-0.000000515176</R20>
                    <R21>-0.00000055489</R21>
                    <R22>-1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">22</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="33">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>1.6416016</X>
                    <Y>-1.7288597</Y>
                    <Z>-1.6999764</Z>
                    <R00>0.0000012417568</R00>
                    <R01>0.0000009904106</R01>
                    <R02>1</R02>
                    <R10>-0.70710504</R10>
                    <R11>0.7071084</R11>
                    <R12>0.00000017751881</R12>
                    <R20>-0.7070966</R20>
                    <R21>-0.707117</R21>
                    <R22>0.0000015780042</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">34</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="35">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.30001378</X>
                    <Y>1.7288516</Y>
                    <Z>-0.05834961</Z>
                    <R00>-0.7071057</R00>
                    <R01>-0.70710784</R01>
                    <R02>0.00000075627577</R02>
                    <R10>0.707096</R10>
                    <R11>-0.7071176</R11>
                    <R12>-0.000000059098966</R12>
                    <R20>0.00000057699435</R20>
                    <R21>0.00000049307346</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">36</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="37">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.3288684</X>
                    <Y>-3.3416138</Y>
                    <Z>1.6999834</Z>
                    <R00>-0.7071051</R00>
                    <R01>0.7071085</R01>
                    <R02>0.00000010282747</R02>
                    <R10>-0.0000012198489</R10>
                    <R11>-0.0000010741351</R11>
                    <R12>-1</R12>
                    <R20>-0.7070967</R20>
                    <R21>-0.7071169</R21>
                    <R22>0.0000016217155</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">38</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="39">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-1.9415894</X>
                    <Y>-1.6712165</Y>
                    <Z>1.6999683</Z>
                    <R00>-0.000001179942</R00>
                    <R01>-0.0000010522235</R01>
                    <R02>-1</R02>
                    <R10>0.70710504</R10>
                    <R11>-0.7071084</R11>
                    <R12>-0.00000009009818</R12>
                    <R20>-0.7070966</R20>
                    <R21>-0.707117</R21>
                    <R22>0.0000015780042</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">40</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="41">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-3.2998657</X>
                    <Y>0.000018119812</Y>
                    <Z>-0.000013589859</Z>
                    <R00>-0.0000012192813</R00>
                    <R01>-0.0000010915683</R01>
                    <R02>-1</R02>
                    <R10>0.0000003864338</R10>
                    <R11>1.0000083</R11>
                    <R12>-0.0000010914628</R12>
                    <R20>0.9999918</R20>
                    <R21>-0.00000038835162</R21>
                    <R22>-0.0000012188575</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">42</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="43">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.000010728836</X>
                    <Y>-1.671207</Y>
                    <Z>3.3416138</Z>
                    <R00>-0.7071057</R00>
                    <R01>-0.70710784</R01>
                    <R02>0.00000075627577</R02>
                    <R10>0.707096</R10>
                    <R11>-0.7071176</R11>
                    <R12>-0.000000059098966</R12>
                    <R20>0.00000057699435</R20>
                    <R21>0.00000049307346</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">23</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="44">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-1.3416138</X>
                    <Y>1.7288454</Y>
                    <Z>1.6999964</Z>
                    <R00>-0.000001179942</R00>
                    <R01>-0.0000010522235</R01>
                    <R02>-1</R02>
                    <R10>0.70710504</R10>
                    <R11>-0.7071084</R11>
                    <R12>-0.00000009009818</R12>
                    <R20>-0.7070966</R20>
                    <R21>-0.707117</R21>
                    <R22>0.0000015780042</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">45</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="46">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-1.166687</X>
                    <Y>1.166626</Y>
                    <Z>-1.6499832</Z>
                    <R00>0.4999913</R00>
                    <R01>-0.5000055</R01>
                    <R02>-0.70710915</R02>
                    <R10>0.49999526</R10>
                    <R11>-0.50000805</R11>
                    <R12>0.7071045</R12>
                    <R20>-0.7071163</R20>
                    <R21>-0.7070973</R21>
                    <R22>0.00000069542864</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">47</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="48">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.3000039</X>
                    <Y>-1.6712065</Y>
                    <Z>-0.05834961</Z>
                    <R00>-0.7071057</R00>
                    <R01>-0.70710784</R01>
                    <R02>0.00000075627577</R02>
                    <R10>0.707096</R10>
                    <R11>-0.7071176</R11>
                    <R12>-0.000000059098966</R12>
                    <R20>0.00000057699435</R20>
                    <R21>0.00000049307346</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">49</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="50">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-1.1168823</X>
                    <Y>-1.62118</Y>
                    <Z>1.1281128</Z>
                    <R00>-0.4999887</R00>
                    <R01>-0.5000028</R01>
                    <R02>-0.70710194</R02>
                    <R10>0.70710045</R10>
                    <R11>-0.7071038</R11>
                    <R12>0.000012726723</R12>
                    <R20>-0.5000037</R20>
                    <R21>-0.49999222</R21>
                    <R22>0.7070976</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">51</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="52">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.028721333</X>
                    <Y>1.6999818</Y>
                    <Z>-0.05834961</Z>
                    <R00>-0.7071051</R00>
                    <R01>0.7071085</R01>
                    <R02>0.00000023395842</R02>
                    <R10>-0.7070967</R10>
                    <R11>-0.7071169</R11>
                    <R12>0.0000007562712</R12>
                    <R20>0.0000007006256</R20>
                    <R21>0.0000003694404</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">53</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="54">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>1.9416504</X>
                    <Y>-1.6711998</Y>
                    <Z>1.7000084</Z>
                    <R00>0.0000011181237</R00>
                    <R01>0.0000009904106</R01>
                    <R02>1</R02>
                    <R10>0.7071051</R10>
                    <R11>-0.70710844</R11>
                    <R12>-0.000000090094545</R12>
                    <R20>0.7070966</R20>
                    <R21>0.707117</R21>
                    <R22>-0.0000014905818</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">55</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="56">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.2712474</X>
                    <Y>1.6999934</Y>
                    <Z>-0.05834961</Z>
                    <R00>0.70710504</R00>
                    <R01>-0.7071084</R01>
                    <R02>-0.000000059113518</R02>
                    <R10>0.7070966</R10>
                    <R11>0.707117</R11>
                    <R12>-0.00000075627395</R12>
                    <R20>0.00000057699435</R20>
                    <R21>0.00000049307346</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">24</Ref>
                  <Ref name="Part1">57</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="42">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>2.062528</X>
                  <Y>4.9708433</Y>
                  <Z>-570.17554</Z>
                  <R00>0.000012247903</R00>
                  <R01>-0.7070106</R01>
                  <R02>-0.707203</R02>
                  <R10>0.000045210847</R10>
                  <R11>-0.70722055</R11>
                  <R12>0.7069931</R12>
                  <R20>-1</R20>
                  <R21>-0.00004063327</R21>
                  <R22>0.000023302619</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>0.6000000238418579</X>
                  <Y>0.5999999046325684</Y>
                  <Z>4.000000476837158</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="31">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>0.41253948</X>
                  <Y>4.970511</Y>
                  <Z>-568.5256</Z>
                  <R00>-0.000084882035</R00>
                  <R01>0.0001009354</R01>
                  <R02>-1</R02>
                  <R10>0.7071367</R10>
                  <R11>-0.7070769</R11>
                  <R12>-0.00013956425</R12>
                  <R20>-0.70707697</R20>
                  <R21>-0.70713675</R21>
                  <R22>-0.000011357586</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>4.000000476837158</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="36">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>2.3627212</X>
                  <Y>3.2418637</Y>
                  <Z>-566.8174</Z>
                  <R00>1</R00>
                  <R01>-0.00014624</R01>
                  <R02>-0.000011370157</R02>
                  <R10>0.00015446541</R10>
                  <R11>1</R11>
                  <R12>-0.00004524191</R12>
                  <R20>0.000011376964</R20>
                  <R21>0.000045240362</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>3.4000000953674316</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="40">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>0.3623016</X>
                  <Y>6.641691</Y>
                  <Z>-568.8172</Z>
                  <R00>0.000012192265</R00>
                  <R01>-0.0001423657</R01>
                  <R02>1</R02>
                  <R10>0.000045210836</R10>
                  <R11>1</R11>
                  <R12>0.00015062086</R12>
                  <R20>-1</R20>
                  <R21>0.000045209206</R21>
                  <R22>0.000012198895</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>3.4000000953674316</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="38">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>0.36258864</X>
                  <Y>4.6416698</Y>
                  <Z>-570.21735</Z>
                  <R00>0.00014233589</R00>
                  <R01>0.000012235979</R01>
                  <R02>1</R02>
                  <R10>-1</R10>
                  <R11>0.00004519832</R11>
                  <R12>0.00015053146</R12>
                  <R20>-0.000045196688</R20>
                  <R21>-1</R21>
                  <R22>0.000012242602</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>3.4000000953674316</X>
                  <Y>0.6000000238418579</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="28">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>2.062787</X>
                  <Y>3.2419667</Y>
                  <Z>-570.21735</Z>
                  <R00>1.0000001</R00>
                  <R01>-0.00013783574</R01>
                  <R02>-0.00001137035</R02>
                  <R10>0.00014606115</R10>
                  <R11>1.0000001</R11>
                  <R12>-0.000045241788</R12>
                  <R20>0.000011376778</R20>
                  <R21>0.00004524034</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.8000001907348633</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="57">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>3.7624383</X>
                  <Y>5.242201</Y>
                  <Z>-566.81726</Z>
                  <R00>-0.0001423657</R00>
                  <R01>-1</R01>
                  <R02>-0.000011370155</R02>
                  <R10>1</R10>
                  <R11>-0.00015062091</R11>
                  <R12>-0.000045241904</R12>
                  <R20>0.0000452404</R20>
                  <R21>-0.00001137679</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>3.4000000953674316</X>
                  <Y>0.6000000238418579</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="49">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>1.7622635</X>
                  <Y>6.6418295</Y>
                  <Z>-566.81726</Z>
                  <R00>1</R00>
                  <R01>-0.00014624</R01>
                  <R02>-0.000011370157</R02>
                  <R10>0.00015446541</R10>
                  <R11>1</R11>
                  <R12>-0.00004524191</R12>
                  <R20>0.000011376964</R20>
                  <R21>0.000045240362</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>3.4000000953674316</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="47">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>3.7124863</X>
                  <Y>4.9710145</Y>
                  <Z>-568.5256</Z>
                  <R00>-0.00008479263</R00>
                  <R01>-0.000100816185</R01>
                  <R02>1</R02>
                  <R10>0.7071366</R10>
                  <R11>0.70707715</R11>
                  <R12>0.00013953444</R12>
                  <R20>-0.70707715</R20>
                  <R21>0.7071365</R21>
                  <R22>0.000011315438</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>4.000000476837158</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="51">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>2.0543256</X>
                  <Y>6.591932</Y>
                  <Z>-568.463</Z>
                  <R00>0.70710826</R00>
                  <R01>-0.00014236583</R01>
                  <R02>0.70709634</R02>
                  <R10>0.00015013896</R10>
                  <R11>0.99999344</R11>
                  <R12>0.00006798444</R12>
                  <R20>-0.70709443</R20>
                  <R21>0.00005802594</R21>
                  <R22>0.7071051</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>4</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="45">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>0.3627504</X>
                  <Y>3.2416027</Y>
                  <Z>-568.2174</Z>
                  <R00>0.000012192265</R00>
                  <R01>-0.0001423657</R01>
                  <R02>1</R02>
                  <R10>0.000045210836</R10>
                  <R11>1</R11>
                  <R12>0.00015062086</R12>
                  <R20>-1</R20>
                  <R21>0.000045209206</R21>
                  <R22>0.000012198895</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>3.4000000953674316</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="53">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>0.36250603</X>
                  <Y>4.9416633</Y>
                  <Z>-566.8173</Z>
                  <R00>0.00014233589</R00>
                  <R01>1</R01>
                  <R02>-0.000011370181</R02>
                  <R10>-1</R10>
                  <R11>0.0001505315</R11>
                  <R12>-0.00004506706</R12>
                  <R20>-0.000045065557</R20>
                  <R21>0.000011376785</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.8000001907348633</X>
                  <Y>0.6000000238418579</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="26">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>2.0627546</X>
                  <Y>3.2706358</Y>
                  <Z>-568.5257</Z>
                  <R00>0.70709616</R00>
                  <R01>0.7071174</R01>
                  <R02>-0.00015723705</R02>
                  <R10>0.0000850308</R10>
                  <R11>0.00014906615</R11>
                  <R12>1</R12>
                  <R20>0.70711744</R20>
                  <R21>-0.7070962</R21>
                  <R22>0.0000452572</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>4.000000476837158</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="34">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>3.7627268</X>
                  <Y>3.2421708</Y>
                  <Z>-568.51733</Z>
                  <R00>-0.0000121922785</R00>
                  <R01>0.0001423657</R01>
                  <R02>1</R02>
                  <R10>-0.00004512342</R10>
                  <R11>-1</R11>
                  <R12>0.00015062086</R12>
                  <R20>1</R20>
                  <R21>-0.000045121786</R21>
                  <R22>0.000012198896</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.8000001907348633</X>
                  <Y>0.6000001430511475</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="21">
              <Properties>
                <string name="Name">Center</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>2.062513</X>
                  <Y>4.94202</Y>
                  <Z>-568.5173</Z>
                  <R00>1</R00>
                  <R01>-0.00013789731</R01>
                  <R02>-0.000011370345</R02>
                  <R10>0.00014600303</R10>
                  <R11>1</R11>
                  <R12>-0.000045241795</R12>
                  <R20>0.000011376767</R20>
                  <R21>0.000045240336</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">8150086</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>3.5999999046325684</X>
                  <Y>3.5999999046325684</Y>
                  <Z>3.5999999046325684</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="55">
              <Properties>
                <string name="Name">Part</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>3.762278</X>
                  <Y>6.642244</Y>
                  <Z>-568.8172</Z>
                  <R00>-0.000012104844</R00>
                  <R01>-0.0001423955</R01>
                  <R02>-1</R02>
                  <R10>-0.000045210825</R10>
                  <R11>1.0000001</R11>
                  <R12>-0.00015053146</R12>
                  <R20>1</R20>
                  <R21>0.000045209214</R21>
                  <R22>-0.000012111469</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6897704</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">3</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">528</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>3.4000000953674316</X>
                  <Y>0.5999999046325684</Y>
                  <Z>0.6000000238418579</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
          <Item class="Model" referent="58">
            <Properties>
              <string name="Name">rock01</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">59</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="MeshPart" referent="60">
              <Properties>
                <string name="Name">rock01</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>6.269264</X>
                  <Y>0.8343276</Y>
                  <Z>-568.0589</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>2.437732696533203</X>
                  <Y>2.9153740406036377</Y>
                  <Z>3.1155753135681152</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">800</token>
                <Content name="MeshID">
                  <url>rbxassetid://5498135840</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://5498135840</url>
                </Content>
                <SharedString name="PhysicalConfigData">1AGo5KJPpGqtziT6sDf9Ew==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>5.0377326011657715</X>
                  <Y>3.4153740406036377</Y>
                  <Z>6.515575408935547</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="59">
              <Properties>
                <string name="Name">PrimaryPart</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>6.15</X>
                  <Y>1.4336901</Y>
                  <Z>-568</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>4.099999904632568</X>
                  <Y>2</Y>
                  <Z>6</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
          <Item class="Model" referent="61">
            <Properties>
              <string name="Name">rock02</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">62</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="MeshPart" referent="63">
              <Properties>
                <string name="Name">rock02</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>1.9537992</X>
                  <Y>0.33834577</Y>
                  <Z>-564.1711</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>2.5836920738220215</X>
                  <Y>2.4968795776367188</Y>
                  <Z>3.151432514190674</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">800</token>
                <Content name="MeshID">
                  <url>rbxassetid://5498140079</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://5498140079</url>
                </Content>
                <SharedString name="PhysicalConfigData">hocqLw6vmtVO0ScHwui/oQ==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>4.5836920738220215</X>
                  <Y>3.096879482269287</Y>
                  <Z>5.151432514190674</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="62">
              <Properties>
                <string name="Name">PrimaryPart</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>1.9500002</X>
                  <Y>1.142022</Y>
                  <Z>-564.25</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>3.700000047683716</X>
                  <Y>1.399999976158142</Y>
                  <Z>4.5</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
          <Item class="Model" referent="64">
            <Properties>
              <string name="Name">rock03</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">65</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="MeshPart" referent="66">
              <Properties>
                <string name="Name">rock03</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>1.5077333</X>
                  <Y>0.9999999</Y>
                  <Z>-570.02734</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>0.25881907</R11>
                  <R12>-0.9659258</R12>
                  <R20>0</R20>
                  <R21>0.9659258</R21>
                  <R22>0.25881907</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>2.0723118782043457</X>
                  <Y>2.121455192565918</Y>
                  <Z>1.9308853149414063</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">800</token>
                <Content name="MeshID">
                  <url>rbxassetid://5498143396</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://5498143396</url>
                </Content>
                <SharedString name="PhysicalConfigData">FJBsQqAd6JZHNbD3qi1kFA==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>5.072311878204346</X>
                  <Y>4.121455192565918</Y>
                  <Z>3.9308853149414063</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="65">
              <Properties>
                <string name="Name">PrimaryPart</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>1.6000001</X>
                  <Y>1.5420241</Y>
                  <Z>-570.05</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>4.599999904632568</X>
                  <Y>2</Y>
                  <Z>3.5</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="67">
          <Properties>
            <string name="Name">Money</string>
          </Properties>
          <Item class="Model" referent="68">
            <Properties>
              <string name="Name">Coin</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">69</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="MeshPart" referent="70">
              <Properties>
                <string name="Name">Coin</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>0.911523</X>
                  <Y>-2</Y>
                  <Z>-618.8</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">15710264</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">1088</token>
                <Content name="MeshID">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <SharedString name="PhysicalConfigData">+KXn2PVkmG8K5+S8Au8qxA==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0.4000000059604645</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="69">
              <Properties>
                <string name="Name">PrimaryPart</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>1</X>
                  <Y>-1.8999951</Y>
                  <Z>-618.8</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.5</X>
                  <Y>2.5</Y>
                  <Z>2.5</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"><![CDATA[Q29pbkJyaWNr]]></BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="NumberValue" referent="71">
                <Properties>
                  <string name="Name">itemId</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <double name="Value">9000001</double>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Model" referent="72">
            <Properties>
              <string name="Name">PileOfCoins</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">73</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="MeshPart" referent="74">
              <Properties>
                <string name="Name">Coin</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>7.961523</X>
                  <Y>2.5919294</Y>
                  <Z>-618.8</Z>
                  <R00>-0.000000043711385</R00>
                  <R01>-0.99999994</R01>
                  <R02>0</R02>
                  <R10>-1</R10>
                  <R11>0.00000004371139</R11>
                  <R12>0.00000008742278</R12>
                  <R20>-0.00000008742278</R20>
                  <R21>0.000000000000003821371</R21>
                  <R22>-1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">15710264</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">1088</token>
                <Content name="MeshID">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <SharedString name="PhysicalConfigData">+KXn2PVkmG8K5+S8Au8qxA==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0.4000000059604645</float>
                <token name="RenderFidelity">0</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="73">
              <Properties>
                <string name="Name">PrimaryPart</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>8.049999</X>
                  <Y>2.6919317</Y>
                  <Z>-618.8</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.5</X>
                  <Y>2.5</Y>
                  <Z>2.5</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags"><![CDATA[Q29pbkJyaWNr]]></BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="NumberValue" referent="75">
                <Properties>
                  <string name="Name">itemId</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <double name="Value">9000008</double>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="76">
              <Properties>
                <string name="Name">Coin</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>9.161523</X>
                  <Y>2.6919296</Y>
                  <Z>-618.8</Z>
                  <R00>-0.15643418</R00>
                  <R01>-0.9876883</R01>
                  <R02>0.000000013675907</R02>
                  <R10>-0.98768836</R10>
                  <R11>0.15643413</R11>
                  <R12>0.00000008634645</R12>
                  <R20>-0.00000008742278</R20>
                  <R21>0.000000000000003821371</R21>
                  <R22>-1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">15710264</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">1088</token>
                <Content name="MeshID">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <SharedString name="PhysicalConfigData">+KXn2PVkmG8K5+S8Au8qxA==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0.4000000059604645</float>
                <token name="RenderFidelity">0</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="MeshPart" referent="77">
              <Properties>
                <string name="Name">Coin</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>7.961523</X>
                  <Y>2.8919296</Y>
                  <Z>-617.89996</Z>
                  <R00>-0.000000043711385</R00>
                  <R01>-0.99999994</R01>
                  <R02>0</R02>
                  <R10>-0.9659258</R10>
                  <R11>0.000000042221956</R11>
                  <R12>0.25881913</R12>
                  <R20>-0.25881913</R20>
                  <R21>0.000000011313343</R21>
                  <R22>-0.9659258</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">15710264</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">1088</token>
                <Content name="MeshID">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <SharedString name="PhysicalConfigData">+KXn2PVkmG8K5+S8Au8qxA==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0.4000000059604645</float>
                <token name="RenderFidelity">0</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="MeshPart" referent="78">
              <Properties>
                <string name="Name">Coin</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>7.961523</X>
                  <Y>2.7919292</Y>
                  <Z>-619.89996</Z>
                  <R00>-0.000000043711385</R00>
                  <R01>-0.99999994</R01>
                  <R02>0</R02>
                  <R10>-0.9816272</R10>
                  <R11>0.00000004290829</R11>
                  <R12>-0.1908089</R12>
                  <R20>0.1908089</R20>
                  <R21>-0.000000008340522</R21>
                  <R22>-0.9816272</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">15710264</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">1088</token>
                <Content name="MeshID">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <SharedString name="PhysicalConfigData">+KXn2PVkmG8K5+S8Au8qxA==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0.4000000059604645</float>
                <token name="RenderFidelity">0</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Weld" referent="79">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.19999981</X>
                    <Y>0</Y>
                    <Z>1.0999756</Z>
                    <R00>0.9816272</R00>
                    <R01>0.00000000080309165</R01>
                    <R02>0.190809</R02>
                    <R10>0.00000000080309165</R10>
                    <R11>0.9999999</R11>
                    <R12>-0.000000008340526</R12>
                    <R20>-0.190809</R20>
                    <R21>0.000000008340526</R21>
                    <R22>0.9816272</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">78</Ref>
                  <Ref name="Part1">74</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="80">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.61424255</X>
                    <Y>0</Y>
                    <Z>1.9060059</Z>
                    <R00>0.89879405</R00>
                    <R01>0.0000000044238435</R01>
                    <R02>0.43837115</R02>
                    <R10>0.000000004423847</R10>
                    <R11>0.9999999</R11>
                    <R12>-0.00000001916181</R12>
                    <R20>-0.43837115</R20>
                    <R21>0.000000019161812</R21>
                    <R22>0.89879405</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">78</Ref>
                  <Ref name="Part1">77</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="81">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.08895302</X>
                    <Y>1.2008686</Y>
                    <Z>1.0999756</Z>
                    <R00>0.9695418</R00>
                    <R01>0.15643412</R01>
                    <R02>0.18845983</R02>
                    <R10>-0.15355995</R10>
                    <R11>0.98768824</R11>
                    <R12>-0.029849026</R12>
                    <R20>-0.190809</R20>
                    <R21>-0.00000000533538</R21>
                    <R22>0.9816272</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">78</Ref>
                  <Ref name="Part1">76</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="82">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.41610718</X>
                    <Y>0</Y>
                    <Z>0.29473877</Z>
                    <R00>0.97437</R00>
                    <R01>0.0000000011203141</R01>
                    <R02>-0.22495121</R02>
                    <R10>0.0000000011203141</R10>
                    <R11>0.9999999</R11>
                    <R12>0.000000009832928</R12>
                    <R20>0.22495121</R20>
                    <R21>-0.00000000983293</R21>
                    <R22>0.97437</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">78</Ref>
                  <Ref name="Part1">83</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="84">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.83657074</X>
                    <Y>-0.23111916</Y>
                    <Z>1.4888306</Z>
                    <R00>0.91317946</R00>
                    <R01>-0.20791169</R01>
                    <R02>0.35053676</R02>
                    <R10>0.19410229</R10>
                    <R11>0.9781475</R11>
                    <R12>0.074508846</R12>
                    <R20>-0.35836795</R20>
                    <R21>0.000000033840976</R21>
                    <R22>0.93358046</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">78</Ref>
                  <Ref name="Part1">85</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="86">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.49977875</X>
                    <Y>-0.47418213</Y>
                    <Z>1.2228394</Z>
                    <R00>0.94446236</R00>
                    <R01>0.3187374</R01>
                    <R02>0.07998364</R02>
                    <R10>0.016710356</R10>
                    <R11>0.19649601</R11>
                    <R12>-0.9803622</R12>
                    <R20>-0.32819462</R20>
                    <R21>0.92725164</R21>
                    <R22>0.18025692</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">78</Ref>
                  <Ref name="Part1">87</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="88">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.08847618</X>
                    <Y>0.09999752</Y>
                    <Z>-1.0999756</Z>
                    <R00>-0.000000043711385</R00>
                    <R01>-0.99999994</R01>
                    <R02>0</R02>
                    <R10>-0.9816272</R10>
                    <R11>0.00000004290829</R11>
                    <R12>-0.1908089</R12>
                    <R20>0.1908089</R20>
                    <R21>-0.000000008340522</R21>
                    <R22>-0.9816272</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">78</Ref>
                  <Ref name="Part1">73</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="89">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>1.0000002</X>
                    <Y>0</Y>
                    <Z>1.0999756</Z>
                    <R00>0.9816272</R00>
                    <R01>0.00000000080309165</R01>
                    <R02>0.190809</R02>
                    <R10>0.00000000080309165</R10>
                    <R11>0.9999999</R11>
                    <R12>-0.000000008340526</R12>
                    <R20>-0.190809</R20>
                    <R21>0.000000008340526</R21>
                    <R22>0.9816272</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">78</Ref>
                  <Ref name="Part1">90</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="91">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>1.4691343</X>
                    <Y>-0.15538406</Y>
                    <Z>1.0999756</Z>
                    <R00>0.4908136</R00>
                    <R01>-0.86602527</R01>
                    <R02>0.09540456</R02>
                    <R10>0.8501139</R10>
                    <R11>0.49999994</R11>
                    <R12>0.16524532</R12>
                    <R20>-0.19080895</R20>
                    <R21>0.00000008405086</R21>
                    <R22>0.9816272</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">78</Ref>
                  <Ref name="Part1">92</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="87">
              <Properties>
                <string name="Name">Coin</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>9.161523</X>
                  <Y>2.9919293</Y>
                  <Z>-619.2</Z>
                  <R00>-0.31873745</R00>
                  <R01>-0.19649604</R01>
                  <R02>-0.9272517</R02>
                  <R10>-0.9423715</R10>
                  <R11>0.1706585</R11>
                  <R12>0.28777015</R12>
                  <R20>0.10169771</R20>
                  <R21>0.9655386</R21>
                  <R22>-0.23956755</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">15710264</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">1088</token>
                <Content name="MeshID">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <SharedString name="PhysicalConfigData">+KXn2PVkmG8K5+S8Au8qxA==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0.4000000059604645</float>
                <token name="RenderFidelity">0</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="MeshPart" referent="83">
              <Properties>
                <string name="Name">Coin</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>7.961523</X>
                  <Y>3.2919292</Y>
                  <Z>-619.8</Z>
                  <R00>-0.000000043711385</R00>
                  <R01>-0.99999994</R01>
                  <R02>0</R02>
                  <R10>-0.91354537</R10>
                  <R11>0.00000003993234</R11>
                  <R12>-0.40673667</R12>
                  <R20>0.40673667</R20>
                  <R21>-0.000000017779024</R21>
                  <R22>-0.91354537</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">15710264</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">1088</token>
                <Content name="MeshID">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <SharedString name="PhysicalConfigData">+KXn2PVkmG8K5+S8Au8qxA==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0.4000000059604645</float>
                <token name="RenderFidelity">0</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="MeshPart" referent="90">
              <Properties>
                <string name="Name">Coin</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>7.961523</X>
                  <Y>3.7919295</Y>
                  <Z>-618.8</Z>
                  <R00>-0.000000043711385</R00>
                  <R01>-0.99999994</R01>
                  <R02>0</R02>
                  <R10>-1</R10>
                  <R11>0.00000004371139</R11>
                  <R12>0.00000008742278</R12>
                  <R20>-0.00000008742278</R20>
                  <R21>0.000000000000003821371</R21>
                  <R22>-1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">15710264</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">1088</token>
                <Content name="MeshID">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <SharedString name="PhysicalConfigData">+KXn2PVkmG8K5+S8Au8qxA==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0.4000000059604645</float>
                <token name="RenderFidelity">0</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="MeshPart" referent="85">
              <Properties>
                <string name="Name">Coin</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>7.561523</X>
                  <Y>3.2919295</Y>
                  <Z>-618.3</Z>
                  <R00>0.20791166</R00>
                  <R01>-0.97814757</R01>
                  <R02>-0.000000018176218</R02>
                  <R10>-0.96328735</R10>
                  <R11>-0.204753</R11>
                  <R12>0.17364827</R12>
                  <R20>-0.16985364</R20>
                  <R21>-0.036103476</R21>
                  <R22>-0.9848077</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">15710264</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">1088</token>
                <Content name="MeshID">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <SharedString name="PhysicalConfigData">+KXn2PVkmG8K5+S8Au8qxA==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0.4000000059604645</float>
                <token name="RenderFidelity">0</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="MeshPart" referent="92">
              <Properties>
                <string name="Name">Coin</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>6.6115236</X>
                  <Y>3.3919294</Y>
                  <Z>-618.8</Z>
                  <R00>0.8660253</R00>
                  <R01>-0.5</R01>
                  <R02>-0.000000075710346</R02>
                  <R10>-0.50000006</R10>
                  <R11>-0.8660252</R11>
                  <R12>0.000000043711385</R12>
                  <R20>-0.00000008742278</R20>
                  <R21>0.000000000000003821371</R21>
                  <R22>-1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">15710264</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">1088</token>
                <Content name="MeshID">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <Content name="MeshId">
                  <url>rbxassetid://4970807658</url>
                </Content>
                <SharedString name="PhysicalConfigData">+KXn2PVkmG8K5+S8Au8qxA==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <float name="Reflectance">0.4000000059604645</float>
                <token name="RenderFidelity">0</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.1769540011882782</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="93">
          <Properties>
            <string name="Name">Pets</string>
          </Properties>
          <Item class="Model" referent="94">
            <Properties>
              <string name="Name">Path Pet Green</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">95</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="95">
              <Properties>
                <string name="Name">Path Pet Green</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>40.160004</X>
                  <Y>109.250015</Y>
                  <Z>-431.745</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">4953931</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.5</X>
                  <Y>1.5</Y>
                  <Z>1.5</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="ParticleEmitter" referent="96">
                <Properties>
                  <string name="Name">trail</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <ColorSequence name="Color">0 0 0.962539 0 0 1 0 0.962539 0 0 </ColorSequence>
                  <float name="Drag">0</float>
                  <token name="EmissionDirection">2</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">1000 1000 </NumberRange>
                  <float name="LightEmission">0</float>
                  <float name="LightInfluence">1</float>
                  <bool name="LockedToPart">false</bool>
                  <float name="Rate">5</float>
                  <NumberRange name="RotSpeed">0 0 </NumberRange>
                  <NumberRange name="Rotation">0 0 </NumberRange>
                  <NumberSequence name="Size">0 0.6 0 1 0.6 0 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">0 0 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/particles/sparkles_main.dds</url>
                  </Content>
                  <NumberSequence name="Transparency">0 0 0 0.951276 0 0 0.987239 0.85625 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="BodyGyro" referent="97">
                <Properties>
                  <string name="Name">BodyGyro</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="D">500</float>
                  <Vector3 name="MaxTorque">
                    <X>4000000</X>
                    <Y>4000000</Y>
                    <Z>4000000</Z>
                  </Vector3>
                  <float name="P">3000</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="BodyPosition" referent="98">
                <Properties>
                  <string name="Name">BodyPosition</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="D">1250</float>
                  <Vector3 name="MaxForce">
                    <X>4000000</X>
                    <Y>4000000</Y>
                    <Z>4000000</Z>
                  </Vector3>
                  <float name="P">10000</float>
                  <Vector3 name="Position">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="99">
              <Properties>
                <string name="Name">Face</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>40.160004</X>
                  <Y>109.250015</Y>
                  <Z>-432.51498</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">false</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">0</float>
                <float name="FrontParamB">0</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.2599999904632568</X>
                  <Y>1.1799999475479126</Y>
                  <Z>0.05000000074505806</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Decal" referent="100">
                <Properties>
                  <string name="Name">Decal</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://4828695202</url>
                  </Content>
                  <float name="Transparency">0</float>
                </Properties>
              </Item>
              <Item class="Weld" referent="101">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>-0.77000046</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">99</Ref>
                  <Ref name="Part1">95</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Model" referent="102">
            <Properties>
              <string name="Name">Path Pet Rainbow</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">103</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="103">
              <Properties>
                <string name="Name">Path Pet Rainbow</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>47.160004</X>
                  <Y>108.75001</Y>
                  <Z>-431.745</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">16316664</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">288</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.5</X>
                  <Y>1.5</Y>
                  <Z>1.5</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0.15000000596046448</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="ParticleEmitter" referent="104">
                <Properties>
                  <string name="Name">trail</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <ColorSequence name="Color">0 0.933333 0.898039 0 0 0.0483333 1 0 0 0 0.135 0.965331 0.497383 0.109209 0 0.255 0.912001 0.900649 0 0 0.356667 0 0.95964 0 0 0.453333 0.142535 0.134096 0.948272 0 0.695 0.532509 0 0.546471 0 0.995 0.54902 0.0392157 0.521569 0 1 0.933333 0.898039 0 0 </ColorSequence>
                  <float name="Drag">0</float>
                  <token name="EmissionDirection">2</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">1000 1000 </NumberRange>
                  <float name="LightEmission">0</float>
                  <float name="LightInfluence">1</float>
                  <bool name="LockedToPart">false</bool>
                  <float name="Rate">5</float>
                  <NumberRange name="RotSpeed">0 0 </NumberRange>
                  <NumberRange name="Rotation">0 0 </NumberRange>
                  <NumberSequence name="Size">0 0.6 0 1 0.6 0 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">0 0 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/particles/sparkles_main.dds</url>
                  </Content>
                  <NumberSequence name="Transparency">0 0 0 0.951276 0 0 0.987239 0.85625 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="BodyGyro" referent="105">
                <Properties>
                  <string name="Name">BodyGyro</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="D">500</float>
                  <Vector3 name="MaxTorque">
                    <X>4000000</X>
                    <Y>4000000</Y>
                    <Z>4000000</Z>
                  </Vector3>
                  <float name="P">3000</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="BodyPosition" referent="106">
                <Properties>
                  <string name="Name">BodyPosition</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="D">1250</float>
                  <Vector3 name="MaxForce">
                    <X>4000000</X>
                    <Y>4000000</Y>
                    <Z>4000000</Z>
                  </Vector3>
                  <float name="P">10000</float>
                  <Vector3 name="Position">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="107">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0.75</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">103</Ref>
                  <Ref name="Part1">108</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="108">
              <Properties>
                <string name="Name">Face</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>47.160004</X>
                  <Y>108.75001</Y>
                  <Z>-432.495</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">false</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.2599999904632568</X>
                  <Y>1.1799999475479126</Y>
                  <Z>0.05000000074505806</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Decal" referent="109">
                <Properties>
                  <string name="Name">Decal</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://4828695202</url>
                  </Content>
                  <float name="Transparency">0</float>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Model" referent="110">
            <Properties>
              <string name="Name">Path Pet Red</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">111</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="111">
              <Properties>
                <string name="Name">Path Pet Red</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>44.160004</X>
                  <Y>109.250015</Y>
                  <Z>-431.745</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">16711680</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.5</X>
                  <Y>1.5</Y>
                  <Z>1.5</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="ParticleEmitter" referent="112">
                <Properties>
                  <string name="Name">trail</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <ColorSequence name="Color">0 1 0 0 0 1 1 0 0 0 </ColorSequence>
                  <float name="Drag">0</float>
                  <token name="EmissionDirection">2</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">1000 1000 </NumberRange>
                  <float name="LightEmission">0</float>
                  <float name="LightInfluence">1</float>
                  <bool name="LockedToPart">false</bool>
                  <float name="Rate">5</float>
                  <NumberRange name="RotSpeed">0 0 </NumberRange>
                  <NumberRange name="Rotation">0 0 </NumberRange>
                  <NumberSequence name="Size">0 0.6 0 1 0.6 0 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">0 0 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/particles/sparkles_main.dds</url>
                  </Content>
                  <NumberSequence name="Transparency">0 0 0 0.951276 0 0 0.987239 0.85625 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="BodyPosition" referent="113">
                <Properties>
                  <string name="Name">BodyPosition</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="D">1250</float>
                  <Vector3 name="MaxForce">
                    <X>4000000</X>
                    <Y>4000000</Y>
                    <Z>4000000</Z>
                  </Vector3>
                  <float name="P">10000</float>
                  <Vector3 name="Position">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="BodyGyro" referent="114">
                <Properties>
                  <string name="Name">BodyGyro</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="D">500</float>
                  <Vector3 name="MaxTorque">
                    <X>4000000</X>
                    <Y>4000000</Y>
                    <Z>4000000</Z>
                  </Vector3>
                  <float name="P">3000</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="115">
              <Properties>
                <string name="Name">Face</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>44.160004</X>
                  <Y>109.250015</Y>
                  <Z>-432.495</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">false</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.2599999904632568</X>
                  <Y>1.1799999475479126</Y>
                  <Z>0.05000000074505806</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Decal" referent="116">
                <Properties>
                  <string name="Name">Decal</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://4828695202</url>
                  </Content>
                  <float name="Transparency">0</float>
                </Properties>
              </Item>
              <Item class="Weld" referent="117">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>-0.75</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">115</Ref>
                  <Ref name="Part1">111</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Model" referent="118">
            <Properties>
              <string name="Name">Path Pet Yellow</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">119</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="119">
              <Properties>
                <string name="Name">Path Pet Yellow</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>42.160004</X>
                  <Y>108.75001</Y>
                  <Z>-431.745</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">16776960</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.5</X>
                  <Y>1.5</Y>
                  <Z>1.5</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Weld" referent="120">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0.75</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">119</Ref>
                  <Ref name="Part1">121</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="ParticleEmitter" referent="122">
                <Properties>
                  <string name="Name">trail</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <ColorSequence name="Color">0 0.936187 0.899611 0 0 1 0.936187 0.899611 0 0 </ColorSequence>
                  <float name="Drag">0</float>
                  <token name="EmissionDirection">2</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">1000 1000 </NumberRange>
                  <float name="LightEmission">0</float>
                  <float name="LightInfluence">1</float>
                  <bool name="LockedToPart">false</bool>
                  <float name="Rate">5</float>
                  <NumberRange name="RotSpeed">0 0 </NumberRange>
                  <NumberRange name="Rotation">0 0 </NumberRange>
                  <NumberSequence name="Size">0 0.6 0 1 0.6 0 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">0 0 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/particles/sparkles_main.dds</url>
                  </Content>
                  <NumberSequence name="Transparency">0 0 0 0.951276 0 0 0.987239 0.85625 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="BodyGyro" referent="123">
                <Properties>
                  <string name="Name">BodyGyro</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="D">500</float>
                  <Vector3 name="MaxTorque">
                    <X>4000000</X>
                    <Y>4000000</Y>
                    <Z>4000000</Z>
                  </Vector3>
                  <float name="P">3000</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="BodyPosition" referent="124">
                <Properties>
                  <string name="Name">BodyPosition</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="D">1250</float>
                  <Vector3 name="MaxForce">
                    <X>4000000</X>
                    <Y>4000000</Y>
                    <Z>4000000</Z>
                  </Vector3>
                  <float name="P">10000</float>
                  <Vector3 name="Position">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="121">
              <Properties>
                <string name="Name">Face</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>42.160004</X>
                  <Y>108.75001</Y>
                  <Z>-432.495</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">false</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.2599999904632568</X>
                  <Y>1.1799999475479126</Y>
                  <Z>0.05000000074505806</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Decal" referent="125">
                <Properties>
                  <string name="Name">Decal</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://4828695202</url>
                  </Content>
                  <float name="Transparency">0</float>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Model" referent="126">
            <Properties>
              <string name="Name">Speed Pet 1</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">127</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="127">
              <Properties>
                <string name="Name">Speed Pet 1</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>59.283203</X>
                  <Y>104.15001</Y>
                  <Z>-417.11926</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">16711680</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.299999952316284</X>
                  <Y>2.299999952316284</Y>
                  <Z>2.299999952316284</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0.20000000298023224</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Weld" referent="128">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.021965027</X>
                    <Y>0.040000916</Y>
                    <Z>1.1494992</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">127</Ref>
                  <Ref name="Part1">129</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="130">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.05329895</X>
                    <Y>0.093696594</Y>
                    <Z>0.019984245</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">127</Ref>
                  <Ref name="Part1">131</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="ParticleEmitter" referent="132">
                <Properties>
                  <string name="Name">ParticleEmitter</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <ColorSequence name="Color">0 0.734096 0 0 0 1 0.734096 0 0 0 </ColorSequence>
                  <float name="Drag">0</float>
                  <token name="EmissionDirection">1</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">0.5 0.5 </NumberRange>
                  <float name="LightEmission">0.6000000238418579</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">false</bool>
                  <float name="Rate">1000</float>
                  <NumberRange name="RotSpeed">199 199 </NumberRange>
                  <NumberRange name="Rotation">0 0 </NumberRange>
                  <NumberSequence name="Size">0 1.56442 0.521473 1 1.53374 0.521473 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">2 6 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>http://www.roblox.com/asset/?id=242997264</url>
                  </Content>
                  <NumberSequence name="Transparency">0 0 0 0.627182 0.5875 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="BodyPosition" referent="133">
                <Properties>
                  <string name="Name">BodyPosition</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="D">1250</float>
                  <Vector3 name="MaxForce">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">10000</float>
                  <Vector3 name="Position">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="BodyGyro" referent="134">
                <Properties>
                  <string name="Name">BodyGyro</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="D">500</float>
                  <Vector3 name="MaxTorque">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">3000</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="129">
              <Properties>
                <string name="Name">Face</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>59.26124</X>
                  <Y>104.11001</Y>
                  <Z>-418.26877</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10011355</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.630000352859497</X>
                  <Y>1.7200000286102295</Y>
                  <Z>0.05000000074505806</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Decal" referent="135">
                <Properties>
                  <string name="Name">Face</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://4828998294</url>
                  </Content>
                  <float name="Transparency">0</float>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="131">
              <Properties>
                <string name="Name">Inside</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>59.229904</X>
                  <Y>104.05631</Y>
                  <Z>-417.13925</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">7667712</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
          <Item class="Model" referent="136">
            <Properties>
              <string name="Name">Speed Pet 2</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">137</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="137">
              <Properties>
                <string name="Name">Speed Pet 2</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>72.2832</X>
                  <Y>104.15001</Y>
                  <Z>-417.11926</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">16756736</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.299999952316284</X>
                  <Y>2.299999952316284</Y>
                  <Z>2.299999952316284</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0.20000000298023224</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="ParticleEmitter" referent="138">
                <Properties>
                  <string name="Name">ParticleEmitter</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <ColorSequence name="Color">0 1 0.233219 0.0504768 0 1 1 0.233219 0.0504768 0 </ColorSequence>
                  <float name="Drag">0</float>
                  <token name="EmissionDirection">1</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">0.5 0.5 </NumberRange>
                  <float name="LightEmission">0.6000000238418579</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">false</bool>
                  <float name="Rate">1000</float>
                  <NumberRange name="RotSpeed">199 199 </NumberRange>
                  <NumberRange name="Rotation">0 0 </NumberRange>
                  <NumberSequence name="Size">0 1.56442 0.521473 1 1.53374 0.521473 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">2 6 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>http://www.roblox.com/asset/?id=242997264</url>
                  </Content>
                  <NumberSequence name="Transparency">0 0 0 0.627182 0.5875 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="BodyPosition" referent="139">
                <Properties>
                  <string name="Name">BodyPosition</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="D">1250</float>
                  <Vector3 name="MaxForce">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">10000</float>
                  <Vector3 name="Position">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="BodyGyro" referent="140">
                <Properties>
                  <string name="Name">BodyGyro</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="D">500</float>
                  <Vector3 name="MaxTorque">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">3000</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="141">
              <Properties>
                <string name="Name">Face</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>72.26124</X>
                  <Y>104.11001</Y>
                  <Z>-418.26877</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10011355</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.630000352859497</X>
                  <Y>1.7200000286102295</Y>
                  <Z>0.05000000074505806</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Decal" referent="142">
                <Properties>
                  <string name="Name">Face</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://4828998294</url>
                  </Content>
                  <float name="Transparency">0</float>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="143">
              <Properties>
                <string name="Name">Inside</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>72.229904</X>
                  <Y>104.05631</Y>
                  <Z>-417.13925</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">13988669</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Weld" referent="144">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.05329895</X>
                    <Y>-0.093696594</Y>
                    <Z>-0.019984245</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">143</Ref>
                  <Ref name="Part1">137</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="145">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.031333923</X>
                    <Y>-0.05369568</Y>
                    <Z>1.1295149</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">143</Ref>
                  <Ref name="Part1">141</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Model" referent="146">
            <Properties>
              <string name="Name">Speed Pet 3</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">147</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="147">
              <Properties>
                <string name="Name">Speed Pet 3</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>83.2832</X>
                  <Y>104.15001</Y>
                  <Z>-417.11926</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">16776960</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.299999952316284</X>
                  <Y>2.299999952316284</Y>
                  <Z>2.299999952316284</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0.20000000298023224</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="BodyGyro" referent="148">
                <Properties>
                  <string name="Name">BodyGyro</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="D">500</float>
                  <Vector3 name="MaxTorque">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">3000</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="BodyPosition" referent="149">
                <Properties>
                  <string name="Name">BodyPosition</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="D">1250</float>
                  <Vector3 name="MaxForce">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">10000</float>
                  <Vector3 name="Position">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="ParticleEmitter" referent="150">
                <Properties>
                  <string name="Name">ParticleEmitter</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <ColorSequence name="Color">0 0.927016 0.890822 0 0 1 0.927016 0.890822 0 0 </ColorSequence>
                  <float name="Drag">0</float>
                  <token name="EmissionDirection">1</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">0.5 0.5 </NumberRange>
                  <float name="LightEmission">0.6000000238418579</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">false</bool>
                  <float name="Rate">1000</float>
                  <NumberRange name="RotSpeed">199 199 </NumberRange>
                  <NumberRange name="Rotation">0 0 </NumberRange>
                  <NumberSequence name="Size">0 1.56442 0.521473 1 1.53374 0.521473 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">2 6 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>http://www.roblox.com/asset/?id=242997264</url>
                  </Content>
                  <NumberSequence name="Transparency">0 0 0 0.627182 0.5875 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="151">
              <Properties>
                <string name="Name">Face</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>83.26124</X>
                  <Y>104.11001</Y>
                  <Z>-418.26877</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10011355</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.630000352859497</X>
                  <Y>1.7200000286102295</Y>
                  <Z>0.05000000074505806</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Decal" referent="152">
                <Properties>
                  <string name="Name">Face</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://4828998294</url>
                  </Content>
                  <float name="Transparency">0</float>
                </Properties>
              </Item>
              <Item class="Weld" referent="153">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.031333923</X>
                    <Y>0.05369568</Y>
                    <Z>-1.1295149</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">151</Ref>
                  <Ref name="Part1">154</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="155">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.021965027</X>
                    <Y>-0.040000916</Y>
                    <Z>-1.1494992</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">151</Ref>
                  <Ref name="Part1">147</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="154">
              <Properties>
                <string name="Name">Inside</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>83.229904</X>
                  <Y>104.05631</Y>
                  <Z>-417.13925</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">16108848</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
          <Item class="Model" referent="156">
            <Properties>
              <string name="Name">Speed Pet 4</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">157</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="157">
              <Properties>
                <string name="Name">Speed Pet 4</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>94.2832</X>
                  <Y>104.15001</Y>
                  <Z>-417.11926</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">16775166</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.299999952316284</X>
                  <Y>2.299999952316284</Y>
                  <Z>2.299999952316284</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0.20000000298023224</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Weld" referent="158">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.021965027</X>
                    <Y>0.040000916</Y>
                    <Z>1.1494992</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">157</Ref>
                  <Ref name="Part1">159</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="160">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.05329895</X>
                    <Y>0.093696594</Y>
                    <Z>0.019984245</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">157</Ref>
                  <Ref name="Part1">161</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="BodyGyro" referent="162">
                <Properties>
                  <string name="Name">BodyGyro</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="D">500</float>
                  <Vector3 name="MaxTorque">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">3000</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="BodyPosition" referent="163">
                <Properties>
                  <string name="Name">BodyPosition</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="D">1250</float>
                  <Vector3 name="MaxForce">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">10000</float>
                  <Vector3 name="Position">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="ParticleEmitter" referent="164">
                <Properties>
                  <string name="Name">ParticleEmitter</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <ColorSequence name="Color">0 0.971984 1 0.983749 0 1 0.971984 1 0.983749 0 </ColorSequence>
                  <float name="Drag">0</float>
                  <token name="EmissionDirection">1</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">0.5 0.5 </NumberRange>
                  <float name="LightEmission">0.6000000238418579</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">false</bool>
                  <float name="Rate">1000</float>
                  <NumberRange name="RotSpeed">199 199 </NumberRange>
                  <NumberRange name="Rotation">0 0 </NumberRange>
                  <NumberSequence name="Size">0 1.56442 0.521473 1 1.53374 0.521473 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">2 6 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>http://www.roblox.com/asset/?id=242997264</url>
                  </Content>
                  <NumberSequence name="Transparency">0 0 0 0.627182 0.5875 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="159">
              <Properties>
                <string name="Name">Face</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>94.26124</X>
                  <Y>104.11001</Y>
                  <Z>-418.26877</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10011355</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.630000352859497</X>
                  <Y>1.7200000286102295</Y>
                  <Z>0.05000000074505806</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Decal" referent="165">
                <Properties>
                  <string name="Name">Face</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://4828998294</url>
                  </Content>
                  <float name="Transparency">0</float>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="161">
              <Properties>
                <string name="Name">Inside</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>94.229904</X>
                  <Y>104.05631</Y>
                  <Z>-417.13925</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">13487565</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
          <Item class="Model" referent="166">
            <Properties>
              <string name="Name">Speed Pet 5</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">167</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="167">
              <Properties>
                <string name="Name">Speed Pet 5</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>106.2832</X>
                  <Y>104.15001</Y>
                  <Z>-417.11926</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">65535</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.299999952316284</X>
                  <Y>2.299999952316284</Y>
                  <Z>2.299999952316284</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0.20000000298023224</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="ParticleEmitter" referent="168">
                <Properties>
                  <string name="Name">ParticleEmitter</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <ColorSequence name="Color">0 0 0.887968 1 0 1 0 0.887968 1 0 </ColorSequence>
                  <float name="Drag">0</float>
                  <token name="EmissionDirection">1</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">0.5 0.5 </NumberRange>
                  <float name="LightEmission">0.6000000238418579</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">false</bool>
                  <float name="Rate">1000</float>
                  <NumberRange name="RotSpeed">199 199 </NumberRange>
                  <NumberRange name="Rotation">0 0 </NumberRange>
                  <NumberSequence name="Size">0 1.56442 0.521473 1 1.53374 0.521473 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">2 6 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>http://www.roblox.com/asset/?id=242997264</url>
                  </Content>
                  <NumberSequence name="Transparency">0 0 0 0.627182 0.5875 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="BodyPosition" referent="169">
                <Properties>
                  <string name="Name">BodyPosition</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="D">1250</float>
                  <Vector3 name="MaxForce">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">10000</float>
                  <Vector3 name="Position">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="BodyGyro" referent="170">
                <Properties>
                  <string name="Name">BodyGyro</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="D">500</float>
                  <Vector3 name="MaxTorque">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">3000</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="171">
              <Properties>
                <string name="Name">Face</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>106.26124</X>
                  <Y>104.11001</Y>
                  <Z>-418.26877</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10011355</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.630000352859497</X>
                  <Y>1.7200000286102295</Y>
                  <Z>0.05000000074505806</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Decal" referent="172">
                <Properties>
                  <string name="Name">Face</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://4828998294</url>
                  </Content>
                  <float name="Transparency">0</float>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="173">
              <Properties>
                <string name="Name">Inside</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>106.229904</X>
                  <Y>104.05631</Y>
                  <Z>-417.13925</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">36764</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Weld" referent="174">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.05329895</X>
                    <Y>-0.093696594</Y>
                    <Z>-0.019984245</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">173</Ref>
                  <Ref name="Part1">167</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="175">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.031333923</X>
                    <Y>-0.05369568</Y>
                    <Z>1.1295149</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">173</Ref>
                  <Ref name="Part1">171</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Model" referent="176">
            <Properties>
              <string name="Name">Speed Pet 6</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <Ref name="PrimaryPart">177</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="177">
              <Properties>
                <string name="Name">Speed Pet 6</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>119.2832</X>
                  <Y>104.15001</Y>
                  <Z>-417.11926</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">307180</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2.299999952316284</X>
                  <Y>2.299999952316284</Y>
                  <Z>2.299999952316284</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0.20000000298023224</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="ParticleEmitter" referent="178">
                <Properties>
                  <string name="Name">ParticleEmitter</string>
                  <Vector3 name="Acceleration">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <ColorSequence name="Color">0 0 0.233738 1 0 1 0 0.233738 1 0 </ColorSequence>
                  <float name="Drag">0</float>
                  <token name="EmissionDirection">1</token>
                  <bool name="Enabled">true</bool>
                  <NumberRange name="Lifetime">0.5 0.5 </NumberRange>
                  <float name="LightEmission">0.6000000238418579</float>
                  <float name="LightInfluence">0</float>
                  <bool name="LockedToPart">false</bool>
                  <float name="Rate">1000</float>
                  <NumberRange name="RotSpeed">199 199 </NumberRange>
                  <NumberRange name="Rotation">0 0 </NumberRange>
                  <NumberSequence name="Size">0 1.56442 0.521473 1 1.53374 0.521473 </NumberSequence>
                  <int64 name="SourceAssetId">-1</int64>
                  <NumberRange name="Speed">2 6 </NumberRange>
                  <Vector2 name="SpreadAngle">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>http://www.roblox.com/asset/?id=242997264</url>
                  </Content>
                  <NumberSequence name="Transparency">0 0 0 0.627182 0.5875 0 1 1 0 </NumberSequence>
                  <float name="VelocityInheritance">0</float>
                  <float name="ZOffset">0</float>
                </Properties>
              </Item>
              <Item class="BodyPosition" referent="179">
                <Properties>
                  <string name="Name">BodyPosition</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="D">1250</float>
                  <Vector3 name="MaxForce">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">10000</float>
                  <Vector3 name="Position">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="BodyGyro" referent="180">
                <Properties>
                  <string name="Name">BodyGyro</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="D">500</float>
                  <Vector3 name="MaxTorque">
                    <X>2000000</X>
                    <Y>2000000</Y>
                    <Z>2000000</Z>
                  </Vector3>
                  <float name="P">3000</float>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="181">
              <Properties>
                <string name="Name">Face</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>119.26124</X>
                  <Y>104.11001</Y>
                  <Z>-418.26877</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10011355</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1.630000352859497</X>
                  <Y>1.7200000286102295</Y>
                  <Z>0.05000000074505806</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
              <Item class="Decal" referent="182">
                <Properties>
                  <string name="Name">Face</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxassetid://4828998294</url>
                  </Content>
                  <float name="Transparency">0</float>
                </Properties>
              </Item>
              <Item class="Weld" referent="183">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.031333923</X>
                    <Y>0.05369568</Y>
                    <Z>-1.1295149</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">181</Ref>
                  <Ref name="Part1">184</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Weld" referent="185">
                <Properties>
                  <string name="Name">BTWeld</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.021965027</X>
                    <Y>-0.040000916</Y>
                    <Z>-1.1494992</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="Enabled">true</bool>
                  <Ref name="Part0">181</Ref>
                  <Ref name="Part1">177</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="184">
              <Properties>
                <string name="Name">Inside</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>119.229904</X>
                  <Y>104.05631</Y>
                  <Z>-417.13925</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">255</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">272</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>2</Y>
                  <Z>2</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="186">
          <Properties>
            <string name="Name">Prefabs</string>
          </Properties>
          <Item class="Part" referent="187">
            <Properties>
              <string name="Name">FinishPlaceholder</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>76.02484</X>
                <Y>13.92466</Y>
                <Z>-651.64984</Z>
                <R00>-0.00000004371139</R00>
                <R01>-1</R01>
                <R02>0</R02>
                <R10>1</R10>
                <R11>-0.00000004371139</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>0.99999994</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">2064413</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">2</token>
              <Vector3 name="size">
                <X>2</X>
                <Y>16</Y>
                <Z>16</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"><![CDATA[RmluaXNoQnJpY2s=]]></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="ParticleEmitter" referent="188">
              <Properties>
                <string name="Name">ParticleEmitter</string>
                <Vector3 name="Acceleration">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <ColorSequence name="Color">0 1 1 1 0 1 1 1 1 0 </ColorSequence>
                <float name="Drag">0</float>
                <token name="EmissionDirection">0</token>
                <bool name="Enabled">true</bool>
                <NumberRange name="Lifetime">0.5 0.5 </NumberRange>
                <float name="LightEmission">0</float>
                <float name="LightInfluence">0</float>
                <bool name="LockedToPart">false</bool>
                <float name="Rate">65</float>
                <NumberRange name="RotSpeed">0 0 </NumberRange>
                <NumberRange name="Rotation">0 0 </NumberRange>
                <NumberSequence name="Size">0 0 0 0.158354 0.9375 0 1 10 0 </NumberSequence>
                <int64 name="SourceAssetId">-1</int64>
                <NumberRange name="Speed">42 42 </NumberRange>
                <Vector2 name="SpreadAngle">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="Texture">
                  <url>http://www.roblox.com/asset/?id=243042003</url>
                </Content>
                <NumberSequence name="Transparency">0 0 0 0.627182 0.5875 0 1 1 0 </NumberSequence>
                <float name="VelocityInheritance">0</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
          </Item>
          <Item class="Part" referent="189">
            <Properties>
              <string name="Name">Floor</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>0</X>
                <Y>10</Y>
                <Z>-606</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>1</X>
                <Y>20</Y>
                <Z>15</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">0</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
          </Item>
          <Item class="Part" referent="190">
            <Properties>
              <string name="Name">Killbrick</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>0</X>
                <Y>21.50001</Y>
                <Z>-531</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">16711680</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>1</X>
                <Y>1</Y>
                <Z>15</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"><![CDATA[S2lsbEJyaWNr]]></BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">0.5</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
          </Item>
          <Item class="Part" referent="191">
            <Properties>
              <string name="Name">SpawnPlaceholder</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>59.37567</X>
                <Y>-1.3823082</Y>
                <Z>-621.2697</Z>
                <R00>-0.000000043711342</R00>
                <R01>-0.9999989</R01>
                <R02>0</R02>
                <R10>0.9999989</R10>
                <R11>-0.000000043711342</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>0.99999994</R22>
              </CoordinateFrame>
              <bool name="CanCollide">false</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">307180</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">512</token>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">2</token>
              <Vector3 name="size">
                <X>2</X>
                <Y>16</Y>
                <Z>16</Z>
              </Vector3>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">1</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
            <Item class="ParticleEmitter" referent="192">
              <Properties>
                <string name="Name">ParticleEmitter</string>
                <Vector3 name="Acceleration">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <ColorSequence name="Color">0 0.0588235 0.34902 0.658824 0 1 0.309804 1 0.898039 0 </ColorSequence>
                <float name="Drag">0</float>
                <token name="EmissionDirection">0</token>
                <bool name="Enabled">true</bool>
                <NumberRange name="Lifetime">10 10 </NumberRange>
                <float name="LightEmission">0.800000011920929</float>
                <float name="LightInfluence">0</float>
                <bool name="LockedToPart">false</bool>
                <float name="Rate">20</float>
                <NumberRange name="RotSpeed">0 0 </NumberRange>
                <NumberRange name="Rotation">0 0 </NumberRange>
                <NumberSequence name="Size">0 1 0 1 0 0 </NumberSequence>
                <int64 name="SourceAssetId">-1</int64>
                <NumberRange name="Speed">2 2 </NumberRange>
                <Vector2 name="SpreadAngle">
                  <X>10</X>
                  <Y>10</Y>
                </Vector2>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="Texture">
                  <url>http://www.roblox.com/asset/?id=241650934</url>
                </Content>
                <NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
                <float name="VelocityInheritance">0</float>
                <float name="ZOffset">0</float>
              </Properties>
            </Item>
          </Item>
          <Item class="Part" referent="193">
            <Properties>
              <string name="Name">Wall</string>
              <bool name="Anchored">true</bool>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <float name="BackParamA">-0.5</float>
              <float name="BackParamB">0.5</float>
              <token name="BackSurface">0</token>
              <token name="BackSurfaceInput">0</token>
              <float name="BottomParamA">-0.5</float>
              <float name="BottomParamB">0.5</float>
              <token name="BottomSurface">0</token>
              <token name="BottomSurfaceInput">0</token>
              <CoordinateFrame name="CFrame">
                <X>0</X>
                <Y>10</Y>
                <Z>-183</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <bool name="CanCollide">true</bool>
              <bool name="CastShadow">true</bool>
              <int name="CollisionGroupId">0</int>
              <Color3uint8 name="Color3uint8">10724005</Color3uint8>
              <PhysicalProperties name="CustomPhysicalProperties">
                <CustomPhysics>false</CustomPhysics>
              </PhysicalProperties>
              <token name="formFactorRaw">1</token>
              <float name="FrontParamA">-0.5</float>
              <float name="FrontParamB">0.5</float>
              <token name="FrontSurface">0</token>
              <token name="FrontSurfaceInput">0</token>
              <float name="LeftParamA">-0.5</float>
              <float name="LeftParamB">0.5</float>
              <token name="LeftSurface">0</token>
              <token name="LeftSurfaceInput">0</token>
              <bool name="Locked">false</bool>
              <bool name="Massless">false</bool>
              <token name="Material">256</token>
              <float name="Reflectance">0</float>
              <float name="RightParamA">-0.5</float>
              <float name="RightParamB">0.5</float>
              <token name="RightSurface">0</token>
              <token name="RightSurfaceInput">0</token>
              <int name="RootPriority">0</int>
              <Vector3 name="RotVelocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <token name="shape">1</token>
              <Vector3 name="size">
                <X>1</X>
                <Y>20</Y>
                <Z>15</Z>
              </Vector3>
              <BinaryString name="Tags">
              </BinaryString>
              <float name="TopParamA">-0.5</float>
              <float name="TopParamB">0.5</float>
              <token name="TopSurface">0</token>
              <token name="TopSurfaceInput">0</token>
              <float name="Transparency">0</float>
              <Vector3 name="Velocity">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="194">
          <Properties>
            <string name="Name">Trails</string>
          </Properties>
          <Item class="Trail" referent="195">
            <Properties>
              <string name="Name">GreenTrail</string>
              <Ref name="Attachment0">null</Ref>
              <Ref name="Attachment1">null</Ref>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <ColorSequence name="Color">0 0.129717 0.778912 0.0675059 0 1 0.129717 0.778912 0.0675059 0 </ColorSequence>
              <bool name="Enabled">true</bool>
              <bool name="FaceCamera">false</bool>
              <float name="Lifetime">20</float>
              <float name="LightEmission">0</float>
              <float name="LightInfluence">1</float>
              <float name="MaxLength">0</float>
              <float name="MinLength">0.10000000149011612</float>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
              <Content name="Texture">
                <null>
                </null>
              </Content>
              <float name="TextureLength">1</float>
              <token name="TextureMode">0</token>
              <NumberSequence name="Transparency">0 0.5 0 1 0.5 0 </NumberSequence>
              <NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
            </Properties>
          </Item>
          <Item class="Trail" referent="196">
            <Properties>
              <string name="Name">RainbowTrail</string>
              <Ref name="Attachment0">null</Ref>
              <Ref name="Attachment1">null</Ref>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <ColorSequence name="Color">0 1 1 0 0 0.0415973 1 0 0 0 0.0748752 1 0 0 0 0.0915141 1 0 0 0 0.121464 1 0.141026 0 0 0.134775 1 0.333333 0 0 0.236273 1 1 0 0 0.264559 1 1 0 0 0.281198 1 1 0 0 0.282862 1 1 0 0 0.287854 1 1 0 0 0.339434 0.333333 1 0 0 0.425957 0 0 1 0 0.532446 0 0 1 0 0.557404 0 0 1 0 0.592346 0 0 1 0 0.645591 0.333333 0 0.498039 0 0.848586 0.333333 0 0.498039 0 0.97005 0.333333 0 0.498039 0 1 1 1 1 0 </ColorSequence>
              <bool name="Enabled">true</bool>
              <bool name="FaceCamera">false</bool>
              <float name="Lifetime">20</float>
              <float name="LightEmission">0</float>
              <float name="LightInfluence">1</float>
              <float name="MaxLength">0</float>
              <float name="MinLength">0.10000000149011612</float>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
              <Content name="Texture">
                <null>
                </null>
              </Content>
              <float name="TextureLength">1</float>
              <token name="TextureMode">0</token>
              <NumberSequence name="Transparency">0 0.5 0 1 0.5 0 </NumberSequence>
              <NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
            </Properties>
          </Item>
          <Item class="Trail" referent="197">
            <Properties>
              <string name="Name">RedTrail</string>
              <Ref name="Attachment0">null</Ref>
              <Ref name="Attachment1">null</Ref>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <ColorSequence name="Color">0 0.904402 0.058381 0.148089 0 1 0.904402 0.058381 0.148089 0 </ColorSequence>
              <bool name="Enabled">true</bool>
              <bool name="FaceCamera">false</bool>
              <float name="Lifetime">20</float>
              <float name="LightEmission">0</float>
              <float name="LightInfluence">1</float>
              <float name="MaxLength">0</float>
              <float name="MinLength">0.10000000149011612</float>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
              <Content name="Texture">
                <null>
                </null>
              </Content>
              <float name="TextureLength">1</float>
              <token name="TextureMode">0</token>
              <NumberSequence name="Transparency">0 0.5 0 1 0.5 0 </NumberSequence>
              <NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
            </Properties>
          </Item>
          <Item class="Trail" referent="198">
            <Properties>
              <string name="Name">YellowTrail</string>
              <Ref name="Attachment0">null</Ref>
              <Ref name="Attachment1">null</Ref>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <ColorSequence name="Color">0 0.929625 0.851286 0.0984054 0 1 0.929625 0.851286 0.0984054 0 </ColorSequence>
              <bool name="Enabled">true</bool>
              <bool name="FaceCamera">false</bool>
              <float name="Lifetime">20</float>
              <float name="LightEmission">0</float>
              <float name="LightInfluence">1</float>
              <float name="MaxLength">0</float>
              <float name="MinLength">0.10000000149011612</float>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
              <Content name="Texture">
                <null>
                </null>
              </Content>
              <float name="TextureLength">1</float>
              <token name="TextureMode">0</token>
              <NumberSequence name="Transparency">0 0.5 0 1 0.5 0 </NumberSequence>
              <NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="199">
          <Properties>
            <string name="Name">Walls</string>
          </Properties>
          <Item class="Folder" referent="200">
            <Properties>
              <string name="Name">Walls_1</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Model" referent="201">
              <Properties>
                <string name="Name">Wall_gray</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <token name="LevelOfDetail">0</token>
                <CoordinateFrame name="ModelInPrimary">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <CoordinateFrame name="ModelMeshCFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <Vector3 name="ModelMeshSize">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Ref name="PrimaryPart">202</Ref>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
              </Properties>
              <Item class="Part" referent="202">
                <Properties>
                  <string name="Name">Wall_gray</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>10</Y>
                    <Z>-579</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10461612</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <token name="formFactorRaw">1</token>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">848</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <token name="shape">1</token>
                  <Vector3 name="size">
                    <X>1</X>
                    <Y>20</Y>
                    <Z>15</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="Part" referent="203">
                <Properties>
                  <string name="Name">Wall_killbrick</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.5</Y>
                    <Z>-579</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">16711680</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <token name="formFactorRaw">1</token>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">256</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <token name="shape">1</token>
                  <Vector3 name="size">
                    <X>1</X>
                    <Y>1</Y>
                    <Z>15</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags"><![CDATA[S2lsbEJyaWNr]]></BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">1</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="204">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-573.3768</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="205">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-581.77673</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="206">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-579.67676</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="207">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-571.97675</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="208">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-576.17676</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="209">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-583.8767</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="210">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-585.27673</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="211">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-576.8768</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="212">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-574.77673</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="213">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-574.0768</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="214">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-580.3767</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="215">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-578.27673</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="216">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-572.67676</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="217">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-578.97675</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="218">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-581.0767</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="219">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-577.5767</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="220">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-582.47675</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="221">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-584.5767</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="222">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-585.9767</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="223">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-583.1767</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="CornerWedgePart" referent="224">
                <Properties>
                  <string name="Name">CornerWedge</string>
                  <bool name="Anchored">true</bool>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <float name="BackParamA">-0.5</float>
                  <float name="BackParamB">0.5</float>
                  <token name="BackSurface">0</token>
                  <token name="BackSurfaceInput">0</token>
                  <float name="BottomParamA">-0.5</float>
                  <float name="BottomParamB">0.5</float>
                  <token name="BottomSurface">0</token>
                  <token name="BottomSurfaceInput">0</token>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>20.241093</Y>
                    <Z>-575.47675</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <bool name="CanCollide">true</bool>
                  <bool name="CastShadow">true</bool>
                  <int name="CollisionGroupId">0</int>
                  <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                  <PhysicalProperties name="CustomPhysicalProperties">
                    <CustomPhysics>false</CustomPhysics>
                  </PhysicalProperties>
                  <float name="FrontParamA">-0.5</float>
                  <float name="FrontParamB">0.5</float>
                  <token name="FrontSurface">0</token>
                  <token name="FrontSurfaceInput">0</token>
                  <float name="LeftParamA">-0.5</float>
                  <float name="LeftParamB">0.5</float>
                  <token name="LeftSurface">0</token>
                  <token name="LeftSurfaceInput">0</token>
                  <bool name="Locked">false</bool>
                  <bool name="Massless">false</bool>
                  <token name="Material">800</token>
                  <float name="Reflectance">0</float>
                  <float name="RightParamA">-0.5</float>
                  <float name="RightParamB">0.5</float>
                  <token name="RightSurface">0</token>
                  <token name="RightSurfaceInput">0</token>
                  <int name="RootPriority">0</int>
                  <Vector3 name="RotVelocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="size">
                    <X>0.5999999642372131</X>
                    <Y>0.5999999642372131</Y>
                    <Z>0.699999988079071</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <float name="TopParamA">-0.5</float>
                  <float name="TopParamB">0.5</float>
                  <token name="TopSurface">0</token>
                  <token name="TopSurfaceInput">0</token>
                  <float name="Transparency">0</float>
                  <Vector3 name="Velocity">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="225">
            <Properties>
              <string name="Name">Walls_1_killbrick</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="226">
              <Properties>
                <string name="Name">Wall_killbrick</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>16.5</Y>
                  <Z>-87.99999</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">16711680</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1</X>
                  <Y>1</Y>
                  <Z>15</Z>
                </Vector3>
                <BinaryString name="Tags"><![CDATA[S2lsbEJyaWNr]]></BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0.800000011920929</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="227">
            <Properties>
              <string name="Name">Walls_2</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="228">
              <Properties>
                <string name="Name">Wall_lightgray</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>10</Y>
                  <Z>-597</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">11249822</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1</X>
                  <Y>20</Y>
                  <Z>15</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="229">
              <Properties>
                <string name="Name">Wall_grayer</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>10</Y>
                  <Z>-616</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">6907484</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1</X>
                  <Y>20</Y>
                  <Z>15</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="230">
              <Properties>
                <string name="Name">Wall_gray</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>10</Y>
                  <Z>-634</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1</X>
                  <Y>20</Y>
                  <Z>15</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="231">
        <Properties>
          <string name="Name">Plugin</string>
        </Properties>
        <Item class="Folder" referent="232">
          <Properties>
            <string name="Name">Actions</string>
          </Properties>
          <Item class="ModuleScript" referent="233">
            <Properties>
              <string name="Name">SetSettings</string>
              <string name="Source">return function(text)
	return {
		type = 'SetSettings',
		text = text,
	}
end</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="234">
          <Properties>
            <string name="Name">Assets</string>
            <string name="Source">local strict = require(script.Parent.strict)

local Assets = {
	Sprites = {},
	Slices = {
		RoundBox = {
			asset = 'rbxassetid://2773204550',
			offset = Vector2.new(0, 0),
			size = Vector2.new(32, 32),
			center = Rect.new(4, 4, 4, 4),
		},
	},
	Images = {
		Logo = 'rbxassetid://5747479619',
		Icon = 'rbxassetid://5747497742',
	},
}

local function guardForTypos(name, map)
	strict(name, map)

	for key, child in pairs(map) do
		if type(child) == 'table' then
			guardForTypos(('%s.%s'):format(name, key), child)
		end
	end
end

guardForTypos('Assets', Assets)

return Assets</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="235">
          <Properties>
            <string name="Name">Components</string>
          </Properties>
          <Item class="ModuleScript" referent="236">
            <Properties>
              <string name="Name">App</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Plugin = Root.Plugin
local ChangeHistoryService = game:GetService('ChangeHistoryService')
local Roact = require(Root:WaitForChild('Roact'))
local Log = require(Root.Log)

local Config = require(Plugin.Config)
local Version = require(Plugin.Version)
local preloadAssets = require(Plugin.preloadAssets)
local MazeGenerator = require(Plugin.Maze.MazeGenerator)
local SettingsForm = require(Plugin.Components.SettingsForm)

local e = Roact.createElement

local App = Roact.Component:extend('App')

function App:init()
	self.displayedVersion = Version.display(Config.version)
end

function App:generateMaze(settings)
	MazeGenerator:generate(settings)
	ChangeHistoryService:SetWaypoint('Generated Maze')
end

function App:render()
	local children

	children = { SettingsForm = e(SettingsForm, { generateMaze = function(settings)
		self:generateMaze(settings)
	end }) }

	return e(Roact.Portal, { target = self.props.root }, children)
end

function App:didMount()
	Log.trace('Root {} initializing', self.displayedVersion)

	preloadAssets()
end

function App:willUnmount()
	if self.serveSession ~= nil then
		self.serveSession:stop()
		self.serveSession = nil
	end
end

return App</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="237">
            <Properties>
              <string name="Name">Checkbox</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Plugin = Root.Plugin

local Roact = require(Root:WaitForChild('Roact'))

local Theme = require(Plugin.Components.Theme)

local e = Roact.createElement

local function Checkbox(props)
	local checked = props.checked
	local layoutOrder = props.layoutOrder
	local onChange = props.onChange

	return Theme.with(function(theme)
		return e(
			'ImageButton',
			{
				LayoutOrder = layoutOrder,
				Size = UDim2.new(0, 20, 0, 20),
				BorderSizePixel = 2,
				BorderColor3 = theme.Text2,
				BackgroundColor3 = theme.Background2,
				[Roact.Event.Activated] = function()
					onChange(not checked)
				end,
			},
			{ Indicator = e('Frame', {
				Size = UDim2.new(0, 18, 0, 18),
				Position = UDim2.new(0.5, 0, 0.5, 0),
				AnchorPoint = Vector2.new(0.5, 0.5),
				BorderSizePixel = 0,
				BackgroundColor3 = theme.Brand1,
				BackgroundTransparency = checked and 0 or 1,
			}) }
		)
	end)
end

return Checkbox</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="238">
            <Properties>
              <string name="Name">DropdownMenu</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Plugin = Root.Plugin

local Roact = require(Root:WaitForChild('Roact'))
local M = require(Root.M)
local FitScrollingFrame = require(Plugin.Components.FitScrollingFrame)

local RoundButton = require(Plugin.Components.RoundButton)
local DropdownItem = require(Plugin.Components.DropdownMenuItem)

local DropdownMenu = Roact.Component:extend('DropdownMenu')

local function noop()
end

function DropdownMenu:init()
	local value = self.props.value
	local options = self.props.options

	if value then
		self:setState({
			selectedIndex = M.find(options, value.Name),
			expanded = false,
		})
	else
		self:setState({
			selectedIndex = 1,
			expanded = false,
		})
	end
end

function DropdownMenu:toggle()
	self:setState(function(state)
		return { expanded = not state.expanded }
	end)
end

function DropdownMenu:render()
	local options = self.props.options
	local color = self.props.color
	local defaultText = self.props.defaultText
	local expanded = self.state.expanded
	local selectedIndex = self.state.selectedIndex
	local onSelect = self.props.onSelect or noop

	local menuOptions = {}

	for index, option in ipairs(options) do
		menuOptions[option] = Roact.createElement(DropdownItem, {
			option = option,
			index = index,
			color = color,
			onActivated = function()
				self:setState({ selectedIndex = index })
				self:toggle()
				onSelect(index)
			end,
		})
	end

	local menu = Roact.createElement(
		FitScrollingFrame,
		{
			fitAxes = 'Y',
			containerProps = {
				Size = UDim2.new(1, 0, 0, 400),
				Position = UDim2.new(0, 0, 1, 4),
				color = color,
				Visible = expanded,
			},
			layoutProps = { Padding = UDim.new(0, 4) },
			paddingProps = {
				PaddingTop = UDim.new(0, 16),
				PaddingBottom = UDim.new(0, 16),
				PaddingLeft = UDim.new(0, 0),
				PaddingRight = UDim.new(0, 0),
			},
		},
		menuOptions
	)

	local button = Roact.createElement(RoundButton, {
		Size = UDim2.new(1, 0, 0, 40),
		Text = options[selectedIndex] or defaultText or 'N/A',
		onClicked = function()
			self:toggle()
		end,
	})

	local frameProps = {
		Size = self.props.Size,
		Position = self.props.Position,
		AnchorPoint = self.props.AnchorPoint,
		LayoutOrder = self.props.LayoutOrder,
		BackgroundTransparency = 1,
	}

	return Roact.createElement('Frame', frameProps, {
		button = button,
		menu = menu,
	})
end

return DropdownMenu</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="239">
            <Properties>
              <string name="Name">DropdownMenuItem</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')

local Roact = require(Root:WaitForChild('Roact'))

return function(props)
	local option = props.option
	local index = props.index
	local color = props.color

	local onActivated = props.onActivated

	return Roact.createElement('TextButton', {
		Text = '  ' .. option,
		Font = Enum.Font.GothamSemibold,
		TextSize = 18,
		TextXAlignment = Enum.TextXAlignment.Left,
		LayoutOrder = index,
		Size = UDim2.new(1, 0, 0, 32),
		BorderSizePixel = 0,
		BackgroundColor3 = color,
		[Roact.Event.Activated] = function()
			onActivated()
		end,
	})
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="240">
            <Properties>
              <string name="Name">ErrorPanel</string>
              <string name="Source">local Roact = require(script:FindFirstAncestor('MazeGeneratorPlugin').Roact)

local Plugin = script:FindFirstAncestor('Plugin')

local Theme = require(Plugin.Components.Theme)
local Panel = require(Plugin.Components.Panel)
local FitText = require(Plugin.Components.FitText)
local FitScrollingFrame = require(Plugin.Components.FitScrollingFrame)
local FormButton = require(Plugin.Components.FormButton)

local e = Roact.createElement

local BUTTON_HEIGHT = 60
local HOR_PADDING = 8

local ErrorPanel = Roact.Component:extend('ErrorPanel')

function ErrorPanel:render()
	local errorMessage = self.props.errorMessage
	local onDismiss = self.props.onDismiss

	return Theme.with(function(theme)
		return e(Panel, nil, {
			Layout = Roact.createElement('UIListLayout', {
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				VerticalAlignment = Enum.VerticalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				Padding = UDim.new(0, 8),
			}),
			ErrorContainer = e(
				FitScrollingFrame,
				{
					containerProps = {
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						Size = UDim2.new(1, -HOR_PADDING * 2, 1, -BUTTON_HEIGHT),
						Position = UDim2.new(0, HOR_PADDING, 0, 0),
						ScrollBarImageColor3 = theme.Text1,
						VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
						ScrollingDirection = Enum.ScrollingDirection.Y,
					},
				},
				{ Text = e(FitText, {
					Size = UDim2.new(1, 0, 0, 0),
					LayoutOrder = 1,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Top,
					FitAxis = 'Y',
					Font = theme.ButtonFont,
					TextSize = 18,
					Text = errorMessage,
					TextWrap = true,
					TextColor3 = theme.Text1,
					BackgroundTransparency = 1,
				}) }
			),
			DismissButton = e(FormButton, {
				layoutOrder = 2,
				text = 'Dismiss',
				secondary = true,
				onClick = function()
					onDismiss()
				end,
			}),
		})
	end)
end

return ErrorPanel</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="241">
            <Properties>
              <string name="Name">FitList</string>
              <string name="Source">local Roact = require(script:FindFirstAncestor('MazeGeneratorPlugin').Roact)

local Dictionary = require(script.Parent.Parent.Dictionary)

local e = Roact.createElement

local FitList = Roact.Component:extend('FitList')

function FitList:init()
	self.sizeBinding, self.setSize = Roact.createBinding(UDim2.new())
end

function FitList:render()
	local containerKind = self.props.containerKind or 'Frame'
	local fitAxes = self.props.fitAxes or 'XY'
	local containerProps = self.props.containerProps
	local layoutProps = self.props.layoutProps
	local paddingProps = self.props.paddingProps

	local padding
	if paddingProps ~= nil then
		padding = e('UIPadding', paddingProps)
	end

	local children = Dictionary.merge(self.props[Roact.Children], {
		['$Layout'] = e(
			'UIListLayout',
			Dictionary.merge(
				{
					SortOrder = Enum.SortOrder.LayoutOrder,
					[Roact.Change.AbsoluteContentSize] = function(instance)
						local contentSize = instance.AbsoluteContentSize

						if paddingProps ~= nil then
							contentSize =
								contentSize + Vector2.new(
									paddingProps.PaddingLeft.Offset + paddingProps.PaddingRight.Offset,
									paddingProps.PaddingTop.Offset + paddingProps.PaddingBottom.Offset
								)
						end

						local combinedSize

						if fitAxes == 'X' then
							combinedSize =
								UDim2.new(
									0,
									contentSize.X,
									containerProps.Size.Y.Scale,
									containerProps.Size.Y.Offset
								)
						elseif fitAxes == 'Y' then
							combinedSize =
								UDim2.new(
									containerProps.Size.X.Scale,
									containerProps.Size.X.Offset,
									0,
									contentSize.Y
								)
						elseif fitAxes == 'XY' then
							combinedSize = UDim2.new(0, contentSize.X, 0, contentSize.Y)
						else
							error('Invalid fitAxes value')
						end

						self.setSize(combinedSize)
					end,
				},
				layoutProps
			)
		),
		['$Padding'] = padding,
	})

	local fullContainerProps = Dictionary.merge(containerProps, { Size = self.sizeBinding })

	return e(containerKind, fullContainerProps, children)
end

return FitList</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="242">
            <Properties>
              <string name="Name">FitScrollingFrame</string>
              <string name="Source">local Roact = require(script:FindFirstAncestor('MazeGeneratorPlugin').Roact)

local Dictionary = require(script.Parent.Parent.Dictionary)

local e = Roact.createElement

local FitScrollingFrame = Roact.Component:extend('FitScrollingFrame')

function FitScrollingFrame:init()
	self.sizeBinding, self.setSize = Roact.createBinding(UDim2.new())
end

function FitScrollingFrame:render()
	local containerProps = self.props.containerProps
	local layoutProps = self.props.layoutProps

	local children = Dictionary.merge(self.props[Roact.Children], { ['$Layout'] = e(
		'UIListLayout',
		Dictionary.merge(
			{
				SortOrder = Enum.SortOrder.LayoutOrder,
				[Roact.Change.AbsoluteContentSize] = function(instance)
					self.setSize(UDim2.new(0, 0, 0, instance.AbsoluteContentSize.Y))
				end,
			},
			layoutProps
		)
	) })

	local fullContainerProps = Dictionary.merge(containerProps, { CanvasSize = self.sizeBinding })

	return e('ScrollingFrame', fullContainerProps, children)
end

return FitScrollingFrame</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="243">
            <Properties>
              <string name="Name">FitText</string>
              <string name="Source">local TextService = game:GetService('TextService')

local Roact = require(script:FindFirstAncestor('MazeGeneratorPlugin').Roact)

local Dictionary = require(script.Parent.Parent.Dictionary)

local e = Roact.createElement

local FitText = Roact.Component:extend('FitText')

function FitText:init()
	self.ref = Roact.createRef()
	self.sizeBinding, self.setSize = Roact.createBinding(UDim2.new())
end

function FitText:render()
	local kind = self.props.Kind or 'TextLabel'

	local containerProps = Dictionary.merge(self.props, {
		FitAxis = Dictionary.None,
		Kind = Dictionary.None,
		Padding = Dictionary.None,
		MinSize = Dictionary.None,
		Size = self.sizeBinding,
		[Roact.Ref] = self.ref,
		[Roact.Change.AbsoluteSize] = function()
			self:updateTextMeasurements()
		end,
	})

	return e(kind, containerProps)
end

function FitText:didMount()
	self:updateTextMeasurements()
end

function FitText:didUpdate()
	self:updateTextMeasurements()
end

function FitText:updateTextMeasurements()
	local minSize = self.props.MinSize or Vector2.new(0, 0)
	local padding = self.props.Padding or Vector2.new(0, 0)
	local fitAxis = self.props.FitAxis or 'XY'
	local baseSize = self.props.Size

	local text = self.props.Text or ''
	local font = self.props.Font or Enum.Font.Legacy
	local textSize = self.props.TextSize or 12

	local containerSize = self.ref.current.AbsoluteSize

	local textBounds

	if fitAxis == 'XY' then
		textBounds = Vector2.new(9e6, 9e6)
	elseif fitAxis == 'X' then
		textBounds = Vector2.new(9e6, containerSize.Y - padding.Y * 2)
	elseif fitAxis == 'Y' then
		textBounds = Vector2.new(containerSize.X - padding.X * 2, 9e6)
	end

	local measuredText = TextService:GetTextSize(text, textSize, font, textBounds)

	local computedX = math.max(minSize.X, padding.X * 2 + measuredText.X)
	local computedY = math.max(minSize.Y, padding.Y * 2 + measuredText.Y)

	local totalSize

	if fitAxis == 'XY' then
		totalSize = UDim2.new(0, computedX, 0, computedY)
	elseif fitAxis == 'X' then
		totalSize = UDim2.new(0, computedX, baseSize.Y.Scale, baseSize.Y.Offset)
	elseif fitAxis == 'Y' then
		totalSize = UDim2.new(baseSize.X.Scale, baseSize.X.Offset, 0, computedY)
	end

	self.setSize(totalSize)
end

return FitText</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="244">
            <Properties>
              <string name="Name">Footer</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Plugin = Root.Plugin

local Roact = require(Root:WaitForChild('Roact'))

local Config = require(Plugin.Config)
local Version = require(Plugin.Version)
local Assets = require(Plugin.Assets)
local Theme = require(Plugin.Components.Theme)

local url = 'https://www.roblox.com/games/3376915546/Maze-World'
local gameId = '3376915546'
local e = Roact.createElement

local Footer = Roact.Component:extend('Footer')

function Footer:init()
	self.footerSize, self.setFooterSize = Roact.createBinding(Vector2.new())
	self.footerVersionSize, self.setFooterVersionSize = Roact.createBinding(Vector2.new())
end

function Footer:render()
	return Theme.with(function(theme)
		return e(
			'Frame',
			{
				LayoutOrder = 3,
				Size = UDim2.new(1, 0, 0, 32),
				BackgroundColor3 = theme.Background2,
				BorderSizePixel = 0,
				ZIndex = 2,
			},
			{
				Padding = e('UIPadding', {
					PaddingTop = UDim.new(0, 4),
					PaddingBottom = UDim.new(0, 4),
					PaddingLeft = UDim.new(0, 8),
					PaddingRight = UDim.new(0, 8),
				}),
				LogoContainer = e(
					'Frame',
					{
						BackgroundTransparency = 1,
						Size = UDim2.new(0, 0, 0, 32),
					},
					{ Logo = e('ImageButton', {
						Image = Assets.Images.Logo,
						Size = UDim2.new(0, 120, 0, 40),
						ScaleType = Enum.ScaleType.Fit,
						BackgroundTransparency = 1,
						Position = UDim2.new(0, 0, 1, 0),
						AnchorPoint = Vector2.new(0, 1),
					}) }
				),
				Link = e('TextLabel', {
					Position = UDim2.new(0.4, 0, 0, 0),
					Size = UDim2.new(0, 100, 1, 0),
					AnchorPoint = Vector2.new(0, 0),
					Font = theme.TitleFont,
					TextSize = 14,
					Text = 'Game id: ' .. gameId,
					TextXAlignment = Enum.TextXAlignment.Right,
					TextColor3 = theme.Text2,
					BackgroundTransparency = 1,
				}),
				Version = e('TextLabel', {
					Position = UDim2.new(1, 0, 0, 0),
					Size = UDim2.new(0, 0, 1, 0),
					AnchorPoint = Vector2.new(1, 0),
					Font = theme.TitleFont,
					TextSize = 18,
					Text = Version.display(Config.version),
					TextXAlignment = Enum.TextXAlignment.Right,
					TextColor3 = theme.Text2,
					BackgroundTransparency = 1,
					[Roact.Change.AbsoluteSize] = function(rbx)
						self.setFooterVersionSize(rbx.AbsoluteSize)
					end,
				}),
			}
		)
	end)
end

return Footer</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="245">
            <Properties>
              <string name="Name">FormButton</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Plugin = Root.Plugin

local Roact = require(Root:WaitForChild('Roact'))

local Theme = require(Plugin.Components.Theme)
local RoundButton = require(Plugin.Components.RoundButton)
local UIPadding = require(Plugin.Components.UIPadding)

local e = Roact.createElement

local function FormButton(props)
	local text = props.text
	local onClick = props.onClick
	local LayoutOrder = props.LayoutOrder

	local TextColor3
	local BackgroundColor3

	return Theme.with(function(theme)
		if props.secondary then
			TextColor3 = theme.Brand1
			BackgroundColor3 = theme.Background2
		else
			TextColor3 = theme.TextOnAccent
			BackgroundColor3 = theme.Brand1
		end

		local button = e(RoundButton, {
			Text = text,
			onClicked = onClick,
			TextColor3 = TextColor3,
			BackgroundColor3 = BackgroundColor3,
		})

		local frame = e(
			'Frame',
			{
				Size = UDim2.new(1, 0, 0, 60),
				BackgroundTransparency = 1,
				LayoutOrder = LayoutOrder,
			},
			{ button }
		)
		return frame
	end)
end

return FormButton</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="246">
            <Properties>
              <string name="Name">FormTextInput</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Plugin = Root.Plugin

local Roact = require(Root:WaitForChild('Roact'))

local Assets = require(Plugin.Assets)
local Theme = require(Plugin.Components.Theme)

local e = Roact.createElement

local RoundBox = Assets.Slices.RoundBox

local TEXT_SIZE = 22
local PADDING = 8

local FormTextInput = Roact.Component:extend('FormTextInput')

function FormTextInput:init()
	self:setState({ focused = false })
end

function FormTextInput:render()
	local value = self.props.value
	local placeholderValue = self.props.placeholderValue
	local onValueChange = self.props.onValueChange
	local layoutOrder = self.props.layoutOrder
	local width = self.props.width

	local shownPlaceholder
	if self.state.focused then
		shownPlaceholder = ''
	else
		shownPlaceholder = placeholderValue
	end

	return Theme.with(function(theme)
		return e(
			'ImageLabel',
			{
				LayoutOrder = layoutOrder,
				Image = RoundBox.asset,
				ImageRectOffset = RoundBox.offset,
				ImageRectSize = RoundBox.size,
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = RoundBox.center,
				ImageColor3 = theme.Background2,
				Size = UDim2.new(width.Scale, width.Offset, 0, TEXT_SIZE + PADDING * 2),
				BackgroundTransparency = 1,
			},
			{ InputInner = e('TextBox', {
				BackgroundTransparency = 1,
				Size = UDim2.new(1, -PADDING * 2, 1, -PADDING * 2),
				Position = UDim2.new(0.5, 0, 0.5, 0),
				AnchorPoint = Vector2.new(0.5, 0.5),
				Font = theme.InputFont,
				ClearTextOnFocus = false,
				TextXAlignment = Enum.TextXAlignment.Center,
				TextSize = TEXT_SIZE,
				Text = value,
				PlaceholderText = shownPlaceholder,
				PlaceholderColor3 = theme.Text2,
				TextColor3 = theme.Text1,
				[Roact.Change.Text] = function(rbx)
					onValueChange(rbx.Text)
				end,
				[Roact.Event.Focused] = function()
					self:setState({ focused = true })
				end,
				[Roact.Event.FocusLost] = function()
					self:setState({ focused = false })
				end,
			}) }
		)
	end)
end

return FormTextInput</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="247">
            <Properties>
              <string name="Name">MaterialsDropdown</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Plugin = Root.Plugin

local Roact = require(Root:WaitForChild('Roact'))
local M = require(Root.M)

local DropdownMenu = require(Plugin.Components.DropdownMenu)

local MaterialsDropdown = Roact.Component:extend('MaterialsDropdown')

local function noop()
end

function MaterialsDropdown:init()
end

function MaterialsDropdown:didMount()
end

function MaterialsDropdown:render()
	local onSelect = self.props.onSelect or noop
	local options = {}
	local tagMap = {}

	local materials = Enum.Material:GetEnumItems()
	for index, material in pairs(materials) do
		tagMap[index] = material

		table.insert(options, material.Name)
	end

	local mergedProps = M.extend(self.props, {
		options = options,
		onSelect = function(newIndex)
			local tag = tagMap[newIndex]
			onSelect(tag)
		end,
	})

	return Roact.createElement(DropdownMenu, mergedProps)
end

return MaterialsDropdown</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="248">
            <Properties>
              <string name="Name">OptionsList</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Roact = require(Root:WaitForChild('Roact'))
local Plugin = Root.Plugin
local OptionEntry = require(script.Parent.OptionEntry)
local Shortcuts = require(Plugin.Shortcuts)

local OptionsList = Roact.PureComponent:extend('OptionsList')

function OptionsList:init()
	self.state = { selectedItemIndex = 1 } -- first item in the array
end

function OptionsList:changeSelection(increment)
	self:setState(function(prevState, props)
		local nextIndex = prevState.selectedItemIndex + increment

		if nextIndex > #props.items then
			nextIndex = 1
		elseif nextIndex &lt; 1 then
			nextIndex = #props.items
		end

		return { selectedItemIndex = nextIndex }
	end)
end

function OptionsList:render()
	local entrySize = self.props.entrySize
	local children = {}

	children.Layout = Roact.createElement('UIListLayout', {
		Padding = UDim.new(0, 1),
		SortOrder = Enum.SortOrder.LayoutOrder,
	})

	for index, item in pairs(self.props.items) do
		children[item] = Roact.createElement(OptionEntry, {
			size = entrySize,
			layoutOrder = index,
			text = item,
			isSelected = self.state.selectedItemIndex == index,
		})
	end

	return Roact.createElement(
		'Frame',
		{
			BackgroundTransparency = 1,
			Size = self.props.frameSize,
			LayoutOrder = self.props.layoutOrder,
		},
		children
	)
end

function OptionsList:didMount()
	Shortcuts.bind(Shortcuts.SELECT_UP, function()
		self:changeSelection(-1)
	end)

	Shortcuts.bind(Shortcuts.SELECT_DOWN, function()
		self:changeSelection(1)
	end)
end

function OptionsList:willUnmount()
	Shortcuts.unbind(Shortcuts.SELEC_UP)
	Shortcuts.unbind(Shortcuts.SELEC_DOWN)
end

return OptionsList</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="249">
            <Properties>
              <string name="Name">Panel</string>
              <string name="Source">local Roact = require(script:FindFirstAncestor('MazeGeneratorPlugin').Roact)

local Plugin = script:FindFirstAncestor('Plugin')

local Footer = require(Plugin.Components.Footer)
local Theme = require(Plugin.Components.Theme)

local e = Roact.createElement

local Panel = Roact.Component:extend('Panel')

function Panel:init()
	self.footerSize, self.setFooterSize = Roact.createBinding(Vector2.new())
end

function Panel:render()
	return Theme.with(function(theme)
		return e(
			'Frame',
			{
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundColor3 = theme.Background1,
				BorderSizePixel = 1,
			},
			{
				Layout = Roact.createElement('UIListLayout', {
					HorizontalAlignment = Enum.HorizontalAlignment.Left,
					SortOrder = Enum.SortOrder.LayoutOrder,
				}),
				Body = e(
					'Frame',
					{
						Size = UDim2.new(1, 0, 1, -32),
						BackgroundTransparency = 1,
					},
					self.props[Roact.Children]
				),
				Footer = e(Footer),
			}
		)
	end)
end

return Panel</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="250">
            <Properties>
              <string name="Name">PluginSettings</string>
              <string name="Source">--[[
	Persistent plugin settings that can be accessed via Roact context.
]]

local Root = script:FindFirstAncestor('MazeGeneratorPlugin')

local Roact = require(Root:WaitForChild('Roact'))

local defaultSettings = {
	openScriptsExternally = false,
	twoWaySync = false,
}

local Settings = {}
Settings.__index = Settings

function Settings.fromPlugin(plugin)
	local values = {}

	for name, defaultValue in pairs(defaultSettings) do
		local savedValue = plugin:GetSetting('Root_' .. name)

		if savedValue == nil then
			plugin:SetSetting('Root_' .. name, defaultValue)
			values[name] = defaultValue
		else
			values[name] = savedValue
		end
	end

	return setmetatable(
		{
			__values = values,
			__plugin = plugin,
			__updateListeners = {},
		},
		Settings
	)
end

function Settings:get(name)
	if defaultSettings[name] == nil then
		error('Invalid setings name ' .. tostring(name), 2)
	end

	return self.__values[name]
end

function Settings:set(name, value)
	self.__plugin:SetSetting('Root_' .. name, value)
	self.__values[name] = value

	for callback in pairs(self.__updateListeners) do
		callback(name, value)
	end
end

function Settings:onUpdate(newCallback)
	local newListeners = {}
	for callback in pairs(self.__updateListeners) do
		newListeners[callback] = true
	end

	newListeners[newCallback] = true
	self.__updateListeners = newListeners

	return function()
		local newListeners = {}
		for callback in pairs(self.__updateListeners) do
			if callback ~= newCallback then
				newListeners[callback] = true
			end
		end

		self.__updateListeners = newListeners
	end
end

local Context = Roact.createContext(nil)

local StudioProvider = Roact.Component:extend('StudioProvider')

function StudioProvider:init()
	self.settings = Settings.fromPlugin(self.props.plugin)
end

function StudioProvider:render()
	return Roact.createElement(
		Context.Provider,
		{ value = self.settings },
		self.props[Roact.Children]
	)
end

local InternalConsumer = Roact.Component:extend('InternalConsumer')

function InternalConsumer:render()
	return self.props.render(self.props.settings)
end

function InternalConsumer:didMount()
	self.disconnect = self.props.settings:onUpdate(function()
	-- Trigger a dummy state update to update the settings consumer.
		self:setState({})
	end)
end

function InternalConsumer:willUnmount()
	self.disconnect()
end

local function with(callback)
	return Roact.createElement(Context.Consumer, { render = function(settings)
		return Roact.createElement(InternalConsumer, {
			settings = settings,
			render = callback,
		})
	end })
end

return {
	StudioProvider = StudioProvider,
	with = with,
}</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="251">
            <Properties>
              <string name="Name">RoundButton</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Plugin = Root.Plugin

local Roact = require(Root:WaitForChild('Roact'))
local M = require(Root.M)

local UICorner = require(Plugin.Components.UICorner)
local e = Roact.createElement

local materialIconsAsset = 'rbxassetid://3926305904'
local materialIconsAsset2 = 'rbxassetid://3926307971'
local Theme = require(Plugin.Components.Theme)

local MaterialIcons = {
	close = {
		Image = materialIconsAsset,
		ImageRectOffset = Vector2.new(284, 4),
		ImageRectSize = Vector2.new(24, 24),
	},
	inbox = {
		Image = materialIconsAsset,
		ImageRectOffset = Vector2.new(404, 484),
		ImageRectSize = Vector2.new(36, 36),
	},
	shop = {
		Image = materialIconsAsset2,
		ImageRectOffset = Vector2.new(684, 44),
		ImageRectSize = Vector2.new(36, 36),
	},
}

local function RoundButton(props)
	local image
	local aspect

	local size = UDim2.new(1, 0, 0, 50)

	if props.icon then
		size = UDim2.new(0.7, 0, 0.7, 0)
		aspect = e('UIAspectRatioConstraint')
		image = e(
			'ImageButton',
			M.extend(
				{
					Position = UDim2.new(0.5, 0, 0.5, 0),
					AnchorPoint = Vector2.new(0.5, 0.5),
					Size = UDim2.new(0, 25, 0, 25),
					BackgroundTransparency = 1,
					ZIndex = 2,
					[Roact.Event.MouseButton1Click] = function()
						props.onClicked()
					end,
				},
				MaterialIcons[props.icon]
			)
		)
	end
	return Theme.with(function(theme)
		return e(
			'TextButton',

			M.extend(
				{
					Font = theme.ButtonFont,
					Size = size,
					BackgroundColor3 = theme.Brand1,
					TextColor3 = theme.TextOnAccent,
					TextSize = 26,
					Text = '',
					[Roact.Event.MouseButton1Click] = function()
						props.onClicked()
					end,
				},
				M.omit(props, 'icon', 'onClicked')
			),
			{
				UICorner = e(UICorner),
				aspect,
				image,
			}
		)
	end)
end

return RoundButton</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="252">
            <Properties>
              <string name="Name">SettingsForm</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Roact = require(Root:WaitForChild('Roact'))
local Plugin = Root.Plugin
local RoactRodux = require(Root.RoactRodux)
local Config = require(Plugin.Config)
local Theme = require(Plugin.Components.Theme)
local Panel = require(Plugin.Components.Panel)
local FitScrollingFrame = require(Plugin.Components.FitScrollingFrame)
local FitText = require(Plugin.Components.FitText)
local FormButton = require(Plugin.Components.FormButton)
local FormTextInput = require(Plugin.Components.FormTextInput)
local PluginSettings = require(Plugin.Components.PluginSettings)
local MaterialsDropdown = require(Plugin.Components.MaterialsDropdown)
local Checkbox = require(Plugin.Components.Checkbox)
local SettingsFormItem = require(Plugin.Components.SettingsFormItem)
local UIPadding = require(Plugin.Components.UIPadding)
local SetSettings = require(Plugin.Actions.SetSettings)

local selection = game:GetService('Selection')
local e = Roact.createElement

local SettingsForm = Roact.Component:extend('SettingsForm')

function SettingsForm:init()
	local changeSettings = self.props.changeSettings
	local settings = self.props.settings
	selection.SelectionChanged:Connect(function()
		if #selection:Get() > 0 then
			changeSettings({ location = selection:Get()[1] })
		else
			changeSettings({ location = nil })
		end
	end)
end

function SettingsForm:render()
	local generateMaze = self.props.generateMaze
	local changeSettings = self.props.changeSettings
	local settings = self.props.settings

	return Theme.with(function(theme)
		return PluginSettings.with(function()
			local location = settings.location
			local locationName = 'workspace'
			local locationPos = tostring(Vector3.new(0, 0, 0))

			if location and location:IsA('BasePart') then
				locationName = location.Name
				locationPos = tostring(location.Position)
			end

			return e(Panel, nil, {
				Layout = e('UIListLayout', {
					SortOrder = Enum.SortOrder.LayoutOrder,
					HorizontalAlignment = Enum.HorizontalAlignment.Left,
					VerticalAlignment = Enum.VerticalAlignment.Top,
				}),
				Inputs = e(
					FitScrollingFrame,
					{
						fitAxes = 'Y',
						containerProps = {
							BackgroundTransparency = 1,
							LayoutOrder = 0,
							Size = UDim2.new(1, 0, 1, 0),
						},
						layoutProps = { Padding = UDim.new(0, 8) },
						paddingProps = {
							PaddingTop = UDim.new(0, 10),
							PaddingBottom = UDim.new(0, 10),
							PaddingLeft = UDim.new(0, 10),
							PaddingRight = UDim.new(0, 10),
						},
					},
					{
						UIPadding = e(UIPadding, { padding = 10 }),
						Location = e(SettingsFormItem, {
							LayoutOrder = 0,
							Text = 'Selection/Location',
							theme = theme,
							Input = e(FitText, {
								Kind = 'TextLabel',
								LayoutOrder = 2,
								BackgroundTransparency = 1,
								TextXAlignment = Enum.TextXAlignment.Left,
								Font = theme.TitleFont,
								TextSize = 20,
								Text = locationName .. ' ' .. locationPos,
								TextColor3 = theme.Text1,
							}),
						}),
						Height = e(SettingsFormItem, {
							LayoutOrder = 1,
							Text = 'Height',
							theme = theme,
							Input = e(FormTextInput, {
								layoutOrder = 2,
								width = UDim.new(0, 70),
								value = settings.height,
								placeholderValue = Config.defaultHeight,
								onValueChange = function(newValue)
									changeSettings({ height = newValue })
								end,
							}),
						}),
						Width = e(SettingsFormItem, {
							LayoutOrder = 2,
							Text = 'Width',
							theme = theme,
							Input = e(FormTextInput, {
								layoutOrder = 2,
								width = UDim.new(0, 70),
								value = settings.width,
								placeholderValue = Config.defaultWidth,
								onValueChange = function(newValue)
									changeSettings({ width = newValue })
								end,
							}),
						}),
						wallMaterial = e(SettingsFormItem, {
							LayoutOrder = 3,
							Text = 'Wall Material',
							theme = theme,
							Input = e(MaterialsDropdown, {
								Size = UDim2.new(0, 150, 1, 0),
								LayoutOrder = 2,
								value = settings.wallMaterial,
								onSelect = function(material)
									warn('Selected material', material)
									changeSettings({ wallMaterial = material })
								end,
							}),
						}),
						groundMaterial = e(SettingsFormItem, {
							LayoutOrder = 4,
							Text = 'Ground Material',
							theme = theme,
							Input = e(MaterialsDropdown, {
								Size = UDim2.new(0, 150, 1, 0),
								LayoutOrder = 2,
								value = settings.groundMaterial,
								onSelect = function(material)
									warn('Selected ground material', material)
									changeSettings({ groundMaterial = material })
								end,
							}),
						}),
						onlyBlocks = e(SettingsFormItem, {
							LayoutOrder = 5,
							Text = 'Use only blocks',
							theme = theme,
							Input = e(Checkbox, {
								layoutOrder = 2,
								checked = settings.onlyBlocks,
								onChange = function(newValue)
									warn('Use only blocks', newValue)
									changeSettings({ onlyBlocks = newValue })
								end,
							}),
						}),
						addRandomModels = e(SettingsFormItem, {
							LayoutOrder = 6,
							Text = 'Random models',
							theme = theme,
							Input = e(Checkbox, {
								layoutOrder = 2,
								checked = settings.addRandomModels,
								onChange = function(newValue)
									warn('Add random models', newValue)
									changeSettings({ addRandomModels = newValue })
								end,
							}),
						}),
						addStartAndFinish = e(SettingsFormItem, {
							LayoutOrder = 7,
							Text = 'Start and Finish',
							theme = theme,
							Input = e(Checkbox, {
								layoutOrder = 2,
								checked = settings.addStartAndFinish,
								onChange = function(newValue)
									warn('Add start and finish', newValue)
									changeSettings({ addStartAndFinish = newValue })
								end,
							}),
						}),
						addKillBlocks = e(SettingsFormItem, {
							LayoutOrder = 8,
							Text = 'Killblocks',
							theme = theme,
							Input = e(Checkbox, {
								layoutOrder = 2,
								checked = settings.addKillBlocks,
								onChange = function(newValue)
									warn('Add addKillBlocks', newValue)
									changeSettings({ addKillBlocks = newValue })
								end,
							}),
						}),
						addCeiling = e(SettingsFormItem, {
							LayoutOrder = 9,
							Text = 'Ceiling',
							theme = theme,
							Input = e(Checkbox, {
								layoutOrder = 2,
								checked = settings.addCeiling,
								onChange = function(newValue)
									warn('Add addCeiling', newValue)
									changeSettings({ addCeiling = newValue })
								end,
							}),
						}),
						Button = e(FormButton, {
							text = 'Generate',
							LayoutOrder = 10,
							onClick = function()
								if generateMaze ~= nil then
									local height = settings.height
									if height:len() == 0 then
										height = Config.defaultHeight
									end

									local width = settings.width
									if width:len() == 0 then
										width = Config.defaultWidth
									end

									generateMaze({
										width = width,
										height = height,
										wallMaterial = settings.wallMaterial,
										groundMaterial = settings.groundMaterial,
										addRandomModels = settings.addRandomModels,
										addStartAndFinish = settings.addStartAndFinish,
										addKillBlocks = settings.addKillBlocks,
										addCeiling = settings.addCeiling,
										onlyBlocks = settings.onlyBlocks,
										location = settings.location or workspace,
									})
								end
							end,
						}),
					}
				),
			})
		end)
	end)
end

local SettingsFormConnected = RoactRodux.connect(
	function(state)
		local settings = state.settings
		warn('settings', settings)
		return settings
	end,
	function(dispatch)
		return { changeSettings = function(settings)
			dispatch(SetSettings(settings))
		end }
	end
)(SettingsForm)

return SettingsFormConnected</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="253">
            <Properties>
              <string name="Name">SettingsFormItem</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Roact = require(Root.Roact)
local Plugin = Root.Plugin
local FitList = require(Plugin.Components.FitList)
local FitText = require(Plugin.Components.FitText)

local e = Roact.createElement

local function SettingsFormItem(props)
	local Text = props.Text
	local theme = props.theme
	local Input = props.Input
	local LayoutOrder = props.LayoutOrder

	local textFieldWidth = 200

	return e(
		FitList,
		{
			fitAxes = 'X',
			containerProps = {
				LayoutOrder = LayoutOrder,
				BackgroundTransparency = 1,
				Size = UDim2.new(0, 0, 0, 45),
			},
			layoutProps = {
				FillDirection = Enum.FillDirection.Horizontal,
				Padding = UDim.new(0, 10),
			},
		},
		{
			Label = e(FitText, {
				Kind = 'TextLabel',
				LayoutOrder = 1,
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				Font = theme.TitleFont,
				TextSize = 20,
				Text = Text,
				TextColor3 = theme.Text1,
				MinSize = Vector2.new(textFieldWidth, 0),
			}),
			Input = Input,
		}
	)
end

return SettingsFormItem</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="254">
            <Properties>
              <string name="Name">Theme</string>
              <string name="Source">--[[
	Theming system taking advantage of Roact's new context API.

	Doesn't use colors provided by Studio and instead just branches on theme
	name. This isn't exactly best practice.
]]

-- Studio does not exist outside Roblox Studio, so we'll lazily initialize it
-- when possible.
local _Studio
local function getStudio()
	if _Studio == nil then
		_Studio = settings():GetService('Studio')
	end

	return _Studio
end

local Root = script:FindFirstAncestor('MazeGeneratorPlugin')

local Roact = require(Root:WaitForChild('Roact'))
local Log = require(Root.Log)

local strict = require(script.Parent.Parent.strict)

local lightTheme = strict('Theme', {
	ButtonFont = Enum.Font.SourceSans,
	InputFont = Enum.Font.SourceSans,
	TitleFont = Enum.Font.SourceSans,
	MainFont = Enum.Font.SourceSans,
	Brand1 = Color3.fromRGB(124, 0, 215),
	Text1 = Color3.fromRGB(64, 64, 64),
	Text2 = Color3.fromRGB(160, 160, 160),
	TextOnAccent = Color3.fromRGB(235, 235, 235),
	Background1 = Color3.fromRGB(255, 255, 255),
	Background2 = Color3.fromRGB(235, 235, 235),
})

local darkTheme = strict('Theme', {
	ButtonFont = Enum.Font.SourceSans,
	InputFont = Enum.Font.SourceSans,
	TitleFont = Enum.Font.SourceSans,
	MainFont = Enum.Font.SourceSans,
	Brand1 = Color3.fromRGB(124, 0, 215),
	Text1 = Color3.fromRGB(235, 235, 235),
	Text2 = Color3.fromRGB(200, 200, 200),
	TextOnAccent = Color3.fromRGB(235, 235, 235),
	Background1 = Color3.fromRGB(48, 48, 48),
	Background2 = Color3.fromRGB(64, 64, 64),
})

local Context = Roact.createContext(lightTheme)

local StudioProvider = Roact.Component:extend('StudioProvider')

-- Pull the current theme from Roblox Studio and update state with it.
function StudioProvider:updateTheme()
	local studioTheme = getStudio().Theme

	if studioTheme.Name == 'Light' then
		self:setState({ theme = lightTheme })
	elseif studioTheme.Name == 'Dark' then
		self:setState({ theme = darkTheme })
	else
		Log.warn("Unexpected theme '{}'' -- falling back to light theme!", studioTheme.Name)

		self:setState({ theme = lightTheme })
	end
end

function StudioProvider:init()
	self:updateTheme()
end

function StudioProvider:render()
	return Roact.createElement(
		Context.Provider,
		{ value = self.state.theme },
		self.props[Roact.Children]
	)
end

function StudioProvider:didMount()
	self.connection = getStudio().ThemeChanged:Connect(function()
		self:updateTheme()
	end)
end

function StudioProvider:willUnmount()
	self.connection:Disconnect()
end

local function with(callback)
	return Roact.createElement(Context.Consumer, { render = callback })
end

return {
	StudioProvider = StudioProvider,
	Consumer = Context.Consumer,
	with = with,
}</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="255">
            <Properties>
              <string name="Name">UICorner</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Roact = require(Root:WaitForChild('Roact'))
local M = require(Root.M)

local createElement = Roact.createElement

local function UICorner(props)
	local joinedProps = M.extend({}, { CornerRadius = UDim.new(0, 4) }, props)

	return createElement('UICorner', joinedProps)
end

return UICorner</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="256">
            <Properties>
              <string name="Name">UIPadding</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Roact = require(Root:WaitForChild('Roact'))
local M = require(Root.M)

local createElement = Roact.createElement

local function UIPadding(props)
	local padding = props.padding

	local paddingProp = UDim.new(0, padding)

	return createElement(
		'UIPadding',
		M.extend(
			{
				PaddingBottom = paddingProp,
				PaddingLeft = paddingProp,
				PaddingRight = paddingProp,
				PaddingTop = paddingProp,
			},
			M.omit(props, 'padding')
		)
	)
end

return UIPadding</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="257">
          <Properties>
            <string name="Name">Config</string>
            <string name="Source">local strict = require(script.Parent.strict)
local PluginFolderName = 'MazeGeneratorPlugin'

local ServerStorage = game:GetService('ServerStorage')
local devSource = ServerStorage:FindFirstChild(PluginFolderName)

local isDevBuild = true
if not devSource and script.Parent.Parent.Parent ~= nil then
	isDevBuild = script.Parent.Parent.Parent:FindFirstChild('DEV_BUILD') ~= nil
end

return strict('Config', {
	isDevBuild = isDevBuild,
	codename = 'Epiphany',
	version = { 1, 0, 0 },
	expectedServerVersionString = '1.0 or newer',
	protocolVersion = 3,
	defaultHeight = '10',
	defaultWidth = '10',
})</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="258">
          <Properties>
            <string name="Name">DevSettings</string>
            <string name="Source">local Config = require(script.Parent.Config)

local Environment = {
	User = 'User',
	Dev = 'Dev',
	Test = 'Test',
}

local DEFAULT_ENVIRONMENT = Config.isDevBuild and Environment.Dev or Environment.User

local VALUES = {
	LogLevel = {
		type = 'IntValue',
		values = {
			[Environment.User] = 2,
			[Environment.Dev] = 4,
			[Environment.Test] = 4,
		},
	},
	TypecheckingEnabled = {
		type = 'BoolValue',
		values = {
			[Environment.User] = false,
			[Environment.Dev] = true,
			[Environment.Test] = true,
		},
	},
}

local CONTAINER_NAME = 'RootDevSettings' .. Config.codename

local function getValueContainer()
	return game:FindFirstChild(CONTAINER_NAME)
end

local valueContainer = getValueContainer()

game.ChildAdded:Connect(function(child)
	local success, name = pcall(function()
		return child.Name
	end)

	if success and name == CONTAINER_NAME then
		valueContainer = child
	end
end)

local function getStoredValue(name)
	if valueContainer == nil then
		return nil
	end

	local valueObject = valueContainer:FindFirstChild(name)

	if valueObject == nil then
		return nil
	end

	return valueObject.Value
end

local function setStoredValue(name, kind, value)
	local object = valueContainer:FindFirstChild(name)

	if object == nil then
		object = Instance.new(kind)
		object.Name = name
		object.Parent = valueContainer
	end

	object.Value = value
end

local function createAllValues(environment)
	assert(Environment[environment] ~= nil, 'Invalid environment')

	valueContainer = getValueContainer()

	if valueContainer == nil then
		valueContainer = Instance.new('Folder')
		valueContainer.Name = CONTAINER_NAME
		valueContainer.Parent = game
	end

	for name, value in pairs(VALUES) do
		setStoredValue(name, value.type, value.values[environment])
	end
end

local function getValue(name)
	assert(VALUES[name] ~= nil, 'Invalid DevSettings name')

	local stored = getStoredValue(name)

	if stored ~= nil then
		return stored
	end

	return VALUES[name].values[DEFAULT_ENVIRONMENT]
end

local DevSettings = {}

function DevSettings:createDevSettings()
	createAllValues(Environment.Dev)
end

function DevSettings:createTestSettings()
	createAllValues(Environment.Test)
end

function DevSettings:hasChangedValues()
	return valueContainer ~= nil
end

function DevSettings:resetValues()
	if valueContainer then
		valueContainer:Destroy()
		valueContainer = nil
	end
end

function DevSettings:isEnabled()
	return valueContainer ~= nil
end

function DevSettings:getLogLevel()
	return getValue('LogLevel')
end

function DevSettings:shouldTypecheck()
	return getValue('TypecheckingEnabled')
end

function _G.ROJO_DEV_CREATE()
	DevSettings:createDevSettings()
end

return DevSettings</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="259">
          <Properties>
            <string name="Name">Dictionary</string>
            <string name="Source">--[[
	This is a placeholder module waiting for Cryo to become available.
]]

local None = newproxy(true)
getmetatable(None).__tostring = function()
	return "None"
end

local function merge(...)
	local output = {}

	for i = 1, select("#", ...) do
		local source = select(i, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					output[key] = nil
				else
					output[key] = value
				end
			end
		end
	end

	return output
end

return {
	None = None,
	merge = merge,
}</string>
          </Properties>
        </Item>
        <Item class="Script" referent="260">
          <Properties>
            <string name="Name">Loader</string>
            <string name="Source">-- Taken from https://github.com/tiffany352/Roblox-Tag-Editor/blob/bd48fb7ceea6bcd1cd9c515891ae4eb4eb9d1a71/src/Loader.server.lua#L24

-- Sanity check.
if not plugin then
	error('Hot reloader must be executed as a plugin!')
end

-- Change to true to enable hot reloading support. Opening a place
-- containing the code synced via Rojo will cause the plugin to be
-- reloaded in edit mode. (No need for play solo or the hotswap plugin.)
local Config = require(script.Parent.Config)
local useDevSource = Config.isDevBuild
local ServerStorage = game:GetService('ServerStorage')
local PluginFolderName = 'MazeGeneratorPlugin'
local devSource = ServerStorage:FindFirstChild(PluginFolderName)

-- The source that's shipped integrated into the plugin.
local builtinSource = script.Parent.Parent

-- `source` is where we should watch for changes.
-- `currentRoot` is the clone we make of source to avoid require()
-- returning stale values.
local source = builtinSource
local currentRoot = source

local PluginFacade = {
	_toolbars = {},
	_pluginGuis = {},
	_buttons = {},
	_watching = {},
	_beforeUnload = nil,
}

--[[
	Abstraction for plugin:CreateToolbar
]]
function PluginFacade:toolbar(name)
	if self._toolbars[name] then
		return self._toolbars[name]
	end

	local toolbar = plugin:CreateToolbar(name)

	self._toolbars[name] = toolbar

	return toolbar
end
function PluginFacade:GetSetting(name)
	return plugin:GetSetting(name)
end
function PluginFacade:SetSetting(name)
	return plugin:SetSetting(name)
end

--[[
	Abstraction for toolbar:CreateButton
]]
function PluginFacade:button(toolbar, name, tooltip, icon)
	local existingButtons = self._buttons[toolbar]

	if existingButtons then
		local existingButton = existingButtons[name]

		if existingButton then
			return existingButton
		end
	else
		existingButtons = {}
		self._buttons[toolbar] = existingButtons
	end

	local button = toolbar:CreateButton(name, tooltip, icon)

	existingButtons[name] = button

	return button
end

--[[
	Wrapper around plugin:CreatePluginGui
]]
function PluginFacade:createDockWidgetPluginGui(name, ...)
	if self._pluginGuis[name] then
		return self._pluginGuis[name]
	end

	local gui = plugin:CreateDockWidgetPluginGui(name, ...)
	self._pluginGuis[name] = gui

	return gui
end

--[[
	Sets the method to call the next time the system tries to reload
]]
function PluginFacade:beforeUnload(callback)
	self._beforeUnload = callback
end

function PluginFacade:_load(savedState)
	local Plugin = currentRoot:WaitForChild('Plugin')
	local Main = Plugin:WaitForChild('Main')
	local ok, result = pcall(require, Main)

	if not ok then
		warn('Plugin failed to load: ' .. result)
		return
	end

	local MainPluginScript = result

	ok, result = pcall(MainPluginScript, PluginFacade, savedState)

	if not ok then
		warn('Plugin failed to run: ' .. result)
		return
	end
end

function PluginFacade:unload()
	if self._beforeUnload then
		local saveState = self._beforeUnload()
		self._beforeUnload = nil

		return saveState
	end
end

function PluginFacade:_reload()
	local saveState = self:unload()
	currentRoot = source:Clone()

	self:_load(saveState)
end

function PluginFacade:_watch(instance)
	if self._watching[instance] then return end

	-- Don't watch ourselves!
	if instance == script then return end

	local connection1 = instance.Changed:Connect(function(prop)
		print('Reloading due to', instance:GetFullName())

		self:_reload()
	end)

	local connection2 = instance.ChildAdded:Connect(function(instance)
		self:_watch(instance)
	end)

	local connections = { connection1, connection2 }

	self._watching[instance] = connections

	for _, child in ipairs(instance:GetChildren()) do
		self:_watch(child)
	end
end

if useDevSource then
	if devSource ~= nil then
		source = devSource
		currentRoot = source
	else
		warn(
			'MazeGenerator development source is not present, running using built-in source. Waiting for ' .. PluginFolderName .. ' into ServerStorage.'
		)
		local connection
		connection = ServerStorage.ChildAdded:Connect(function(child)
			print('ServerStorage changed', child.Name)
			if child.Name == PluginFolderName then
				print('Got ' .. PluginFolderName .. 'Reloading plugin.', child.Name)
				connection:Disconnect()
				source = ServerStorage:WaitForChild(PluginFolderName)
				currentRoot = source
				PluginFacade:_load()
				PluginFacade:_watch(source)
			end
		end)
	end
end

PluginFacade:_load()
PluginFacade:_watch(source)</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="261">
          <Properties>
            <string name="Name">Main</string>
            <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')
local Roact = require(Root:WaitForChild('Roact'))
local Plugin = Root.Plugin
local Rodux = require(Root.Rodux)
local RoactRodux = require(Root.RoactRodux)
local Log = require(Root.Log)

local DevSettings = require(Plugin.DevSettings)

local App = require(Plugin.Components.App)
local Reducer = require(Plugin.Reducer)
local Theme = require(Plugin.Components.Theme)
local Assets = require(Plugin.Assets)

local Version = require(Plugin.Version)
local Config = require(Plugin.Config)
local PluginSettings = require(Plugin.Components.PluginSettings)

local e = Roact.createElement
local function Main(pluginFacade, savedState)
	local WIDGET_ID = 'MazeGenerator'
	local PLUGIN_TITLE = 'Maze Generator'
	local PLUGIN_DESC = 'Show or hide the Maze Generator panel'

	-- PLUGIN CONFIGURATION
	local displayedVersion = Version.display(Config.version)
	local toolbar = pluginFacade:toolbar('Maze Generator ' .. displayedVersion)

	if Config.isDevBuild then
		WIDGET_ID = WIDGET_ID .. '_Local'
		PLUGIN_TITLE = PLUGIN_TITLE .. ' (LOCAL)'
	end

	local widgetInfo = DockWidgetPluginGuiInfo.new(
		-- Minimum size
		Enum.InitialDockState.Right,
		false, -- Initially enabled state
		false, -- Whether to override the widget's previous state
		360,
		190, -- Floating size
		360,
		190
	)

	local widgetName = WIDGET_ID .. '-' .. displayedVersion
	local dockWidget = pluginFacade:createDockWidgetPluginGui(widgetName, widgetInfo)
	dockWidget.Name = PLUGIN_TITLE .. ' ' .. displayedVersion
	dockWidget.Title = PLUGIN_TITLE .. '' .. displayedVersion
	dockWidget.AutoLocalize = false
	dockWidget.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	local toggleButton = pluginFacade:button(toolbar, PLUGIN_TITLE, PLUGIN_DESC, Assets.Images.Icon)
	toggleButton.ClickableWhenViewportHidden = true
	toggleButton.Click:Connect(function()
		dockWidget.Enabled = not dockWidget.Enabled
	end)

	local dockWidgetEnabled = dockWidget:GetPropertyChangedSignal('Enabled'):Connect(function()
		toggleButton:SetActive(dockWidget.Enabled)
	end)

	local unloadConnection
	unloadConnection = dockWidget.AncestryChanged:Connect(function()
		print('New MazeGenerator version coming online; unloading the old version')
		unloadConnection:Disconnect()
		pluginFacade:unload()
	end)

	Log.setLogLevelThunk(function()
		return DevSettings:getLogLevel()
	end)
	--- APP UI
	local store = Rodux.Store.new(Reducer, savedState)
	local app =
		e(Theme.StudioProvider, nil, {
			e(
				PluginSettings.StudioProvider,
				{ plugin = pluginFacade },
				{ RootUI = e(App, { root = dockWidget }) }
			),
		})
	local element = Roact.createElement(RoactRodux.StoreProvider, { store = store }, { app = app })

	local instance = Roact.mount(element, dockWidget, 'APP-UI')

	pluginFacade:beforeUnload(function()
		Roact.unmount(instance)
		dockWidgetEnabled:Disconnect()
		return store:getState()
	end)
end

return Main</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="262">
          <Properties>
            <string name="Name">Maze</string>
          </Properties>
          <Item class="ModuleScript" referent="263">
            <Properties>
              <string name="Name">Maze</string>
              <string name="Source">local setmetatable = setmetatable
local ipairs = ipairs
local pairs = pairs

local Maze = {
	directions = {
		north = {
			x = 0,
			y = -1,
		},
		east = {
			x = 1,
			y = 0,
		},
		south = {
			x = 0,
			y = 1,
		},
		west = {
			x = -1,
			y = 0,
		},
	},
}

function Maze:new(width, height, closed, obj)
	obj = obj or {}
	setmetatable(obj, self)
	self.__index = self

	-- Actual maze setup
	for y = 1, height do
		obj[y] = {}
		for x = 1, width do
			obj[y][x] = {
				east = obj:CreateDoor(closed),
				south = obj:CreateDoor(closed),
			}

			-- Doors are shared beetween the cells to avoid out of sync conditions and data dublication
			if x ~= 1 then
				obj[y][x].west = obj[y][x - 1].east
			else
				obj[y][x].west = obj:CreateDoor(closed)
			end

			if y ~= 1 then
				obj[y][x].north = obj[y - 1][x].south
			else
				obj[y][x].north = self:CreateDoor(closed)
			end
		end
	end

	return obj
end

function Maze:width()
	return #self[1]
end

function Maze:height()
	return #self
end

function Maze:DirectionsFrom(x, y, validator)
	local directions = {}
	validator = validator or function()
		return true
	end

	for name, shift in pairs(self.directions) do
		local x, y = x + shift.x, y + shift.y

		if self[y] and self[y][x] and validator(self[y][x], x, y) then
			directions[#directions + 1] = {
				name = name,
				x = x,
				y = y,
			}
		end
	end

	return directions
end

function Maze:ResetDoors(close, borders)
	for y = 1, #self do
		for i, cell in ipairs(self[y]) do
			cell.north:SetClosed(close or y == 1 and not borders)
			cell.west:SetClosed(close)
		end

		self[y][1].west:SetClosed(close or not borders)
		self[y][#self[1]].east:SetClosed(close or not borders)
	end

	for i, cell in ipairs(self[#self]) do
		cell.south:SetClosed(close or not borders)
	end
end

function Maze:ResetVisited()
	for y = 1, #self do
		for x = 1, #self[1] do
			self[y][x].visited = nil
		end
	end
end

function Maze.tostring(maze, wall, passage)
	wall = wall or '#'
	passage = passage or ' '

	local result = ''

	local verticalBorder = ''
	for i = 1, #maze[1] do
		verticalBorder = verticalBorder .. wall .. (maze[1][i].north:IsClosed() and wall or passage)
	end
	verticalBorder = verticalBorder .. wall
	result = result .. verticalBorder .. '\n'

	for y, row in ipairs(maze) do
		local line = row[1].west:IsClosed() and wall or passage
		local underline = wall
		for x, cell in ipairs(row) do
			line = line .. ' ' .. (cell.east:IsClosed() and wall or passage)
			underline = underline .. (cell.south:IsClosed() and wall or passage) .. wall
		end
		result = result .. line .. '\n' .. underline .. '\n'
	end

	return result
end

Maze.__tostring = Maze.tostring

function Maze:CreateDoor(closed)
	local door = {}
	door.closed = closed and true or false

	function door:IsClosed()
		return self.closed
	end

	function door:IsOpened()
		return not self.closed
	end

	function door:Close()
		self.closed = true
	end

	function door:Open()
		self.closed = false
	end

	function door:SetOpened(opened)
		if opened then
			self:Open()
		else
			self:Close()
		end
	end

	function door:SetClosed(closed)
		self:SetOpened(not closed)
	end

	return door
end

return Maze</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="264">
            <Properties>
              <string name="Name">MazeBacktrace</string>
              <string name="Source">-- Recursive Backtracker algorithm
-- Detailed description: http://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking
local random = math.random

local function backtrack(maze, x, y)
	maze[y][x].visited = true

	-- while there are possible travel directions from this cell
	local directions = maze:DirectionsFrom(x, y, function(cell)
		return not cell.visited
	end)
	while #directions ~= 0 do
		-- choose random direction
		local rand_i = random(#directions)
		local dirn = directions[rand_i]

		directions[rand_i] = directions[#directions]
		directions[#directions] = nil

		-- if this direction leads to an unvisited cell:
		-- carve and recurse into this new cell
		if not maze[dirn.y][dirn.x].visited then
			maze[y][x][dirn.name]:Open()
			backtrack(maze, dirn.x, dirn.y)
		end
	end
end

local function recursive_backtracker(maze, x, y)
	maze:ResetDoors(true)
	x, y = random(maze:width()), random(maze:height())

	-- start recursive maze carving
	backtrack(maze, x, y)

	maze:ResetVisited()
end

return recursive_backtracker</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="265">
            <Properties>
              <string name="Name">MazeGenerator</string>
              <string name="Source">local Root = script:FindFirstAncestor('MazeGeneratorPlugin')

local M = require(Root:WaitForChild('M'))

local Models = Root:WaitForChild('Models')

local recursive_backtracker = require(script.Parent.MazeBacktrace)
local Maze = require(script.Parent.Maze)

local Prefabs = Models.Prefabs
local Misc = Models.Misc
local Money = Models.Money

local blockHeight = 20
local blockWidth = 25
local blockDepth = 0

local floorPartName = 'FloorPart'

function partToRegion3(obj)
	local abs = math.abs

	local cf = obj.CFrame -- this causes a LuaBridge invocation + heap alfolder to create CFrame object - expensive! - but no way around it. we need the cframe
	local size = obj.Size -- this causes a LuaBridge invocation + heap alfolder to create Vector3 object - expensive! - but no way around it
	local sx, sy, sz = size.X, size.Y, size.Z -- this causes 3 Lua->C++ invocations
	local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cf:components() -- this causes 1 Lua->C++ invocations and gets all components of cframe in one go, with no alfolders
	-- https://zeuxcg.org/2010/10/17/aabb-from-obb-with-component-wise-abs/
	local wsx = 0.5 * (abs(R00) * sx + abs(R01) * sy + abs(R02) * sz) -- this requires 3 Lua->C++ invocations to call abs, but no hash lookups since we cached abs value above; otherwise this is just a bunch of local ops
	local wsy = 0.5 * (abs(R10) * sx + abs(R11) * sy + abs(R12) * sz) -- same
	local wsz = 0.5 * (abs(R20) * sx + abs(R21) * sy + abs(R22) * sz) -- same
	-- just a bunch of local ops
	local minx = x - wsx
	local miny = y - wsy
	local minz = z - wsz

	local maxx = x + wsx
	local maxy = y + wsy
	local maxz = z + wsz

	local minv, maxv = Vector3.new(minx, miny, minz), Vector3.new(maxx, maxy, maxz)
	return Region3.new(minv, maxv)
end

function dummyPart(position, folder)
	local newBlock = Instance.new('Part')

	newBlock.Anchored = true
	newBlock.Size = Vector3.new(0.5, blockHeight, 0.5)
	newBlock.Position = position
	newBlock.Parent = folder
end

local areaHalfWidth = (blockWidth - 5) / 2
local neg = M.range(5, areaHalfWidth)
local pos = M.range(-5, -areaHalfWidth)
local arr = M.append(neg, pos)

function randomPos()
	-- we are taking out center values

	local p = M.sample(arr)

	return p[1]
end

function randomRotation(position)
	return CFrame.new(position) * CFrame.fromOrientation(0, math.random(1, 360), 0)
end

function AddRandomPart(x, y, z, folder)
	local parts = Misc:GetChildren()
	local randomPart = parts[math.random(1, #parts)]
	local newBlock = randomPart:Clone()

	local randomPosition = Vector3.new(randomPos(), 0, randomPos())

	local partSize
	if newBlock:IsA('BasePart') then
		partSize = newBlock.Size
	else
		partSize = newBlock.PrimaryPart.Size
	end

	local halfX = blockWidth / 2 - partSize.X / 2
	local halfY = partSize.Y / 2
	local halfZ = blockWidth / 2 - partSize.Z / 2

	local position = randomRotation(Vector3.new(x + halfX, y + halfY, z + halfZ) + randomPosition)

	if newBlock:IsA('BasePart') then
		newBlock.CFrame = position
	else
		newBlock:SetPrimaryPartCFrame(position)
	end

	newBlock.Parent = folder
end

function AddCoinPart(x, y, z, folder)
	local parts = Money:GetChildren()
	local randomPart = parts[math.random(1, #parts)]
	local newBlock = randomPart:Clone()

	local partSize
	if newBlock:IsA('BasePart') then
		partSize = newBlock.Size
	else
		partSize = newBlock.PrimaryPart.Size
	end

	local halfX = blockWidth / 2 - partSize.X / 2
	local halfY = partSize.Y / 2
	local halfZ = blockWidth / 2 - partSize.Z / 2

	local position = randomRotation(Vector3.new(x + halfX, y + halfY, z + halfZ))

	if newBlock:IsA('BasePart') then
		newBlock.CFrame = position
	else
		newBlock:SetPrimaryPartCFrame(position)
	end

	newBlock.Parent = folder
end

function AddRandomParts(x, y, z, folder)
	local times = M.range(1, 5)

	local fromGround = 2.5
	AddCoinPart(x, y + fromGround, z, folder)
	M.map(times, function()
		local willAdd = math.random(1, 10)
		if willAdd == 1 then
			AddRandomPart(x, y + fromGround, z, folder)
		end
	end)
end

function DrawBlock(x, y, z, folder, vertical, settings)
	local newBlock = Instance.new('Part')

	newBlock.Anchored = true
	newBlock.Size = Vector3.new(1, blockHeight, blockWidth)

	local halfHeight = newBlock.Size.Y / 2
	local halfWidth = newBlock.Size.Z / 2

	local position = CFrame.new(x, y + halfHeight, z + halfWidth)

	if vertical then
		local angle = math.rad(90)
		position = CFrame.new(x + halfWidth, y + halfHeight, z) * CFrame.Angles(0, angle, 0)
	end

	newBlock.CFrame = position

	local region = partToRegion3(newBlock)
	region = region:ExpandToGrid(4)

	if settings.onlyBlocks then
		warn('Generating with wall material ', settings.wallMaterial)
		game.Workspace.Terrain:FillRegion(region, 4, settings.wallMaterial)
	else
		newBlock.Parent = folder
	end

	if settings.addKillBlocks then
		-- make top walls not walkable, by killing
		local killBlockName = 'Killbrick'
		local killBlock = Prefabs[killBlockName]:Clone()
		killBlock.Size = Vector3.new(3, 4, blockWidth)
		killBlock.CFrame = newBlock.CFrame + Vector3.new(0, blockHeight - 7, 0)
		killBlock.Transparency = 1
		killBlock.Parent = folder
	end
end

function DrawFloor(x, y, z, folder, width, height, settings)
	local floor = Instance.new('Part')
	floor.Parent = folder
	floor.Size = Vector3.new(width, 1, height)

	floor.Name = floorPartName
	floor.CanCollide = false
	floor.Transparency = 1
	floor.Anchored = true
	floor.CFrame = CFrame.new(x + width / 2, y, z + height / 2)

	if settings.onlyBlocks then
		workspace.Terrain:FillBlock(floor.CFrame, floor.Size, settings.groundMaterial)
	else
		floor.Parent = folder
	end
end

function DrawCeiling(x, y, z, folder, width, height, settings)
	local floor = Instance.new('Part')
	floor.Parent = folder
	floor.Size = Vector3.new(width, 1, height)

	floor.Name = floorPartName
	floor.CanCollide = false
	floor.Transparency = 1
	floor.Anchored = true
	floor.CFrame = CFrame.new(x + width / 2, y, z + height / 2)

	if settings.onlyBlocks then
		workspace.Terrain:FillBlock(floor.CFrame, floor.Size, settings.wallMaterial)
	else
		floor.Parent = folder
	end
end

function DrawStart(x, y, z, folder, width, depth)
	local block = 'SpawnPlaceholder'
	local newBlock = Prefabs[block]:Clone()

	local position = Vector3.new(x + width / 2, y, z + depth / 2)
	newBlock.Position = position
	newBlock.Parent = folder
end

function DrawFinish(x, y, z, folder, width, depth)
	local block = 'FinishPlaceholder'
	local newBlock = Prefabs[block]:Clone()

	local position = Vector3.new(x + width / 2, y, z + depth / 2)
	newBlock.Position = position
	newBlock.Parent = folder
end

local function draw_maze(maze, blockWidth, blockDepth, folder, position, settings)
	local maze_width = (blockWidth + blockDepth) * #maze[1] + blockDepth
	local maze_height = (blockWidth + blockDepth) * #maze + blockDepth

	local x = position.X
	local y = position.Y
	local z = position.Z

	warn('Positioning Maze: ' .. x .. ' ' .. y)
	-- part can have max size 2048
	warn('Size in studs:' .. tostring(maze_width) .. ', height:' .. tostring(maze_height))

	DrawFloor(x, y, z, folder, maze_width, maze_height, settings)

	if settings.addCeiling then
		DrawCeiling(x, y + blockHeight, z, folder, maze_width, maze_height, settings)
	end

	if settings.addStartAndFinish then
		DrawStart(x + 2, y + 6, z + 2, folder, blockWidth, blockWidth)

		local finisWidth = blockWidth - 2

		DrawFinish(
			x + maze_width - finisWidth,
			y,
			z + maze_height - finisWidth,
			folder,
			finisWidth,
			finisWidth
		)
	end

	for zi = 1, #maze do
		for xi = 1, #maze[1] do
			local pos_x = x + (blockWidth + blockDepth) * (xi - 1) + blockDepth
			local pos_z = z + (blockWidth + blockDepth) * (zi - 1) + blockDepth

			local cell = maze[zi][xi]

			if not cell.north:IsOpened() then
				DrawBlock(pos_x, y, pos_z - blockDepth, folder, true, settings)
			end

			if not cell.east:IsOpened() then
				DrawBlock(pos_x + blockWidth, y, pos_z, folder, false, settings)
			end

			if not cell.south:IsOpened() then
				DrawBlock(pos_x, y, pos_z + blockWidth, folder, true, settings)
			end

			if not cell.west:IsOpened() then
				DrawBlock(pos_x - blockDepth, y, pos_z, folder, false, settings)
			end

			if settings.addRandomModels then
				AddRandomParts(pos_x, y, pos_z, folder)
			end
		end
	end
end

local MazeGenerator = {}

local mazeFolderName = 'Maze'

function MazeGenerator:generate(settings)
	local width = settings.width
	local height = settings.height
	local location = settings.location
	warn('Generating maze  width:' .. width .. ', height:' .. height)

	local maze = Maze:new(width, height, true)

	recursive_backtracker(maze)

	local mazeFolder = location:FindFirstChild(mazeFolderName)

	if mazeFolder then
		local floor = mazeFolder:FindFirstChild(floorPartName)
		workspace.Terrain:FillBlock(
			floor.CFrame,
			floor.Size + Vector3.new(10, blockHeight * 3, 10),
			Enum.Material.Air
		)
		mazeFolder:Destroy()
	end

	mazeFolder = Instance.new('Folder')
	mazeFolder.Name = mazeFolderName
	mazeFolder.Parent = location

	local position = Vector3.new(0, 0, 0)
	if location:IsA('BasePart') then
		position = location.Position
		warn('Using part location')
	end

	draw_maze(maze, blockWidth, blockDepth, mazeFolder, position, settings)
end

return MazeGenerator</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="266">
          <Properties>
            <string name="Name">Reducer</string>
            <string name="Source">local settings = require(script.settings)

return function(state, action)
	state = state or {}
	return { settings = settings(state.settings, action) }
end</string>
          </Properties>
          <Item class="ModuleScript" referent="267">
            <Properties>
              <string name="Name">settings</string>
              <string name="Source">return function(state, action)
	state = state or {
		height = Config.defaultWidth,
		width = Config.defaultWidth,
		wallMaterial = Enum.Material.Grass,
		groundMaterial = Enum.Material.Sand,
		onlyBlocks = false,
		addRandomModels = true,
		addStartAndFinish = true,
		addKillBlocks = true,
		addCeiling = false,
		location = workspace,
	}

	if action.type == 'OpenDropdown' then
		return action.open
	end

	return state
end</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="268">
          <Properties>
            <string name="Name">Types</string>
            <string name="Source">local t = require(script.Parent.Parent.t)

local DevSettings = require(script.Parent.DevSettings)
local strict = require(script.Parent.strict)

local RbxId = t.string

local ApiValue = t.interface({
	Type = t.string,
	Value = t.optional(t.any),
})

local ApiInstanceMetadata = t.interface({
	ignoreUnknownInstances = t.optional(t.boolean),
})

local ApiInstance = t.interface({
	Id = RbxId,
	Parent = t.optional(RbxId),
	Name = t.string,
	ClassName = t.string,
	Properties = t.map(t.string, ApiValue),
	Metadata = t.optional(ApiInstanceMetadata),
	Children = t.array(RbxId),
})

local ApiInstanceUpdate = t.interface({
	id = RbxId,
	changedName = t.optional(t.string),
	changedClassName = t.optional(t.string),
	changedProperties = t.map(t.string, ApiValue),
	changedMetadata = t.optional(ApiInstanceMetadata),
})

local ApiSubscribeMessage = t.interface({
	removed = t.array(RbxId),
	added = t.map(RbxId, ApiInstance),
	updated = t.array(ApiInstanceUpdate),
})

local ApiInfoResponse = t.interface({
	sessionId = t.string,
	serverVersion = t.string,
	protocolVersion = t.number,
	expectedPlaceIds = t.optional(t.array(t.number)),
	rootInstanceId = RbxId,
})

local ApiReadResponse = t.interface({
	sessionId = t.string,
	messageCursor = t.number,
	instances = t.map(RbxId, ApiInstance),
})

local ApiSubscribeResponse = t.interface({
	sessionId = t.string,
	messageCursor = t.number,
	messages = t.array(ApiSubscribeMessage),
})

local ApiError = t.interface({
	kind = t.union(
		t.literal("NotFound"),
		t.literal("BadRequest"),
		t.literal("InternalError")
	),
	details = t.string,
})

local function ifEnabled(innerCheck)
	return function(...)
		if DevSettings:shouldTypecheck() then
			return innerCheck(...)
		else
			return true
		end
	end
end

return strict("Types", {
	ifEnabled = ifEnabled,

	ApiInfoResponse = ApiInfoResponse,
	ApiReadResponse = ApiReadResponse,
	ApiSubscribeResponse = ApiSubscribeResponse,
	ApiError = ApiError,

	ApiInstance = ApiInstance,
	ApiInstanceUpdate = ApiInstanceUpdate,
	ApiInstanceMetadata = ApiInstanceMetadata,
	ApiSubscribeMessage = ApiSubscribeMessage,
	ApiValue = ApiValue,
	RbxId = RbxId,

	-- Deprecated aliases during transition
	VirtualInstance = ApiInstance,
	VirtualMetadata = ApiInstanceMetadata,
	VirtualValue = ApiValue,
})</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="269">
          <Properties>
            <string name="Name">Version</string>
            <string name="Source">local function compare(a, b)
	if a > b then
		return 1
	elseif a &lt; b then
		return -1
	end

	return 0
end

local Version = {}

--[[
	Compares two versions of the form {major, minor, revision}.

	If a is newer than b, 1.
	If a is older than b, -1.
	If a and b are the same, 0.
]]
function Version.compare(a, b)
	local major = compare(a[1], b[1])
	local minor = compare(a[2] or 0, b[2] or 0)
	local revision = compare(a[3] or 0, b[3] or 0)

	if major ~= 0 then
		return major
	end

	if minor ~= 0 then
		return minor
	end

	return revision
end

function Version.display(version)
	local output = ("%d.%d.%d"):format(version[1], version[2], version[3])

	if version[4] ~= nil then
		output = output .. version[4]
	end

	return output
end

return Version</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="270">
          <Properties>
            <string name="Name">createSignal</string>
            <string name="Source">--[[
	Create a new signal that can be connected to, disconnected from, and fired.

	Usage:

		local signal = createSignal()
		local disconnect = signal:connect(function(...)
			print("fired:", ...)
		end)

		signal:fire("a", "b", "c")
		disconnect()

	Avoids mutating listeners list directly to prevent iterator invalidation if
	a listener is disconnected while the signal is firing.
]]
local function createSignal()
	local listeners = {}

	local function connect(newListener)
		local nextListeners = {}
		for listener in pairs(listeners) do
			nextListeners[listener] = true
		end

		nextListeners[newListener] = true
		listeners = nextListeners

		return function()
			local nextListeners = {}
			for listener in pairs(listeners) do
				if listener ~= newListener then
					nextListeners[listener] = true
				end
			end

			listeners = nextListeners
		end
	end

	local function fire(...)
		for listener in pairs(listeners) do
			listener(...)
		end
	end

	return {
		connect = connect,
		fire = fire,
	}
end

return createSignal</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="271">
          <Properties>
            <string name="Name">preloadAssets</string>
            <string name="Source">local ContentProvider = game:GetService("ContentProvider")

local Log = require(script.Parent.Parent.Log)

local Assets = require(script.Parent.Assets)

local function preloadAssets()
	local contentUrls = {}

	for _, sprite in pairs(Assets.Sprites) do
		table.insert(contentUrls, sprite.asset)
	end

	for _, slice in pairs(Assets.Slices) do
		table.insert(contentUrls, slice.asset)
	end

	for _, url in pairs(Assets.Images) do
		table.insert(contentUrls, url)
	end

	Log.trace("Preloading assets: {:?}", contentUrls)

	coroutine.wrap(function()
		ContentProvider:PreloadAsync(contentUrls)
	end)()
end

return preloadAssets</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="272">
          <Properties>
            <string name="Name">strict</string>
            <string name="Source">local function strictInner(name, target)
	assert(type(name) == "string", "Argument #1 to `strict` must be a string or the table to modify")
	assert(type(target) == "table", "Argument #2 to `strict` must be nil or the table to modify")

	setmetatable(target, {
		__index = function(_, key)
			error(("%q is not a valid member of strict table %q"):format(tostring(key), name), 2)
		end,

		__newindex = function()
			error(("Strict table %q is read-only"):format(name), 2)
		end,
	})

	return target
end

return function(nameOrTarget, target)
	if type(nameOrTarget) == "string" then
		return strictInner(nameOrTarget, target)
	else
		return strictInner("&lt;unnamed table>", target)
	end
end</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="273">
        <Properties>
          <string name="Name">Promise</string>
          <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_YIELD_NEW = "Yielding inside Promise.new is not allowed! Use Promise.async or create a new thread in the Promise executor!"
local ERROR_YIELD_THEN = "Yielding inside andThen/catch is not allowed! Instead, return a new Promise from andThen/catch."
local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"

local MODE_KEY_METATABLE = {
	__mode = "k";
}

local RunService = game:GetService("RunService")

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

--[[
	Calls a non-yielding function in a new coroutine.

	Handles errors if they happen.
]]
local function runExecutor(yieldError, traceback, callback, ...)
	-- Wrapped because C functions can't be passed to coroutine.create!
	local co = coroutine.create(function(...)
		return callback(...)
	end)

	local ok, len, result = packResult(coroutine.resume(co, ...))

	if ok and coroutine.status(co) ~= "dead" then
		error(yieldError .. "\n" .. traceback, 2)
	end

	return ok, len, result
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(ERROR_YIELD_THEN, traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1] .. "\n" .. traceback)
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local Promise = {}
Promise.prototype = {}
Promise.__index = Promise.prototype

Promise.Status = setmetatable({
	Started = "Started",
	Resolved = "Resolved",
	Rejected = "Rejected",
	Cancelled = "Cancelled",
}, {
	__index = function(_, k)
		error(("%s is not in Promise.Status!"):format(k), 2)
	end
})

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise.new(callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = debug.traceback(),

		_status = Promise.Status.Started,

		-- Will be set to the Lua error string if it occurs while executing.
		_error = nil,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation.
		_parent = parent,

		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	local ok, _, result = runExecutor(
		ERROR_YIELD_NEW,
		self._source,
		callback,
		resolve,
		reject,
		onCancel
	)

	if not ok then
		self._error = result[1] or "error"
		reject((result[1] or "error") .. "\n" .. self._source)
	end

	return self
end

function Promise._newWithSelf(executor, ...)
	local args
	local promise = Promise.new(function(...)
		args = { ... }
	end, ...)

	-- we don't handle the length here since `args` will always be { resolve, reject, onCancelHook }
	executor(promise, unpack(args))

	return promise
end

function Promise._new(traceback, executor, ...)
	return Promise._newWithSelf(function(self, ...)
		self._source = traceback
		executor(...)
	end, ...)
end

--[[
	Promise.new, except pcall on a new thread is automatic.
]]
function Promise.async(callback)
	local traceback = debug.traceback()
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = RunService.Heartbeat:Connect(function()
			connection:Disconnect()
			local ok, err = pcall(callback, resolve, reject, onCancel)

			if not ok then
				promise._error = err or "error"
				reject(err .. "\n" .. traceback)
			end
		end)
	end)

	return promise
end

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Begins a Promise chain, turning synchronous errors into rejections.
]]
function Promise.try(...)
	return Promise.resolve():andThenCall(...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(ERROR_NON_LIST:format("Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error((ERROR_NON_PROMISE_IN_LIST):format("Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._newWithSelf(function(self, resolve, reject, onCancel)
		self._source = traceback

		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			table.insert(
				newPromises,
				promise:andThen(
					function(...)
						resolveOne(i, ...)
					end,
					function(...)
						rejectedCount = rejectedCount + 1

						if amount == nil or #promises - rejectedCount < amount then
							cancel()
							done = true

							reject(...)
						end
					end
				)
			)
		end

		if done then
			cancel()
		end
	end)
end

function Promise.all(promises)
	return Promise._all(debug.traceback(), promises)
end

function Promise.some(promises, amount)
	assert(type(amount) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(), promises, amount)
end

function Promise.any(promises)
	return Promise._all(debug.traceback(), promises, 1):andThen(function(values)
		return values[1]
	end)
end

function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(ERROR_NON_LIST:format("Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error((ERROR_NON_PROMISE_IN_LIST):format("Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			table.insert(
				newPromises,
				promise:finally(
					function(...)
						resolveOne(i, ...)
					end
				)
			)
		end
	end)
end

--[[
	Races a set of Promises and returns the first one that resolves,
	cancelling the others.
]]
function Promise.race(promises)
	assert(type(promises) == "table", ERROR_NON_LIST:format("Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), (ERROR_NON_PROMISE_IN_LIST):format("Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function (...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for _, promise in ipairs(promises) do
			table.insert(
				newPromises,
				promise:andThen(finalize(resolve), finalize(reject))
			)
		end

		if finished then
			cancel()
		end
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return type(object.andThen) == "function"
	elseif type(objectMetatable) == "table" and type(rawget(objectMetatable, "andThen")) == "function" then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[[
	Converts a yielding function into a Promise-returning one.
]]
function Promise.promisify(callback)
	return function(...)
		local traceback = debug.traceback()
		local length, values = pack(...)
		return Promise._new(traceback, function(resolve, reject)
			coroutine.wrap(function()
				local ok, resultLength, resultValues = packResult(pcall(callback, unpack(values, 1, length)))
				if ok then
					resolve(unpack(resultValues, 1, resultLength))
				else
					reject((resultValues[1] or "error") .. "\n" .. traceback)
				end
			end)()
		end)
	end
end

--[[
	Creates a Promise that resolves after given number of seconds.
]]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(), function(resolve, _, onCancel)
			local startTime = tick()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = RunService.Heartbeat:Connect(function()
					local currentTime = tick()

					while first.endTime <= currentTime do
						first.resolve(currentTime - first.startTime)
						first = first.next
						if first == nil then
							connection:Disconnect()
							connection = nil
							break
						end
						first.previous = nil
						currentTime = tick()
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[[
	Rejects the promise after `seconds` seconds.
]]
function Promise.prototype:timeout(seconds, timeoutValue)
	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(timeoutValue == nil and "Timed out" or timeoutValue)
		end),
		self
	})
end

function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(
				traceback,
				successHandler,
				resolve,
				reject
			)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(
				traceback,
				failureHandler,
				resolve,
				reject
			)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject("Promise is cancelled")
		end
	end, self)
end

function Promise.prototype:andThen(successHandler, failureHandler)
	assert(
		successHandler == nil or type(successHandler) == "function",
		ERROR_NON_FUNCTION:format("Promise:andThen")
	)
	assert(
		failureHandler == nil or type(failureHandler) == "function",
		ERROR_NON_FUNCTION:format("Promise:andThen")
	)

	return self:_andThen(debug.traceback(), successHandler, failureHandler)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	assert(
		failureCallback == nil or type(failureCallback) == "function",
		ERROR_NON_FUNCTION:format("Promise:catch")
	)
	return self:_andThen(debug.traceback(), nil, failureCallback)
end

--[[
	Like andThen, but the value passed into the handler is also the
	value returned from the handler.
]]
function Promise.prototype:tap(tapCallback)
	assert(type(tapCallback) == "function", ERROR_NON_FUNCTION:format("Promise:tap"))
	return self:_andThen(debug.traceback(), function(...)
		local callbackReturn = tapCallback(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[[
	Calls a callback on `andThen` with specific arguments.
]]
function Promise.prototype:andThenCall(callback, ...)
	assert(type(callback) == "function", ERROR_NON_FUNCTION:format("Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for an andThen handler that returns the given value.
]]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(
				traceback,
				finallyHandler,
				resolve,
				reject
			)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

function Promise.prototype:finally(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		ERROR_NON_FUNCTION:format("Promise:finally")
	)
	return self:_finally(debug.traceback(), finallyHandler)
end

--[[
	Calls a callback on `finally` with specific arguments.
]]
function Promise.prototype:finallyCall(callback, ...)
	assert(type(callback) == "function", ERROR_NON_FUNCTION:format("Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for a finally handler that returns the given value.
]]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Similar to finally, except rejections are propagated through it.
]]
function Promise.prototype:done(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		ERROR_NON_FUNCTION:format("Promise:finallyO")
	)
	return self:_finally(debug.traceback(), finallyHandler, true)
end

--[[
	Calls a callback on `done` with specific arguments.
]]
function Promise.prototype:doneCall(callback, ...)
	assert(type(callback) == "function", ERROR_NON_FUNCTION:format("Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[[
	Shorthand for a done handler that returns the given value.
]]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(), function()
		return unpack(values, 1, length)
	end, true)
end

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[[
	Calls awaitStatus internally, returns (isResolved, values...)
]]
function Promise.prototype:await(...)
	return awaitHelper(self:awaitStatus(...))
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "" or tostring((...)), 3)
	end

	return ...
end

--[[
	Calls await and only returns if the Promise resolves.
	Throws if the Promise rejects or gets cancelled.
]]
function Promise.prototype:expect(...)
	return expectHelper(self:awaitStatus(...))
end

Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = (
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s"
			):format(
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				-- The handler errored. Replace the inner stack trace with our outer stack trace.
				if chainedPromise._error then
					return self:_reject((chainedPromise._error or "") .. "\n" .. self._source)
				end
				self:_reject(...)
			end
		)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		callback(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			callback(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			RunService.Heartbeat:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message
			if self._error then
				message = ("Unhandled promise rejection:\n\n%s"):format(err)
			else
				message = ("Unhandled promise rejection:\n\n%s\n\n%s"):format(
					err,
					self._source
				)
			end
			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		callback(self._status)
	end

	if self._parent and self._error == nil then
		self._error = self._parent._error
	end

	-- Allow family to be buried
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

return Promise
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="274">
          <Properties>
            <string name="Name">init.spec</string>
            <string name="Source">return function()
	local Promise = require(script.Parent)
	Promise.TEST = true

	local function pack(...)
		local len = select("#", ...)

		return len, { ... }
	end

	describe("Promise.Status", function()
		it("should error if indexing nil value", function()
			expect(function()
				local _ = Promise.Status.wrong
			end).to.throw()
		end)
	end)

	describe("Promise.new", function()
		it("should instantiate with a callback", function()
			local promise = Promise.new(function() end)

			expect(promise).to.be.ok()
		end)

		it("should invoke the given callback with resolve and reject", function()
			local callCount = 0
			local resolveArg
			local rejectArg

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				resolveArg = resolve
				rejectArg = reject
			end)

			expect(promise).to.be.ok()

			expect(callCount).to.equal(1)
			expect(resolveArg).to.be.a("function")
			expect(rejectArg).to.be.a("function")
			expect(promise:getStatus()).to.equal(Promise.Status.Started)
		end)

		it("should resolve promises on resolve()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve)
				callCount = callCount + 1
				resolve()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should reject promises on reject()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				reject()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
		end)

		it("should reject on error in callback", function()
			local callCount = 0

			local promise = Promise.new(function()
				callCount = callCount + 1
				error("hahah")
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]:find("hahah")).to.be.ok()

			-- Loosely check for the pieces of the stack trace we expect
			expect(promise._values[1]:find("init.spec")).to.be.ok()
			expect(promise._values[1]:find("new")).to.be.ok()
		end)
	end)

	describe("Promise.resolve", function()
		it("should immediately resolve with a value", function()
			local promise = Promise.resolve(5, 6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
			expect(promise._values[2]).to.equal(6)
		end)

		it("should chain onto passed promises", function()
			local promise = Promise.resolve(Promise.new(function(_, reject)
				reject(7)
			end))

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(7)
		end)
	end)

	describe("Promise.reject", function()
		it("should immediately reject with a value", function()
			local promise = Promise.reject(6, 7)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)
			expect(promise._values[2]).to.equal(7)
		end)

		it("should pass a promise as-is as an error", function()
			local innerPromise = Promise.new(function(resolve)
				resolve(6)
			end)

			local promise = Promise.reject(innerPromise)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(innerPromise)
		end)
	end)

	describe("Promise:andThen", function()
		it("should chain onto resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.resolve(5)

			local chained = promise:andThen(
				function(...)
					argsLength, args = pack(...)
					callCount = callCount + 1
				end,
				function()
					badCallCount = badCallCount + 1
				end
			)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.reject(5)

			local chained = promise:andThen(
				function(...)
					badCallCount = badCallCount + 1
				end,
				function(...)
					argsLength, args = pack(...)
					callCount = callCount + 1
				end
			)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto asynchronously resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(resolve)
				startResolution = resolve
			end)

			local chained = promise:andThen(
				function(...)
					args = {...}
					argsLength = select("#", ...)
					callCount = callCount + 1
				end,
				function()
					badCallCount = badCallCount + 1
				end
			)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto asynchronously rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(_, reject)
				startResolution = reject
			end)

			local chained = promise:andThen(
				function()
					badCallCount = badCallCount + 1
				end,
				function(...)
					args = {...}
					argsLength = select("#", ...)
					callCount = callCount + 1
				end
			)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should propagate errors through multiple levels", function()
			local x, y, z
			Promise.new(function(resolve, reject)
				reject(1, 2, 3)
			end)
			:andThen(function() end)
			:catch(function(a, b, c)
				x, y, z = a, b, c
			end)

			expect(x).to.equal(1)
			expect(y).to.equal(2)
			expect(z).to.equal(3)
		end)
	end)

	describe("Promise:cancel", function()
		it("should mark promises as cancelled and not resolve or reject them", function()
			local callCount = 0
			local finallyCallCount = 0
			local promise = Promise.new(function() end):andThen(function()
				callCount = callCount + 1
			end):finally(function()
				finallyCallCount = finallyCallCount + 1
			end)

			promise:cancel()
			promise:cancel() -- Twice to check call counts

			expect(callCount).to.equal(0)
			expect(finallyCallCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should call the cancellation hook once", function()
			local callCount = 0

			local promise = Promise.new(function(resolve, reject, onCancel)
				onCancel(function()
					callCount = callCount + 1
				end)
			end)

			promise:cancel()
			promise:cancel() -- Twice to check call count

			expect(callCount).to.equal(1)
		end)

		it("should propagate cancellations", function()
			local promise = Promise.new(function() end)

			local consumer1 = promise:andThen()
			local consumer2 = promise:andThen()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Started)

			consumer1:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Started)

			consumer2:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should affect downstream promises", function()
			local promise = Promise.new(function() end)
			local consumer = promise:andThen()

			promise:cancel()

			expect(consumer:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should track consumers", function()
			local pending = Promise.new(function() end)
			local p0 = Promise.resolve()
			local p1 = p0:finally(function() return pending end)
			local p2 = Promise.new(function(resolve)
				resolve(p1)
			end)
			local p3 = p2:andThen(function() end)

			expect(p1._parent).to.never.equal(p0)
			expect(p2._parent).to.never.equal(p1)
			expect(p2._consumers[p3]).to.be.ok()
			expect(p3._parent).to.equal(p2)
		end)

		it("should cancel resolved pending promises", function()
			local p1 = Promise.new(function() end)

			local p2 = Promise.new(function(resolve)
				resolve(p1)
			end):finally(function() end)

			p2:cancel()

			expect(p1._status).to.equal(Promise.Status.Cancelled)
			expect(p2._status).to.equal(Promise.Status.Cancelled)
		end)
	end)

	describe("Promise:finally", function()
		it("should be called upon resolve, reject, or cancel", function()
			local callCount = 0

			local function finally()
				callCount = callCount + 1
			end

			-- Resolved promise
			Promise.new(function(resolve, reject)
				resolve()
			end):finally(finally)

			-- Chained promise
			Promise.resolve():andThen(function()

			end):finally(finally):finally(finally)

			-- Rejected promise
			Promise.reject():finally(finally)

			local cancelledPromise = Promise.new(function() end):finally(finally)
			cancelledPromise:cancel()

			expect(callCount).to.equal(5)
		end)

		it("should be a child of the parent Promise", function()
			local p1 = Promise.new(function() end)
			local p2 = p1:finally(function() end)

			expect(p2._parent).to.equal(p1)
			expect(p1._consumers[p2]).to.equal(true)
		end)

		it("should forward return values", function()
			local value

			Promise.resolve():finally(function()
				return 1
			end):andThen(function(v)
				value = v
			end)

			expect(value).to.equal(1)
		end)
	end)

	describe("Promise.all", function()
		it("should error if given something other than a table", function()
			expect(function()
				Promise.all(1)
			end).to.throw()
		end)

		it("should resolve instantly with an empty table if given no promises", function()
			local promise = Promise.all({})
			local success, value = promise:_unwrap()

			expect(success).to.equal(true)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(value).to.be.a("table")
			expect(next(value)).to.equal(nil)
		end)

		it("should error if given non-promise values", function()
			expect(function()
				Promise.all({{}, {}, {}})
			end).to.throw()
		end)

		it("should wait for all promises to be resolved and return their values", function()
			local resolveFunctions = {}

			local testValuesLength, testValues = pack(1, "A string", nil, false)

			local promises = {}

			for i = 1, testValuesLength do
				promises[i] = Promise.new(function(resolve)
					resolveFunctions[i] = {resolve, testValues[i]}
				end)
			end

			local combinedPromise = Promise.all(promises)

			for _, resolve in ipairs(resolveFunctions) do
				expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)
				resolve[1](resolve[2])
			end

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, resolved = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(2)
			expect(success).to.equal(true)
			expect(resolved).to.be.a("table")
			expect(#resolved).to.equal(#promises)

			for i = 1, testValuesLength do
				expect(resolved[i]).to.equal(testValues[i])
			end
		end)

		it("should reject if any individual promise rejected", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({a, b})

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("baz", "qux")
			resolveB("foo", "bar")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
			expect(b:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should not resolve if resolved after rejecting", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({a, b})

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("baz", "qux")
			resolveB("foo", "bar")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
		end)

		it("should only reject once", function()
			local rejectA
			local rejectB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(_, reject)
				rejectB = reject
			end)

			local combinedPromise = Promise.all({a, b})

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("foo", "bar")

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Rejected)

			rejectB("baz", "qux")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("foo")
			expect(second).to.equal("bar")
		end)

		it("should error if a non-array table is passed in", function()
			local ok, err = pcall(function()
				Promise.all(Promise.new(function() end))
			end)

			expect(ok).to.be.ok()
			expect(err:find("Non%-promise")).to.be.ok()
		end)

		it("should cancel pending promises if one rejects", function()
			local p = Promise.new(function() end)
			expect(Promise.all({
				Promise.resolve(),
				Promise.reject(),
				p
			}):getStatus()).to.equal(Promise.Status.Rejected)
			expect(p:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p
			}

			Promise.all(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)

	describe("Promise.race", function()
		it("should resolve with the first settled value", function()
			local promise = Promise.race({
				Promise.resolve(1),
				Promise.resolve(2)
			}):andThen(function(value)
				expect(value).to.equal(1)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should cancel other promises", function()
			local promise = Promise.new(function() end)
			promise:andThen(function() end)
			local promises = {
				promise,
				Promise.new(function() end),
				Promise.new(function(resolve)
					resolve(2)
				end)
			}

			local promise = Promise.race(promises)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(2)
			expect(promises[1]:getStatus()).to.equal(Promise.Status.Started)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Resolved)

			local p = Promise.new(function() end)
			expect(Promise.race({
				Promise.reject(),
				Promise.resolve(),
				p
			}):getStatus()).to.equal(Promise.Status.Rejected)
			expect(p:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should error if a non-array table is passed in", function()
			local ok, err = pcall(function()
				Promise.race(Promise.new(function() end))
			end)

			expect(ok).to.be.ok()
			expect(err:find("Non%-promise")).to.be.ok()
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p
			}

			Promise.race(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)

	describe("Promise.promisify", function()
		it("should wrap functions", function()
			local function test(n)
				return n + 1
			end

			local promisified = Promise.promisify(test)
			local promise = promisified(1)
			local success, result = promise:_unwrap()

			expect(success).to.equal(true)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(result).to.equal(2)
		end)

		it("should catch errors after a yield", function()
			local bindable = Instance.new("BindableEvent")
			local test = Promise.promisify(function ()
				bindable.Event:Wait()
				error('errortext')
			end)

			local promise = test()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]:find("errortext")).to.be.ok()
		end)
	end)

	describe("Promise.tap", function()
		it("should thread through values", function()
			local first, second

			Promise.resolve(1)
				:andThen(function(v)
					return v + 1
				end)
				:tap(function(v)
					first = v
					return v + 1
				end)
				:andThen(function(v)
					second = v
				end)

			expect(first).to.equal(2)
			expect(second).to.equal(2)
		end)

		it("should chain onto promises", function()
			local resolveInner, finalValue

			local promise = Promise.resolve(1)
				:tap(function()
					return Promise.new(function(resolve)
						resolveInner = resolve
					end)
				end)
				:andThen(function(v)
					finalValue = v
				end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(finalValue).to.never.be.ok()

			resolveInner(1)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(finalValue).to.equal(1)
		end)
	end)

	describe("Promise.try", function()
		it("should catch synchronous errors", function()
			local errorText
			Promise.try(function()
				error('errortext')
			end):catch(function(e)
				errorText = e
			end)

			expect(errorText:find("errortext")).to.be.ok()
		end)
	end)

	describe("Promise:andThenReturn", function()
		it("should return the given values", function()
			local value1, value2

			Promise.resolve():andThenReturn(1, 2):andThen(function(one, two)
				value1 = one
				value2 = two
			end)

			expect(value1).to.equal(1)
			expect(value2).to.equal(2)
		end)
	end)

	describe("Promise:doneReturn", function()
		it("should return the given values", function()
			local value1, value2

			Promise.resolve():doneReturn(1, 2):andThen(function(one, two)
				value1 = one
				value2 = two
			end)

			expect(value1).to.equal(1)
			expect(value2).to.equal(2)
		end)
	end)

	describe("Promise:andThenCall", function()
		it("should call the given function with arguments", function()
			local value1, value2
			Promise.resolve():andThenCall(function(a, b)
				value1 = a
				value2 = b
			end, 3, 4)

			expect(value1).to.equal(3)
			expect(value2).to.equal(4)
		end)
	end)

	describe("Promise:doneCall", function()
		it("should call the given function with arguments", function()
			local value1, value2
			Promise.resolve():doneCall(function(a, b)
				value1 = a
				value2 = b
			end, 3, 4)

			expect(value1).to.equal(3)
			expect(value2).to.equal(4)
		end)
	end)

	describe("Promise:done", function()
		it("should trigger on resolve or cancel", function()
			local promise = Promise.new(function() end)
			local value

			local p = promise:done(function()
				value = true
			end)

			expect(value).to.never.be.ok()
			promise:cancel()
			expect(p:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(value).to.equal(true)

			local never, always
			Promise.reject():done(function()
				never = true
			end):finally(function()
				always = true
			end)

			expect(never).to.never.be.ok()
			expect(always).to.be.ok()
		end)
	end)

	describe("Promise.some", function()
		it("should resolve once the goal is reached", function()
			local p = Promise.some({
				Promise.resolve(1),
				Promise.reject(),
				Promise.resolve(2)
			}, 2)
			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(p._values[1][1]).to.equal(1)
			expect(p._values[1][2]).to.equal(2)
		end)

		it("should error if the goal can't be reached", function()
			expect(Promise.some({
				Promise.resolve(),
				Promise.reject()
			}, 2):getStatus()).to.equal(Promise.Status.Rejected)

			local reject
			local p = Promise.some({
				Promise.resolve(),
				Promise.new(function(_, r) reject = r end)
			}, 2)

			expect(p:getStatus()).to.equal(Promise.Status.Started)
			reject("foo")
			expect(p:getStatus()).to.equal(Promise.Status.Rejected)
			expect(p._values[1]).to.equal("foo")
		end)

		it("should cancel pending Promises once the goal is reached", function()
			local resolve
			local pending1 = Promise.new(function() end)
			local pending2 = Promise.new(function(r) resolve = r end)

			local some = Promise.some({
				pending1,
				pending2,
				Promise.resolve()
			}, 2)

			expect(some:getStatus()).to.equal(Promise.Status.Started)
			expect(pending1:getStatus()).to.equal(Promise.Status.Started)
			expect(pending2:getStatus()).to.equal(Promise.Status.Started)

			resolve()

			expect(some:getStatus()).to.equal(Promise.Status.Resolved)
			expect(pending1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(pending2:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should error if passed a non-number", function()
			expect(function()
				Promise.some({}, "non-number")
			end).to.throw()
		end)

		it("should return an empty array if amount is 0", function()
			local p = Promise.some({
				Promise.resolve(2)
			}, 0)

			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#p._values[1]).to.equal(0)
		end)

		it("should not return extra values", function()
			local p = Promise.some({
				Promise.resolve(1),
				Promise.resolve(2),
				Promise.resolve(3),
				Promise.resolve(4),
			}, 2)

			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#p._values[1]).to.equal(2)
			expect(p._values[1][1]).to.equal(1)
			expect(p._values[1][2]).to.equal(2)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p
			}

			Promise.some(promises, 3):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)

		describe("Promise.any", function()
			it("should return the value directly", function()
				local p = Promise.any({
					Promise.reject(),
					Promise.reject(),
					Promise.resolve(1)
				})

				expect(p:getStatus()).to.equal(Promise.Status.Resolved)
				expect(p._values[1]).to.equal(1)
			end)

			it("should error if all are rejected", function()
				expect(Promise.any({
					Promise.reject(),
					Promise.reject(),
					Promise.reject(),
				}):getStatus()).to.equal(Promise.Status.Rejected)
			end)
		end)
	end)

	describe("Promise.allSettled", function()
		it("should resolve with an array of PromiseStatuses", function()
			local reject
			local p = Promise.allSettled({
				Promise.resolve(),
				Promise.reject(),
				Promise.resolve(),
				Promise.new(function(_, r) reject = r end)
			})

			expect(p:getStatus()).to.equal(Promise.Status.Started)
			reject()
			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(p._values[1][1]).to.equal(Promise.Status.Resolved)
			expect(p._values[1][2]).to.equal(Promise.Status.Rejected)
			expect(p._values[1][3]).to.equal(Promise.Status.Resolved)
			expect(p._values[1][4]).to.equal(Promise.Status.Rejected)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p
			}

			Promise.allSettled(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)
end</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="275">
        <Properties>
          <string name="Name">Roact</string>
          <string name="Source">--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local GlobalConfig = require(script.GlobalConfig)
local createReconciler = require(script.createReconciler)
local createReconcilerCompat = require(script.createReconcilerCompat)
local RobloxRenderer = require(script.RobloxRenderer)
local strict = require(script.strict)
local Binding = require(script.Binding)

local robloxReconciler = createReconciler(RobloxRenderer)
local reconcilerCompat = createReconcilerCompat(robloxReconciler)

local Roact = strict {
	Component = require(script.Component),
	createElement = require(script.createElement),
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),
	None = require(script.None),
	Portal = require(script.Portal),
	createRef = require(script.createRef),
	createBinding = Binding.create,
	joinBindings = Binding.join,
	createContext = require(script.createContext),

	Change = require(script.PropMarkers.Change),
	Children = require(script.PropMarkers.Children),
	Event = require(script.PropMarkers.Event),
	Ref = require(script.PropMarkers.Ref),

	mount = robloxReconciler.mountVirtualTree,
	unmount = robloxReconciler.unmountVirtualTree,
	update = robloxReconciler.updateVirtualTree,

	reify = reconcilerCompat.reify,
	teardown = reconcilerCompat.teardown,
	reconcile = reconcilerCompat.reconcile,

	setGlobalConfig = GlobalConfig.set,

	-- APIs that may change in the future without warning
	UNSTABLE = {
	},
}

return Roact</string>
        </Properties>
        <Item class="ModuleScript" referent="276">
          <Properties>
            <string name="Name">Binding</string>
            <string name="Source">local createSignal = require(script.Parent.createSignal)
local Symbol = require(script.Parent.Symbol)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local BindingImpl = Symbol.named("BindingImpl")

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype:getValue()
	return BindingInternalApi.getValue(self)
end

function bindingPrototype:map(predicate)
	return BindingInternalApi.map(self, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update(binding, newValue)
	return binding[BindingImpl].update(newValue)
end

function BindingInternalApi.subscribe(binding, callback)
	return binding[BindingImpl].subscribe(callback)
end

function BindingInternalApi.getValue(binding)
	return binding[BindingImpl].getValue()
end

function BindingInternalApi.create(initialValue)
	local impl = {
		value = initialValue,
		changeSignal = createSignal(),
	}

	function impl.subscribe(callback)
		return impl.changeSignal:subscribe(callback)
	end

	function impl.update(newValue)
		impl.value = newValue
		impl.changeSignal:fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta), impl.update
end

function BindingInternalApi.map(upstreamBinding, predicate)
	if config.typeChecks then
		assert(Type.of(upstreamBinding) == Type.Binding, "Expected arg #1 to be a binding")
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

function BindingInternalApi.join(upstreamBindings)
	if config.typeChecks then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in pairs(upstreamBindings) do
			if Type.of(value) ~= Type.Binding then
				local message = (
					"Expected arg #1 to contain only bindings, but key %q had a non-binding value"
				):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		local disconnects = {}

		for key, upstream in pairs(upstreamBindings) do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in pairs(disconnects) do
				disconnect()
			end

			disconnects = nil
		end
	end

	function impl.update(newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

return BindingInternalApi</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="277">
          <Properties>
            <string name="Name">Binding.spec</string>
            <string name="Source">return function()
	local createSpy = require(script.Parent.createSpy)
	local Type = require(script.Parent.Type)
	local GlobalConfig = require(script.Parent.GlobalConfig)

	local Binding = require(script.Parent.Binding)

	describe("Binding.create", function()
		it("should return a Binding object and an update function", function()
			local binding, update = Binding.create(1)

			expect(Type.of(binding)).to.equal(Type.Binding)
			expect(typeof(update)).to.equal("function")
		end)

		it("should support tostring on bindings", function()
			local binding, update = Binding.create(1)
			expect(tostring(binding)).to.equal("RoactBinding(1)")

			update("foo")
			expect(tostring(binding)).to.equal("RoactBinding(foo)")
		end)
	end)

	describe("Binding object", function()
		it("should provide a getter and setter", function()
			local binding, update = Binding.create(1)

			expect(binding:getValue()).to.equal(1)

			update(3)

			expect(binding:getValue()).to.equal(3)
		end)

		it("should let users subscribe and unsubscribe to its updates", function()
			local binding, update = Binding.create(1)

			local spy = createSpy()
			local disconnect = Binding.subscribe(binding, spy.value)

			expect(spy.callCount).to.equal(0)

			update(2)

			expect(spy.callCount).to.equal(1)
			spy:assertCalledWith(2)

			disconnect()
			update(3)

			expect(spy.callCount).to.equal(1)
		end)
	end)

	describe("Mapped bindings", function()
		it("should be composable", function()
			local word, updateWord = Binding.create("hi")

			local wordLength = word:map(string.len)
			local isEvenLength = wordLength:map(function(value)
				return value % 2 == 0
			end)

			expect(word:getValue()).to.equal("hi")
			expect(wordLength:getValue()).to.equal(2)
			expect(isEvenLength:getValue()).to.equal(true)

			updateWord("sup")

			expect(word:getValue()).to.equal("sup")
			expect(wordLength:getValue()).to.equal(3)
			expect(isEvenLength:getValue()).to.equal(false)
		end)

		it("should cascade updates when subscribed", function()
			-- base binding
			local word, updateWord = Binding.create("hi")

			local wordSpy = createSpy()
			local disconnectWord = Binding.subscribe(word, wordSpy.value)

			-- binding -> base binding
			local length = word:map(string.len)

			local lengthSpy = createSpy()
			local disconnectLength = Binding.subscribe(length, lengthSpy.value)

			-- binding -> binding -> base binding
			local isEvenLength = length:map(function(value)
				return value % 2 == 0
			end)

			local isEvenLengthSpy = createSpy()
			local disconnectIsEvenLength = Binding.subscribe(isEvenLength, isEvenLengthSpy.value)

			expect(wordSpy.callCount).to.equal(0)
			expect(lengthSpy.callCount).to.equal(0)
			expect(isEvenLengthSpy.callCount).to.equal(0)

			updateWord("nice")

			expect(wordSpy.callCount).to.equal(1)
			wordSpy:assertCalledWith("nice")

			expect(lengthSpy.callCount).to.equal(1)
			lengthSpy:assertCalledWith(4)

			expect(isEvenLengthSpy.callCount).to.equal(1)
			isEvenLengthSpy:assertCalledWith(true)

			disconnectWord()
			disconnectLength()
			disconnectIsEvenLength()

			updateWord("goodbye")

			expect(wordSpy.callCount).to.equal(1)
			expect(isEvenLengthSpy.callCount).to.equal(1)
			expect(lengthSpy.callCount).to.equal(1)
		end)

		it("should throw when updated directly", function()
			local source = Binding.create(1)
			local mapped = source:map(function(v)
				return v
			end)

			expect(function()
				Binding.update(mapped, 5)
			end).to.throw()
		end)
	end)

	describe("Binding.join", function()
		it("should have getValue", function()
			local binding1 = Binding.create(1)
			local binding2 = Binding.create(2)
			local binding3 = Binding.create(3)

			local joinedBinding = Binding.join({
				binding1,
				binding2,
				foo = binding3,
			})

			local bindingValue = joinedBinding:getValue()
			expect(bindingValue).to.be.a("table")
			expect(bindingValue[1]).to.equal(1)
			expect(bindingValue[2]).to.equal(2)
			expect(bindingValue.foo).to.equal(3)
		end)

		it("should update when any one of the subscribed bindings updates", function()
			local binding1, update1 = Binding.create(1)
			local binding2, update2 = Binding.create(2)
			local binding3, update3 = Binding.create(3)

			local joinedBinding = Binding.join({
				binding1,
				binding2,
				foo = binding3,
			})

			local spy = createSpy()
			Binding.subscribe(joinedBinding, spy.value)

			expect(spy.callCount).to.equal(0)

			update1(3)
			expect(spy.callCount).to.equal(1)

			local args = spy:captureValues("value")
			expect(args.value).to.be.a("table")
			expect(args.value[1]).to.equal(3)
			expect(args.value[2]).to.equal(2)
			expect(args.value["foo"]).to.equal(3)

			update2(4)
			expect(spy.callCount).to.equal(2)

			args = spy:captureValues("value")
			expect(args.value).to.be.a("table")
			expect(args.value[1]).to.equal(3)
			expect(args.value[2]).to.equal(4)
			expect(args.value["foo"]).to.equal(3)

			update3(8)
			expect(spy.callCount).to.equal(3)

			args = spy:captureValues("value")
			expect(args.value).to.be.a("table")
			expect(args.value[1]).to.equal(3)
			expect(args.value[2]).to.equal(4)
			expect(args.value["foo"]).to.equal(8)
		end)

		it("should disconnect from all upstream bindings", function()
			local binding1, update1 = Binding.create(1)
			local binding2, update2 = Binding.create(2)

			local joined = Binding.join({binding1, binding2})

			local spy = createSpy()
			local disconnect = Binding.subscribe(joined, spy.value)

			expect(spy.callCount).to.equal(0)

			update1(3)
			expect(spy.callCount).to.equal(1)

			update2(3)
			expect(spy.callCount).to.equal(2)

			disconnect()
			update1(4)
			expect(spy.callCount).to.equal(2)

			update2(2)
			expect(spy.callCount).to.equal(2)

			local value = joined:getValue()
			expect(value[1]).to.equal(4)
			expect(value[2]).to.equal(2)
		end)

		it("should be okay with calling disconnect multiple times", function()
			local joined = Binding.join({})

			local disconnect = Binding.subscribe(joined, function() end)

			disconnect()
			disconnect()
		end)

		it("should throw if updated directly", function()
			local joined = Binding.join({})

			expect(function()
				Binding.update(joined, 0)
			end)
		end)

		it("should throw when a non-table value is passed", function()
			GlobalConfig.scoped({
				typeChecks = true,
			}, function()
				expect(function()
					Binding.join("hi")
				end).to.throw()
			end)
		end)

		it("should throw when a non-binding value is passed via table", function()
			GlobalConfig.scoped({
				typeChecks = true,
			}, function()
				expect(function()
					local binding = Binding.create(123)

					Binding.join({
						binding,
						"abcde",
					})
				end).to.throw()
			end)
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="278">
          <Properties>
            <string name="Name">Component</string>
            <string name="Source">local assign = require(script.Parent.assign)
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)
local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)
local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

--[[
	Calling setState during certain lifecycle allowed methods has the potential
	to create an infinitely updating component. Rather than time out, we exit
	with an error if an unreasonable number of self-triggering updates occur
]]
local MAX_PENDING_UPDATES = 100

local InternalData = Symbol.named("InternalData")

local componentMissingRenderMessage = [[
The component %q is missing the `render` method.
`render` must be defined when creating a Roact component!]]

local tooManyUpdatesMessage = [[
The component %q has reached the setState update recursion limit.
When using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]

local componentClassMetatable = {}

function componentClassMetatable:__tostring()
	return self.__componentName
end

local Component = {}
setmetatable(Component, componentClassMetatable)

Component[Type] = Type.StatefulComponentClass
Component.__index = Component
Component.__componentName = "Component"

--[[
	A method called by consumers of Roact to create a new component class.
	Components can not be extended beyond this point, with the exception of
	PureComponent.
]]
function Component:extend(name)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentClass, "Invalid `self` argument to `extend`.")
		assert(typeof(name) == "string", "Component class name must be a string")
	end

	local class = {}

	for key, value in pairs(self) do
		-- Roact opts to make consumers use composition over inheritance, which
		-- lines up with React.
		-- https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class[Type] = Type.StatefulComponentClass
	class.__index = class
	class.__componentName = name

	setmetatable(class, componentClassMetatable)

	return class
end

function Component:__getDerivedState(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getDerivedState`")
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	if componentClass.getDerivedStateFromProps ~= nil then
		local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)

		if derivedState ~= nil then
			if config.typeChecks then
				assert(typeof(derivedState) == "table", "getDerivedStateFromProps must return a table!")
			end

			return derivedState
		end
	end

	return nil
end

function Component:setState(mapState)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentInstance, "Invalid `self` argument to `extend`.")
	end

	local internalData = self[InternalData]
	local lifecyclePhase = internalData.lifecyclePhase

	--[[
		When preparing to update, rendering, or unmounting, it is not safe
		to call `setState` as it will interfere with in-flight updates. It's
		also disallowed during unmounting
	]]
	if lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate or
		lifecyclePhase == ComponentLifecyclePhase.WillUpdate or
		lifecyclePhase == ComponentLifecyclePhase.Render or
		lifecyclePhase == ComponentLifecyclePhase.WillUnmount
	then
		local messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end

	local pendingState = internalData.pendingState

	local partialState
	if typeof(mapState) == "function" then
		partialState = mapState(pendingState or self.state, self.props)

		-- Abort the state update if the given state updater function returns nil
		if partialState == nil then
			return
		end
	elseif typeof(mapState) == "table" then
		partialState = mapState
	else
		error("Invalid argument to setState, expected function or table", 2)
	end

	local newState
	if pendingState ~= nil then
		newState = assign(pendingState, partialState)
	else
		newState = assign({}, self.state, partialState)
	end

	if lifecyclePhase == ComponentLifecyclePhase.Init then
		-- If `setState` is called in `init`, we can skip triggering an update!
		local derivedState = self:__getDerivedState(self.props, newState)
		self.state = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.DidMount or
		lifecyclePhase == ComponentLifecyclePhase.DidUpdate or
		lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren
	then
		--[[
			During certain phases of the component lifecycle, it's acceptable to
			allow `setState` but defer the update until we're done with ones in flight.
			We do this by collapsing it into any pending updates we have.
		]]
		local derivedState = self:__getDerivedState(self.props, newState)
		internalData.pendingState = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.Idle then
		-- Outside of our lifecycle, the state update is safe to make immediately
		self:__update(nil, newState)

	else
		local messageTemplate = invalidSetStateMessages.default

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end
end

--[[
	Returns the stack trace of where the element was created that this component
	instance's properties are based on.

	Intended to be used primarily by diagnostic tools.
]]
function Component:getElementTraceback()
	return self[InternalData].virtualNode.currentElement.source
end

--[[
	Returns a snapshot of this component given the current props and state. Must
	be overridden by consumers of Roact and should be a pure function with
	regards to props and state.

	TODO (#199): Accept props and state as arguments.
]]
function Component:render()
	local internalData = self[InternalData]

	local message = componentMissingRenderMessage:format(
		tostring(internalData.componentClass)
	)

	error(message, 0)
end

--[[
	Retrieves the context value corresponding to the given key. Can return nil
	if a requested context key is not present
]]
function Component:__getContext(key)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getContext`")
		internalAssert(key ~= nil, "Context key cannot be nil")
	end

	local virtualNode = self[InternalData].virtualNode
	local context = virtualNode.context

	return context[key]
end

--[[
	Adds a new context entry to this component's context table (which will be
	passed down to child components).
]]
function Component:__addContext(key, value)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__addContext`")
	end
	local virtualNode = self[InternalData].virtualNode

	-- Make sure we store a reference to the component's original, unmodified
	-- context the virtual node. In the reconciler, we'll restore the original
	-- context if we need to replace the node (this happens when a node gets
	-- re-rendered as a different component)
	if virtualNode.originalContext == nil then
		virtualNode.originalContext = virtualNode.context
	end

	-- Build a new context table on top of the existing one, then apply it to
	-- our virtualNode
	local existing = virtualNode.context
	virtualNode.context = assign({}, existing, { [key] = value })
end

--[[
	Performs property validation if the static method validateProps is declared.
	validateProps should follow assert's expected arguments:
	(false, message: string) | true. The function may return a message in the
	true case; it will be ignored. If this fails, the function will throw the
	error.
]]
function Component:__validateProps(props)
	if not config.propValidation then
		return
	end

	local validator = self[InternalData].componentClass.validateProps

	if validator == nil then
		return
	end

	if typeof(validator) ~= "function" then
		error(("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
			typeof(validator),
			self.__componentName
		))
	end

	local success, failureReason = validator(props)

	if not success then
		failureReason = failureReason or "&lt;Validator function did not supply a message>"
		error(("Property validation failed: %s\n\n%s"):format(
			tostring(failureReason),
			self:getElementTraceback() or "&lt;enable element tracebacks>"),
		0)
	end
end

--[[
	An internal method used by the reconciler to construct a new component
	instance and attach it to the given virtualNode.
]]
function Component:__mount(reconciler, virtualNode)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentClass, "Invalid use of `__mount`")
		internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #2 to be of type VirtualNode")
	end

	local currentElement = virtualNode.currentElement
	local hostParent = virtualNode.hostParent

	-- Contains all the information that we want to keep from consumers of
	-- Roact, or even other parts of the codebase like the reconciler.
	local internalData = {
		reconciler = reconciler,
		virtualNode = virtualNode,
		componentClass = self,
		lifecyclePhase = ComponentLifecyclePhase.Init,
	}

	local instance = {
		[Type] = Type.StatefulComponentInstance,
		[InternalData] = internalData,
	}

	setmetatable(instance, self)

	virtualNode.instance = instance

	local props = currentElement.props

	if self.defaultProps ~= nil then
		props = assign({}, self.defaultProps, props)
	end

	instance:__validateProps(props)

	instance.props = props

	local newContext = assign({}, virtualNode.legacyContext)
	instance._context = newContext

	instance.state = assign({}, instance:__getDerivedState(instance.props, {}))

	if instance.init ~= nil then
		instance:init(instance.props)
		assign(instance.state, instance:__getDerivedState(instance.props, instance.state))
	end

	-- It's possible for init() to redefine _context!
	virtualNode.legacyContext = instance._context

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render
	local renderResult = instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)

	if instance.didMount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount
		instance:didMount()
	end

	if internalData.pendingState ~= nil then
		-- __update will handle pendingState, so we don't pass any new element or state
		instance:__update(nil, nil)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
end

--[[
	Internal method used by the reconciler to clean up any resources held by
	this component instance.
]]
function Component:__unmount()
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__unmount`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	if self.willUnmount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount
		self:willUnmount()
	end

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end
end

--[[
	Internal method used by setState (to trigger updates based on state) and by
	the reconciler (to trigger updates based on props)

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__update(updatedElement, updatedState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__update`")
		internalAssert(
			Type.of(updatedElement) == Type.Element or updatedElement == nil,
			"Expected arg #1 to be of type Element or nil"
		)
		internalAssert(
			typeof(updatedState) == "table" or updatedState == nil,
			"Expected arg #2 to be of type table or nil"
		)
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	local newProps = self.props
	if updatedElement ~= nil then
		newProps = updatedElement.props

		if componentClass.defaultProps ~= nil then
			newProps = assign({}, componentClass.defaultProps, newProps)
		end

		self:__validateProps(newProps)
	end

	local updateCount = 0
	repeat
		local finalState
		local pendingState = nil

		-- Consume any pending state we might have
		if internalData.pendingState ~= nil then
			pendingState = internalData.pendingState
			internalData.pendingState = nil
		end

		-- Consume a standard update to state or props
		if updatedState ~= nil or newProps ~= self.props then
			if pendingState == nil then
				finalState = updatedState or self.state
			else
				finalState = assign(pendingState, updatedState)
			end

			local derivedState = self:__getDerivedState(newProps, finalState)

			if derivedState ~= nil then
				finalState = assign({}, finalState, derivedState)
			end

			updatedState = nil
		else
			finalState = pendingState
		end

		if not self:__resolveUpdate(newProps, finalState) then
			-- If the update was short-circuited, bubble the result up to the caller
			return false
		end

		updateCount = updateCount + 1

		if updateCount > MAX_PENDING_UPDATES then
			error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)
		end
	until internalData.pendingState == nil

	return true
end

--[[
	Internal method used by __update to apply new props and state

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__resolveUpdate(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__resolveUpdate`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	local oldProps = self.props
	local oldState = self.state

	if incomingProps == nil then
		incomingProps = oldProps
	end
	if incomingState == nil then
		incomingState = oldState
	end

	if self.shouldUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate
		local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)

		if not continueWithUpdate then
			internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
			return false
		end
	end

	if self.willUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate
		self:willUpdate(incomingProps, incomingState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render

	self.props = incomingProps
	self.state = incomingState

	local renderResult = virtualNode.instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)

	if self.didUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate
		self:didUpdate(oldProps, oldState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
	return true
end

return Component</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="279">
          <Properties>
            <string name="Name">Component.spec</string>
          </Properties>
          <Item class="ModuleScript" referent="280">
            <Properties>
              <string name="Name">context.spec</string>
              <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local oneChild = require(script.Parent.Parent.oneChild)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be provided as an internal api on Component", function()
		local Provider = Component:extend("Provider")

		function Provider:init()
			self:__addContext("foo", "bar")
		end

		function Provider:render()
		end

		local element = createElement(Provider)
		local hostParent = nil
		local hostKey = "Provider"
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContext = {
			foo = "bar",
		}

		assertDeepEqual(node.context, expectedContext)
	end)

	it("should be inherited from parent stateful nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = {
				hello = self:__getContext("hello"),
				value = self:__getContext("value"),
			}
		end

		function Consumer:render()
		end

		local Parent = Component:extend("Parent")

		function Parent:render()
			return createElement(Consumer)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local context = {
			hello = "world",
			value = 6,
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)

		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.context)
		assertDeepEqual(node.context, context)
		assertDeepEqual(capturedContext, context)
	end)

	it("should be inherited from parent function nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = {
				hello = self:__getContext("hello"),
				value = self:__getContext("value"),
			}
		end

		function Consumer:render()
		end

		local function Parent()
			return createElement(Consumer)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local context = {
			hello = "world",
			value = 6,
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)

		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.context)
		assertDeepEqual(node.context, context)
		assertDeepEqual(capturedContext, context)
	end)

	it("should not copy the context table if it doesn't need to", function()
		local Parent = Component:extend("Parent")

		function Parent:init()
			self:__addContext("parent", "I'm here!")
		end

		function Parent:render()
			-- Create some child element
			return createElement(function() end)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local parentNode = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContext = {
			parent = "I'm here!",
		}

		assertDeepEqual(parentNode.context, expectedContext)

		local childNode = oneChild(parentNode.children)

		-- Parent and child should have the same context table
		expect(parentNode.context).to.equal(childNode.context)
	end)

	it("should not allow context to move up the tree", function()
		local ChildProvider = Component:extend("ChildProvider")

		function ChildProvider:init()
			self:__addContext("child", "I'm here too!")
		end

		function ChildProvider:render()
		end

		local ParentProvider = Component:extend("ParentProvider")

		function ParentProvider:init()
			self:__addContext("parent", "I'm here!")
		end

		function ParentProvider:render()
			return createElement(ChildProvider)
		end

		local element = createElement(ParentProvider)
		local hostParent = nil
		local hostKey = "Parent"

		local parentNode = noopReconciler.mountVirtualNode(element, hostParent, hostKey)
		local childNode = oneChild(parentNode.children)

		local expectedParentContext = {
			parent = "I'm here!",
			-- Context does not travel back up
		}

		local expectedChildContext = {
			parent = "I'm here!",
			child = "I'm here too!"
		}

		assertDeepEqual(parentNode.context, expectedParentContext)
		assertDeepEqual(childNode.context, expectedChildContext)
	end)

	it("should contain values put into the tree by parent nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = {
				dont = self:__getContext("dont"),
				frob = self:__getContext("frob"),
			}
		end

		function Consumer:render()
		end

		local Provider = Component:extend("Provider")

		function Provider:init()
			self:__addContext("frob", "ulator")
		end

		function Provider:render()
			return createElement(Consumer)
		end

		local element = createElement(Provider)
		local hostParent = nil
		local hostKey = "Consumer"
		local context = {
			dont = "try it",
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)

		local initialContext = {
			dont = "try it",
		}

		local expectedContext = {
			dont = "try it",
			frob = "ulator",
		}

		-- Because components mutate context, we're careful with equality
		expect(node.context).never.to.equal(context)
		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.context)

		assertDeepEqual(context, initialContext)
		assertDeepEqual(node.context, expectedContext)
		assertDeepEqual(capturedContext, expectedContext)
	end)

	it("should transfer context to children that are replaced", function()
		local ConsumerA = Component:extend("ConsumerA")

		local function captureAllContext(component)
			return {
				A = component:__getContext("A"),
				B = component:__getContext("B"),
				frob = component:__getContext("frob"),
			}
		end

		local capturedContextA
		function ConsumerA:init()
			self:__addContext("A", "hello")

			capturedContextA = captureAllContext(self)
		end

		function ConsumerA:render()
		end

		local ConsumerB = Component:extend("ConsumerB")

		local capturedContextB
		function ConsumerB:init()
			self:__addContext("B", "hello")

			capturedContextB = captureAllContext(self)
		end

		function ConsumerB:render()
		end

		local Provider = Component:extend("Provider")

		function Provider:init()
			self:__addContext("frob", "ulator")
		end

		function Provider:render()
			local useConsumerB = self.props.useConsumerB

			if useConsumerB then
				return createElement(ConsumerB)
			else
				return createElement(ConsumerA)
			end
		end

		local hostParent = nil
		local hostKey = "Consumer"

		local element = createElement(Provider)
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContextA = {
			frob = "ulator",
			A = "hello",
		}

		assertDeepEqual(capturedContextA, expectedContextA)

		local expectedContextB = {
			frob = "ulator",
			B = "hello",
		}

		local replacedElement = createElement(Provider, {
			useConsumerB = true,
		})
		noopReconciler.updateVirtualNode(node, replacedElement)

		assertDeepEqual(capturedContextB, expectedContextB)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="281">
            <Properties>
              <string name="Name">defaultProps.spec</string>
              <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local None = require(script.Parent.Parent.None)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should fill in when mounting before init", function()
		local defaultProps = {
			a = 3,
			b = 2,
		}

		local Foo = Component:extend("Foo")

		Foo.defaultProps = defaultProps

		local capturedProps
		function Foo:init()
			capturedProps = self.props
		end

		function Foo:render()
		end

		local initialProps = {
			b = 4,
			c = 6,
		}

		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Some Foo"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		local expectedProps = {
			a = defaultProps.a,
			b = initialProps.b,
			c = initialProps.c,
		}

		assertDeepEqual(capturedProps, expectedProps)
	end)

	it("should fill in when updating via props", function()
		local defaultProps = {
			a = 3,
			b = 2,
		}

		local Foo = Component:extend("Foo")

		Foo.defaultProps = defaultProps

		local capturedProps
		function Foo:render()
			capturedProps = self.props
		end

		local initialProps = {
			b = 4,
			c = 6,
		}

		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Some Foo"

		local node = noopReconciler.mountVirtualNode(element, hostParent, key)

		local updatedProps = {
			c = 5,
		}
		local updatedElement = createElement(Foo, updatedProps)

		noopReconciler.updateVirtualNode(node, updatedElement)

		local expectedProps = {
			a = defaultProps.a,
			b = defaultProps.b,
			c = updatedProps.c,
		}

		assertDeepEqual(capturedProps, expectedProps)
	end)

	it("should respect None to override a default prop with nil", function()
		local defaultProps = {
			a = 3,
			b = 2,
		}

		local Foo = Component:extend("Foo")

		Foo.defaultProps = defaultProps

		local capturedProps
		function Foo:render()
			capturedProps = self.props
		end

		local initialProps = {
			b = None,
			c = 4,
		}

		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Some Foo"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		local expectedProps = {
			a = defaultProps.a,
			b = nil,
			c = initialProps.c,
		}

		assertDeepEqual(capturedProps, expectedProps)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="282">
            <Properties>
              <string name="Name">didMount.spec</string>
              <string name="Source">return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when mounted", function()
		local MyComponent = Component:extend("MyComponent")

		local didMountSpy = createSpy()

		MyComponent.didMount = didMountSpy.value

		function MyComponent:render()
			return nil
		end

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(didMountSpy.callCount).to.equal(1)

		local values = didMountSpy:captureValues("self")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="283">
            <Properties>
              <string name="Name">didUpdate.spec</string>
              <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when updated via updateVirtualNode", function()
		local MyComponent = Component:extend("MyComponent")

		local didUpdateSpy = createSpy()
		MyComponent.didUpdate = didUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialProps = {
			a = 5,
		}
		local initialElement = createElement(MyComponent, initialProps)
		local hostParent = nil
		local key = "Test"

		local virtualNode = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(didUpdateSpy.callCount).to.equal(0)

		local newProps = {
			a = 6,
			b = 2,
		}
		local newElement = createElement(MyComponent, newProps)
		noopReconciler.updateVirtualNode(virtualNode, newElement)

		expect(didUpdateSpy.callCount).to.equal(1)

		local values = didUpdateSpy:captureValues("self", "oldProps", "oldState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.oldProps, initialProps)
		assertDeepEqual(values.oldState, {})
	end)

	it("should be invoked when updated via setState", function()
		local MyComponent = Component:extend("MyComponent")

		local didUpdateSpy = createSpy()
		MyComponent.didUpdate = didUpdateSpy.value

		local initialState = {
			a = 4,
		}

		local setState
		function MyComponent:init()
			setState = function(...)
				return self:setState(...)
			end

			self:setState(initialState)
		end

		function MyComponent:render()
		end

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(didUpdateSpy.callCount).to.equal(0)

		setState({
			a = 5,
		})

		expect(didUpdateSpy.callCount).to.equal(1)

		local values = didUpdateSpy:captureValues("self", "oldProps", "oldState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.oldProps, {})
		assertDeepEqual(values.oldState, initialState)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="284">
            <Properties>
              <string name="Name">extend.spec</string>
              <string name="Source">return function()
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	it("should be extendable", function()
		local MyComponent = Component:extend("The Senate")

		expect(MyComponent).to.be.ok()
		expect(Type.of(MyComponent)).to.equal(Type.StatefulComponentClass)
	end)

	it("should prevent extending a user component", function()
		local MyComponent = Component:extend("Sheev")

		expect(function()
			MyComponent:extend("Frank")
		end).to.throw()
	end)

	it("should use a given name", function()
		local MyComponent = Component:extend("FooBar")

		local name = tostring(MyComponent)

		expect(name).to.be.a("string")
		expect(name:find("FooBar")).to.be.ok()
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="285">
            <Properties>
              <string name="Name">getDerivedStateFromProps.spec</string>
              <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createSpy = require(script.Parent.Parent.createSpy)
	local createElement = require(script.Parent.Parent.createElement)
	local createFragment = require(script.Parent.Parent.createFragment)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked on initial mount", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState, {
			someProp = 1,
		})
		local hostParent = nil
		local hostKey = "WithDerivedState"

		noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		expect(getDerivedSpy.callCount).to.equal(1)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, { someProp = 1 })
		assertDeepEqual(values.state, {})
	end)

	it("should be invoked when updated via props", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:render()
			return nil
		end

		local hostParent = nil
		local hostKey = "WithDerivedState"

		local node = noopReconciler.mountVirtualNode(createElement(WithDerivedState, {
			someProp = 1,
		}), hostParent, hostKey)

		noopReconciler.updateVirtualNode(node, createElement(WithDerivedState, {
			someProp = 2,
		}))

		expect(getDerivedSpy.callCount).to.equal(2)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, { someProp = 2 })
		assertDeepEqual(values.state, {})
	end)

	it("should be invoked when updated via state", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:init()
			self:setState({
				someState = 1,
			})
		end

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState)
		local hostParent = nil
		local hostKey = "WithDerivedState"

		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		noopReconciler.updateVirtualNode(node, element, {
			someState = 2,
		})

		-- getDerivedStateFromProps will be called:
		-- * Once on empty props
		-- * Once during the self:setState in init
		-- * Once more, defensively, on the resulting state AFTER init
		-- * On updating with new state via updateVirtualNode
		expect(getDerivedSpy.callCount).to.equal(4)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {})
		assertDeepEqual(values.state, { someState = 2 })
	end)

	it("should be invoked when updating via state in init (which skips reconciliation)", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:init()
			self:setState({
				stateFromInit = 1,
			})
		end

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState, {
			someProp = 1,
		})
		local hostParent = nil
		local hostKey = "WithDerivedState"

		noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		-- getDerivedStateFromProps will be called:
		-- * Once on empty props
		-- * Once during the self:setState in init
		-- * Once more, defensively, on the resulting state AFTER init
		expect(getDerivedSpy.callCount).to.equal(3)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {
			someProp = 1,
		})
		assertDeepEqual(values.state, {
			stateFromInit = 1,
		})
	end)

	it("should receive defaultProps", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.defaultProps = {
			someDefaultProp = "foo",
		}

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState, {
			someProp = 1,
		})
		local hostParent = nil
		local hostKey = "WithDerivedState"

		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		expect(getDerivedSpy.callCount).to.equal(1)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {
			someDefaultProp = "foo",
			someProp = 1,
		})

		-- Update via props, confirm that defaultProp is still present
		element = createElement(WithDerivedState, {
			someProp = 2,
		})

		noopReconciler.updateVirtualNode(node, element)

		expect(getDerivedSpy.callCount).to.equal(2)

		values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {
			someDefaultProp = "foo",
			someProp = 2,
		})
	end)

	it("should derive state for all setState updates, even when deferred", function()
		local Child = Component:extend("Child")
		local stateUpdaterSpy = createSpy(function()
			return {}
		end)
		local stateDerivedSpy = createSpy()

		function Child:render()
			return nil
		end

		function Child:didMount()
			self.props.callback()
		end

		local Parent = Component:extend("Parent")

		Parent.getDerivedStateFromProps = stateDerivedSpy.value

		function Parent:render()
			local callback = function()
				self:setState(stateUpdaterSpy.value)
			end

			return createFragment({
				ChildA = createElement(Child, {
					callback = callback,
				}),
				ChildB = createElement(Child, {
					callback = callback,
				}),
			})
		end

		local element = createElement(Parent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(stateUpdaterSpy.callCount).to.equal(2)

		-- getDerivedStateFromProps is always called on initial state
		expect(stateDerivedSpy.callCount).to.equal(3)
	end)

	it("should have derived state after assigning to state in init", function()
		local getStateCallback
		local getDerivedSpy = createSpy(function()
			return {
				derived = true,
			}
		end)
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:init()
			self.state = {
				init = true,
			}

			getStateCallback = function()
				return self.state
			end
		end

		function WithDerivedState:render()
			return nil
		end

		local hostParent = nil
		local hostKey = "WithDerivedState"
		local element = createElement(WithDerivedState)

		noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		expect(getDerivedSpy.callCount).to.equal(2)

		assertDeepEqual(getStateCallback(), {
			init = true,
			derived = true,
		})
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="286">
            <Properties>
              <string name="Name">getElementTraceback.spec</string>
              <string name="Source">return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local GlobalConfig = require(script.Parent.Parent.GlobalConfig)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should return stack traces in initial renders", function()
		local TestComponent = Component:extend("TestComponent")

		local stackTrace
		function TestComponent:init()
			stackTrace = self:getElementTraceback()
		end

		function TestComponent:render()
			return nil
		end

		local config = {
			elementTracing = true,
		}

		GlobalConfig.scoped(config, function()
			local element = createElement(TestComponent)
			local hostParent = nil
			local key = "Some key"

			noopReconciler.mountVirtualNode(element, hostParent, key)
		end)

		expect(stackTrace).to.be.a("string")
	end)

	itSKIP("it should return an updated stack trace after an update", function() end)

	it("should return nil when elementTracing is off", function()
		local stackTrace = nil

		local config = {
			elementTracing = false,
		}

		local TestComponent = Component:extend("TestComponent")

		function TestComponent:init()
			stackTrace = self:getElementTraceback()
		end

		function TestComponent:render()
			return nil
		end

		GlobalConfig.scoped(config, function()
			local element = createElement(TestComponent)
			local hostParent = nil
			local key = "Some key"

			noopReconciler.mountVirtualNode(element, hostParent, key)
		end)

		expect(stackTrace).to.equal(nil)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="287">
            <Properties>
              <string name="Name">init.spec</string>
              <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked with props when mounted", function()
		local MyComponent = Component:extend("MyComponent")

		local initSpy = createSpy()

		MyComponent.init = initSpy.value

		function MyComponent:render()
			return nil
		end

		local props = {
			a = 5,
		}
		local element = createElement(MyComponent, props)
		local hostParent = nil
		local key = "Some Component Key"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(initSpy.callCount).to.equal(1)

		local values = initSpy:captureValues("self", "props")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		expect(typeof(values.props)).to.equal("table")
		assertDeepEqual(values.props, props)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="288">
            <Properties>
              <string name="Name">legacyContext.spec</string>
              <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be provided as a mutable self._context in Component:init", function()
		local Provider = Component:extend("Provider")

		function Provider:init()
			self._context.foo = "bar"
		end

		function Provider:render()
		end

		local element = createElement(Provider)
		local hostParent = nil
		local hostKey = "Provider"
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContext = {
			foo = "bar",
		}

		assertDeepEqual(node.legacyContext, expectedContext)
	end)

	it("should be inherited from parent stateful nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = self._context
		end

		function Consumer:render()
		end

		local Parent = Component:extend("Parent")

		function Parent:render()
			return createElement(Consumer)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local context = {
			hello = "world",
			value = 6,
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)

		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.legacyContext)
		assertDeepEqual(node.legacyContext, context)
		assertDeepEqual(capturedContext, context)
	end)

	it("should be inherited from parent function nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = self._context
		end

		function Consumer:render()
		end

		local function Parent()
			return createElement(Consumer)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local context = {
			hello = "world",
			value = 6,
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)

		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.legacyContext)
		assertDeepEqual(node.legacyContext, context)
		assertDeepEqual(capturedContext, context)
	end)

	it("should contain values put into the tree by parent nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = self._context
		end

		function Consumer:render()
		end

		local Provider = Component:extend("Provider")

		function Provider:init()
			self._context.frob = "ulator"
		end

		function Provider:render()
			return createElement(Consumer)
		end

		local element = createElement(Provider)
		local hostParent = nil
		local hostKey = "Consumer"
		local context = {
			dont = "try it",
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)

		local initialContext = {
			dont = "try it",
		}

		local expectedContext = {
			dont = "try it",
			frob = "ulator",
		}

		-- Because components mutate context, we're careful with equality
		expect(node.legacyContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.legacyContext)

		assertDeepEqual(context, initialContext)
		assertDeepEqual(node.legacyContext, expectedContext)
		assertDeepEqual(capturedContext, expectedContext)
	end)

	it("should transfer context to children that are replaced", function()
		local ConsumerA = Component:extend("ConsumerA")

		local capturedContextA
		function ConsumerA:init()
			self._context.A = "hello"

			capturedContextA = self._context
		end

		function ConsumerA:render()
		end

		local ConsumerB = Component:extend("ConsumerB")

		local capturedContextB
		function ConsumerB:init()
			self._context.B = "hello"

			capturedContextB = self._context
		end

		function ConsumerB:render()
		end

		local Provider = Component:extend("Provider")

		function Provider:init()
			self._context.frob = "ulator"
		end

		function Provider:render()
			local useConsumerB = self.props.useConsumerB

			if useConsumerB then
				return createElement(ConsumerB)
			else
				return createElement(ConsumerA)
			end
		end

		local hostParent = nil
		local hostKey = "Consumer"

		local element = createElement(Provider)
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContextA = {
			frob = "ulator",
			A = "hello",
		}

		assertDeepEqual(capturedContextA, expectedContextA)

		local expectedContextB = {
			frob = "ulator",
			B = "hello",
		}

		local replacedElement = createElement(Provider, {
			useConsumerB = true,
		})
		noopReconciler.updateVirtualNode(node, replacedElement)

		assertDeepEqual(capturedContextB, expectedContextB)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="289">
            <Properties>
              <string name="Name">render.spec</string>
              <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should throw on mount if not overridden", function()
		local MyComponent = Component:extend("MyComponent")

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local success, result = pcall(function()
			noopReconciler.mountVirtualNode(element, hostParent, key)
		end)

		expect(success).to.equal(false)
		expect(result:match("MyComponent")).to.be.ok()
		expect(result:match("render")).to.be.ok()
	end)

	it("should be invoked when a component is mounted", function()
		local Foo = Component:extend("Foo")

		local capturedProps
		local capturedState
		local renderSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state
		end)
		Foo.render = renderSpy.value

		local element = createElement(Foo)
		local hostParent = nil
		local key = "Foo Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local renderArguments = renderSpy:captureValues("self")

		expect(Type.of(renderArguments.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(capturedProps, {})
		assertDeepEqual(capturedState, {})
	end)

	it("should be invoked when a component is updated via props", function()
		local Foo = Component:extend("Foo")

		local capturedProps
		local capturedState
		local renderSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state
		end)
		Foo.render = renderSpy.value

		local initialProps = {
			a = 2,
		}
		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Foo Test"

		local node = noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local firstRenderArguments = renderSpy:captureValues("self")
		local firstProps = capturedProps
		local firstState = capturedState

		expect(Type.of(firstRenderArguments.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(firstProps, initialProps)
		assertDeepEqual(firstState, {})

		local updatedProps = {
			a = 3,
		}
		local newElement = createElement(Foo, updatedProps)

		noopReconciler.updateVirtualNode(node, newElement)

		expect(renderSpy.callCount).to.equal(2)

		local secondRenderArguments = renderSpy:captureValues("self")
		local secondProps = capturedProps
		local secondState = capturedState

		expect(Type.of(secondRenderArguments.self)).to.equal(Type.StatefulComponentInstance)
		expect(secondProps).never.to.equal(firstProps)
		assertDeepEqual(secondProps, updatedProps)
		expect(secondState).to.equal(firstState)
	end)

	it("should be invoked when a component is updated via state", function()
		local Foo = Component:extend("Foo")

		local setState
		function Foo:init()
			setState = function(...)
				return self:setState(...)
			end
		end

		local capturedProps
		local capturedState
		local renderSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state
		end)
		Foo.render = renderSpy.value

		local element = createElement(Foo)
		local hostParent = nil
		local key = "Foo Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local firstRenderArguments = renderSpy:captureValues("self")
		local firstProps = capturedProps
		local firstState = capturedState

		expect(Type.of(firstRenderArguments.self)).to.equal(Type.StatefulComponentInstance)

		setState({})

		expect(renderSpy.callCount).to.equal(2)

		local renderArguments = renderSpy:captureValues("self")

		expect(Type.of(renderArguments.self)).to.equal(Type.StatefulComponentInstance)
		expect(capturedProps).to.equal(firstProps)
		expect(capturedState).never.to.equal(firstState)
	end)

	itSKIP("Test defaultProps on initial render", function() end)
	itSKIP("Test defaultProps on prop update", function() end)
	itSKIP("Test defaultProps on state update", function() end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="290">
            <Properties>
              <string name="Name">setState.spec</string>
              <string name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local None = require(script.Parent.Parent.None)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	describe("setState", function()
		it("should not trigger an extra update when called in init", function()
			local renderCount = 0
			local updateCount = 0
			local capturedState

			local InitComponent = Component:extend("InitComponent")

			function InitComponent:init()
				self:setState({
					a = 1
				})
			end

			function InitComponent:willUpdate()
				updateCount = updateCount + 1
			end

			function InitComponent:render()
				renderCount = renderCount + 1
				capturedState = self.state
				return nil
			end

			local initElement = createElement(InitComponent)

			noopReconciler.mountVirtualTree(initElement)

			expect(renderCount).to.equal(1)
			expect(updateCount).to.equal(0)
			expect(capturedState.a).to.equal(1)
		end)

		it("should throw when called in render", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				self:setState({
					a = 1
				})
			end

			local renderElement = createElement(TestComponent)

			local success, result = pcall(noopReconciler.mountVirtualTree, renderElement)

			expect(success).to.equal(false)
			expect(result:match("render")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should throw when called in shouldUpdate", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				return nil
			end

			function TestComponent:shouldUpdate()
				self:setState({
					a = 1
				})
			end

			local initialElement = createElement(TestComponent)
			local updatedElement = createElement(TestComponent)

			local tree = noopReconciler.mountVirtualTree(initialElement)

			local success, result = pcall(noopReconciler.updateVirtualTree, tree, updatedElement)

			expect(success).to.equal(false)
			expect(result:match("shouldUpdate")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should throw when called in willUpdate", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				return nil
			end

			function TestComponent:willUpdate()
				self:setState({
					a = 1
				})
			end

			local initialElement = createElement(TestComponent)
			local updatedElement = createElement(TestComponent)
			local tree = noopReconciler.mountVirtualTree(initialElement)

			local success, result = pcall(noopReconciler.updateVirtualTree, tree, updatedElement)

			expect(success).to.equal(false)
			expect(result:match("willUpdate")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should throw when called in willUnmount", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				return nil
			end

			function TestComponent:willUnmount()
				self:setState({
					a = 1
				})
			end

			local element = createElement(TestComponent)
			local tree = noopReconciler.mountVirtualTree(element)

			local success, result = pcall(noopReconciler.unmountVirtualTree, tree)

			expect(success).to.equal(false)
			expect(result:match("willUnmount")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should remove values from state when the value is None", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback, getStateCallback

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				getStateCallback = function()
					return self.state
				end

				self:setState({
					value = 0
				})
			end

			function TestComponent:render()
				return nil
			end

			local element = createElement(TestComponent)
			local instance = noopReconciler.mountVirtualNode(element, nil, "Test")

			expect(getStateCallback().value).to.equal(0)

			setStateCallback({
				value = None
			})

			expect(getStateCallback().value).to.equal(nil)

			noopReconciler.unmountVirtualNode(instance)
		end)

		it("should invoke functions to compute a partial state", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback, getStateCallback, getPropsCallback

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				getStateCallback = function()
					return self.state
				end

				getPropsCallback = function()
					return self.props
				end

				self:setState({
					value = 0
				})
			end

			function TestComponent:render()
				return nil
			end

			local element = createElement(TestComponent)
			local instance = noopReconciler.mountVirtualNode(element, nil, "Test")

			expect(getStateCallback().value).to.equal(0)

			setStateCallback(function(state, props)
				expect(state).to.equal(getStateCallback())
				expect(props).to.equal(getPropsCallback())

				return {
					value = state.value + 1
				}
			end)

			expect(getStateCallback().value).to.equal(1)

			noopReconciler.unmountVirtualNode(instance)
		end)

		it("should cancel rendering if the function returns nil", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback
			local renderCount = 0

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				self:setState({
					value = 0
				})
			end

			function TestComponent:render()
				renderCount = renderCount + 1
				return nil
			end

			local element = createElement(TestComponent)
			local instance = noopReconciler.mountVirtualNode(element, nil, "Test")
			expect(renderCount).to.equal(1)

			setStateCallback(function(state, props)
				return nil
			end)

			expect(renderCount).to.equal(1)

			noopReconciler.unmountVirtualNode(instance)
		end)
	end)

	describe("setState suspension", function()
		it("should defer setState triggered while reconciling", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback()
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function()
						self:setState({
							foo = "bar"
						})
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal("bar")
		end)

		it("should defer setState triggered while reconciling during an update", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didUpdate()
				self.props.callback()
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function()
						-- This guards against a stack overflow that would be OUR fault
						if not self.state.foo then
							self:setState({
								foo = "bar"
							})
						end
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal(nil)

			result = noopReconciler.updateVirtualNode(result, createElement(Parent))

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal("bar")

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should combine pending state changes properly", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback("foo", 1)
				self.props.callback("bar", 3)
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function(key, value)
						self:setState({
							[key] = value,
						})
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal(1)
			expect(getParentStateCallback().bar).to.equal(3)

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should abort properly when functional setState returns nil while deferred", function()
			local Child = Component:extend("Child")

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback()
			end

			local Parent = Component:extend("Parent")

			local renderSpy = createSpy(function(self)
				return createElement(Child, {
					callback = function()
						self:setState(function()
							-- abort the setState
							return nil
						end)
					end,
				})
			end)

			Parent.render = renderSpy.value

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(renderSpy.callCount).to.equal(1)

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should still apply pending state if a subsequent state update was aborted", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback(function()
					return {
						foo = 1,
					}
				end)
				self.props.callback(function()
					return nil
				end)
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function(stateUpdater)
						self:setState(stateUpdater)
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal(1)

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should not re-process new state when pending state is present after update", function()
			local setComponentState
			local getComponentState

			local MyComponent = Component:extend("MyComponent")

			function MyComponent:init()
				self:setState({
					hasUpdatedOnce = false,
					counter = 0,
				})

				setComponentState = function(mapState)
					self:setState(mapState)
				end

				getComponentState = function()
					return self.state
				end
			end

			function MyComponent:render()
				return nil
			end

			function MyComponent:didUpdate()
				if self.state.hasUpdatedOnce == false then
					self:setState({
						hasUpdatedOnce = true,
					})
				end
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(getComponentState().hasUpdatedOnce).to.equal(false)
			expect(getComponentState().counter).to.equal(0)

			setComponentState(function(state)
				return {
					counter = state.counter + 1
				}
			end)

			expect(getComponentState().hasUpdatedOnce).to.equal(true)
			expect(getComponentState().counter).to.equal(1)
		end)

		it("should throw when an infinite update is triggered", function()
			local InfiniteUpdater = Component:extend("InfiniteUpdater")

			function InfiniteUpdater:render()
				return nil
			end

			function InfiniteUpdater:didMount()
				self:setState({})
			end

			function InfiniteUpdater:didUpdate()
				self:setState({})
			end

			local element = createElement(InfiniteUpdater)
			local hostParent = nil
			local key = "Test"

			local success, result = pcall(noopReconciler.mountVirtualNode, element, hostParent, key)

			expect(success).to.equal(false)
			expect(result:find("InfiniteUpdater")).to.be.ok()
			expect(result:find("reached the setState update recursion limit")).to.be.ok()
		end)

		itSKIP("should process single updates with both new and pending state", function()
			--[[
				This situation shouldn't be possible currently, but the implementation
				should support it for future update de-duplication
			]]
		end)

		it("should call trigger update after didMount when setting state in didMount", function()
			--[[
				Before setState suspension, it was possible to call setState in didMount but it would
				not actually finish resolving didMount until after the entire update.

				This is theoretically problematic, as it means that lifecycle methods like didUpdate
				could be called before didMount is finished. setState suspension resolves this by
				suspending state updates made in didMount and didUpdate as well as reconciliation
			]]
			local MyComponent = Component:extend("MyComponent")

			function MyComponent:init()
				self:setState({
					status = "initial mount"
				})

				self.isMounted = false
			end

			function MyComponent:render()
				return nil
			end

			function MyComponent:didMount()
				self:setState({
					status = "mounted"
				})

				self.isMounted = true
			end

			function MyComponent:didUpdate(oldProps, oldState)
				expect(oldState.status).to.equal("initial mount")
				expect(self.state.status).to.equal("mounted")

				expect(self.isMounted).to.equal(true)
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
		end)
	end)
end
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="291">
            <Properties>
              <string name="Name">shouldUpdate.spec</string>
              <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when props update", function()
		local MyComponent = Component:extend("MyComponent")

		local capturedProps
		local capturedState
		local shouldUpdateSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state

			return true
		end)

		MyComponent.shouldUpdate = shouldUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialProps = {
			a = 5,
		}
		local initialElement = createElement(MyComponent, initialProps)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(shouldUpdateSpy.callCount).to.equal(0)

		local newProps = {
			a = 6,
			b = 2,
		}
		local newElement = createElement(MyComponent, newProps)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(shouldUpdateSpy.callCount).to.equal(1)

		local values = shouldUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)

		assertDeepEqual(values.newProps, newProps)

		assertDeepEqual(capturedProps, initialProps)

		expect(values.newState).to.equal(capturedState)
		assertDeepEqual(capturedState, {})
	end)

	it("should be invoked when state is updated", function()
		local MyComponent = Component:extend("MyComponent")

		local initialState = {
			a = 1,
		}

		local setState
		local initState
		function MyComponent:init()
			setState = function(...)
				return self:setState(...)
			end

			self:setState(initialState)

			initState = self.state
		end

		local capturedProps
		local capturedState
		local shouldUpdateSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state

			return true
		end)

		MyComponent.shouldUpdate = shouldUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(shouldUpdateSpy.callCount).to.equal(0)

		local newState = {
			a = 2,
			b = 3,
		}

		setState(newState)

		expect(shouldUpdateSpy.callCount).to.equal(1)

		local values = shouldUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)

		expect(values.newProps).to.equal(capturedProps)
		assertDeepEqual(capturedProps, {})

		assertDeepEqual(capturedState, initialState)
		expect(capturedState).to.equal(initState)
		assertDeepEqual(values.newState, newState)
	end)

	it("should not abort an update when returning true", function()
		local MyComponent = Component:extend("MyComponent")

		function MyComponent:shouldUpdate()
			return true
		end

		local renderSpy = createSpy()

		MyComponent.render = renderSpy.value

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local newElement = createElement(MyComponent)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(renderSpy.callCount).to.equal(2)
	end)

	it("should abort an update when retuning false", function()
		local MyComponent = Component:extend("MyComponent")

		function MyComponent:shouldUpdate()
			return false
		end

		local renderSpy = createSpy()

		MyComponent.render = renderSpy.value

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local newElement = createElement(MyComponent)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(renderSpy.callCount).to.equal(1)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="292">
            <Properties>
              <string name="Name">validateProps.spec</string>
              <string name="Source">return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local GlobalConfig = require(script.Parent.Parent.GlobalConfig)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when mounted", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
		end)
	end)

	it("should be invoked when props change", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			local node = noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 1,
			})

			local newElement = createElement(MyComponent, { a = 2 })
			noopReconciler.updateVirtualNode(node, newElement)
			expect(validatePropsSpy.callCount).to.equal(2)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 2,
			})
		end)
	end)

	it("should not be invoked when state changes", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local setStateCallback = nil
			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end
			end

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 1
			})

			setStateCallback({
				b = 1
			})

			expect(validatePropsSpy.callCount).to.equal(1)
		end)
	end)

	it("should throw if validateProps is not a function", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")
			MyComponent.validateProps = 1

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			expect(function()
				noopReconciler.mountVirtualNode(element, hostParent, key)
			end).to.throw()
		end)
	end)

	it("should throw if validateProps returns false", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")
			MyComponent.validateProps = function()
				return false
			end

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			expect(function()
				noopReconciler.mountVirtualNode(element, hostParent, key)
			end).to.throw()
		end)
	end)

	it("should be invoked after defaultProps are applied", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			MyComponent.defaultProps = {
				b = 2,
			}

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			local node = noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 1,
				b = 2,
			})

			local newElement = createElement(MyComponent, { a = 2 })
			noopReconciler.updateVirtualNode(node, newElement)
			expect(validatePropsSpy.callCount).to.equal(2)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 2,
				b = 2,
			})
		end)
	end)

	it("should not be invoked if the flag is off", function()
		local config = {
			propValidation = false,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			local node = noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(0)

			local newElement = createElement(MyComponent, { a = 2 })
			noopReconciler.updateVirtualNode(node, newElement)
			expect(validatePropsSpy.callCount).to.equal(0)
		end)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="293">
            <Properties>
              <string name="Name">willUnmount.spec</string>
              <string name="Source">return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when unmounted", function()
		local MyComponent = Component:extend("MyComponent")

		local willUnmountSpy = createSpy()

		MyComponent.willUnmount = willUnmountSpy.value

		function MyComponent:render()
			return nil
		end

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(element, hostParent, key)
		noopReconciler.unmountVirtualNode(node)

		expect(willUnmountSpy.callCount).to.equal(1)

		local values = willUnmountSpy:captureValues("self")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="294">
            <Properties>
              <string name="Name">willUpdate.spec</string>
              <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when updated via updateVirtualNode", function()
		local MyComponent = Component:extend("MyComponent")

		local willUpdateSpy = createSpy()

		MyComponent.willUpdate = willUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialProps = {
			a = 5,
		}
		local initialElement = createElement(MyComponent, initialProps)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		local newProps = {
			a = 6,
			b = 2,
		}
		local newElement = createElement(MyComponent, newProps)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(willUpdateSpy.callCount).to.equal(1)

		local values = willUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.newProps, newProps)
		assertDeepEqual(values.newState, {})
	end)

	it("it should be invoked when updated via setState", function()
		local MyComponent = Component:extend("MyComponent")
		local setComponentState

		local willUpdateSpy = createSpy()

		MyComponent.willUpdate = willUpdateSpy.value

		function MyComponent:init()
			setComponentState = function(state)
				self:setState(state)
			end

			self:setState({
				foo = 1
			})
		end

		function MyComponent:render()
			return nil
		end

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(willUpdateSpy.callCount).to.equal(0)

		setComponentState({
			foo = 2
		})

		expect(willUpdateSpy.callCount).to.equal(1)

		local values = willUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.newProps, {})
		assertDeepEqual(values.newState, {
			foo = 2
		})
	end)
end</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="295">
          <Properties>
            <string name="Name">ComponentLifecyclePhase</string>
            <string name="Source">local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local ComponentLifecyclePhase = strict({
	-- Component methods
	Init = Symbol.named("init"),
	Render = Symbol.named("render"),
	ShouldUpdate = Symbol.named("shouldUpdate"),
	WillUpdate = Symbol.named("willUpdate"),
	DidMount = Symbol.named("didMount"),
	DidUpdate = Symbol.named("didUpdate"),
	WillUnmount = Symbol.named("willUnmount"),

	-- Phases describing reconciliation status
	ReconcileChildren = Symbol.named("reconcileChildren"),
	Idle = Symbol.named("idle"),
}, "ComponentLifecyclePhase")

return ComponentLifecyclePhase</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="296">
          <Properties>
            <string name="Name">Config</string>
            <string name="Source">--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.
	["internalTypeChecks"] = false,
	-- Enables stricter type asserts for Roact's public API.
	["typeChecks"] = false,
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables validation of component props in stateful components.
	["propValidation"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

local Config = {}

function Config.new()
	local self = {}

	self._currentConfig = setmetatable({}, {
		__index = function(_, key)
			local message = (
				"Invalid global configuration key %q. Valid configuration keys are: %s"
			):format(
				tostring(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end
	})

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.get = function(...)
		return Config.get(self, ...)
	end

	self.scoped = function(...)
		return Config.scoped(self, ...)
	end

	self.set(defaultConfig)

	return self
end

function Config:set(configValues)
	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = (
				"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
			):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(
				tostring(value),
				typeof(value),
				tostring(key)
			)

			error(message, 3)
		end

		self._currentConfig[key] = value
	end
end

function Config:get()
	return self._currentConfig
end

function Config:scoped(configValues, callback)
	local previousValues = {}
	for key, value in pairs(self._currentConfig) do
		previousValues[key] = value
	end

	self.set(configValues)

	local success, result = pcall(callback)

	self.set(previousValues)

	assert(success, result)
end

return Config</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="297">
          <Properties>
            <string name="Name">Config.spec</string>
            <string name="Source">return function()
	local Config = require(script.Parent.Config)

	it("should accept valid configuration", function()
		local config = Config.new()
		local values = config.get()

		expect(values.elementTracing).to.equal(false)

		config.set({
			elementTracing = true,
		})

		expect(values.elementTracing).to.equal(true)
	end)

	it("should reject invalid configuration keys", function()
		local config = Config.new()

		local badKey = "garblegoop"

		local ok, err = pcall(function()
			config.set({
				[badKey] = true,
			})
		end)

		expect(ok).to.equal(false)

		-- The error should mention our bad key somewhere.
		expect(err:find(badKey)).to.be.ok()
	end)

	it("should reject invalid configuration values", function()
		local config = Config.new()

		local goodKey = "elementTracing"
		local badValue = "Hello there!"

		local ok, err = pcall(function()
			config.set({
				[goodKey] = badValue,
			})
		end)

		expect(ok).to.equal(false)

		-- The error should mention both our key and value
		expect(err:find(goodKey)).to.be.ok()
		expect(err:find(badValue)).to.be.ok()
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="298">
          <Properties>
            <string name="Name">ElementKind</string>
            <string name="Source">--[[
	Contains markers for annotating the type of an element.

	Use `ElementKind` as a key, and values from it as the value.

		local element = {
			[ElementKind] = ElementKind.Host,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)
local Portal = require(script.Parent.Portal)

local ElementKind = newproxy(true)

local ElementKindInternal = {
	Portal = Symbol.named("Portal"),
	Host = Symbol.named("Host"),
	Function = Symbol.named("Function"),
	Stateful = Symbol.named("Stateful"),
	Fragment = Symbol.named("Fragment"),
}

function ElementKindInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[ElementKind]
end

local componentTypesToKinds = {
	["string"] = ElementKindInternal.Host,
	["function"] = ElementKindInternal.Function,
	["table"] = ElementKindInternal.Stateful,
}

function ElementKindInternal.fromComponent(component)
	if component == Portal then
		return ElementKind.Portal
	else
		return componentTypesToKinds[typeof(component)]
	end
end

getmetatable(ElementKind).__index = ElementKindInternal

strict(ElementKindInternal, "ElementKind")

return ElementKind</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="299">
          <Properties>
            <string name="Name">ElementKind.spec</string>
            <string name="Source">return function()
	local Portal = require(script.Parent.Portal)
	local Component = require(script.Parent.Component)

	local ElementKind = require(script.Parent.ElementKind)

	describe("of", function()
		it("should return nil for non-table values", function()
			expect(ElementKind.of(nil)).to.equal(nil)
			expect(ElementKind.of(5)).to.equal(nil)
			expect(ElementKind.of(newproxy(true))).to.equal(nil)
		end)

		it("should return nil for table values without an ElementKind key", function()
			expect(ElementKind.of({})).to.equal(nil)
		end)

		it("should return the ElementKind from a table", function()
			local value = {
				[ElementKind] = ElementKind.Stateful,
			}

			expect(ElementKind.of(value)).to.equal(ElementKind.Stateful)
		end)
	end)

	describe("fromComponent", function()
		it("should handle host components", function()
			expect(ElementKind.fromComponent("foo")).to.equal(ElementKind.Host)
		end)

		it("should handle function components", function()
			local function foo()
			end

			expect(ElementKind.fromComponent(foo)).to.equal(ElementKind.Function)
		end)

		it("should handle stateful components", function()
			local Foo = Component:extend("Foo")

			expect(ElementKind.fromComponent(Foo)).to.equal(ElementKind.Stateful)
		end)

		it("should handle portals", function()
			expect(ElementKind.fromComponent(Portal)).to.equal(ElementKind.Portal)
		end)

		it("should return nil for invalid inputs", function()
			expect(ElementKind.fromComponent(5)).to.equal(nil)
			expect(ElementKind.fromComponent(newproxy(true))).to.equal(nil)
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="300">
          <Properties>
            <string name="Name">ElementUtils</string>
            <string name="Source">local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)

local function noop()
	return nil
end

local ElementUtils = {}

--[[
	A signal value indicating that a child should use its parent's key, because
	it has no key of its own.

	This occurs when you return only one element from a function component or
	stateful render function.
]]
ElementUtils.UseParentKey = Symbol.named("UseParentKey")

--[[
	Returns an iterator over the children of an element.
	`elementOrElements` may be one of:
	* a boolean
	* nil
	* a single element
	* a fragment
	* a table of elements

	If `elementOrElements` is a boolean or nil, this will return an iterator with
	zero elements.

	If `elementOrElements` is a single element, this will return an iterator with
	one element: a tuple where the first value is ElementUtils.UseParentKey, and
	the second is the value of `elementOrElements`.

	If `elementOrElements` is a fragment or a table, this will return an iterator
	over all the elements of the array.

	If `elementOrElements` is none of the above, this function will throw.
]]
function ElementUtils.iterateElements(elementOrElements)
	local richType = Type.of(elementOrElements)

	-- Single child
	if richType == Type.Element then
		local called = false

		return function()
			if called then
				return nil
			else
				called = true
				return ElementUtils.UseParentKey, elementOrElements
			end
		end
	end

	local regularType = typeof(elementOrElements)

	if elementOrElements == nil or regularType == "boolean" then
		return noop
	end

	if regularType == "table" then
		return pairs(elementOrElements)
	end

	error("Invalid elements")
end

--[[
	Gets the child corresponding to a given key, respecting Roact's rules for
	children. Specifically:
	* If `elements` is nil or a boolean, this will return `nil`, regardless of
		the key given.
	* If `elements` is a single element, this will return `nil`, unless the key
		is ElementUtils.UseParentKey.
	* If `elements` is a table of elements, this will return `elements[key]`.
]]
function ElementUtils.getElementByKey(elements, hostKey)
	if elements == nil or typeof(elements) == "boolean" then
		return nil
	end

	if Type.of(elements) == Type.Element then
		if hostKey == ElementUtils.UseParentKey then
			return elements
		end

		return nil
	end

	if typeof(elements) == "table" then
		return elements[hostKey]
	end

	error("Invalid elements")
end

return ElementUtils</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="301">
          <Properties>
            <string name="Name">ElementUtils.spec</string>
            <string name="Source">return function()
	local ElementUtils = require(script.Parent.ElementUtils)
	local createElement = require(script.Parent.createElement)
	local createFragment = require(script.Parent.createFragment)
	local Type = require(script.Parent.Type)

	describe("iterateElements", function()
		it("should iterate once for a single child", function()
			local child = createElement("TextLabel")
			local iterator = ElementUtils.iterateElements(child)
			local iteratedKey, iteratedChild = iterator()
			-- For single elements, the key should be UseParentKey
			expect(iteratedKey).to.equal(ElementUtils.UseParentKey)
			expect(iteratedChild).to.equal(child)

			iteratedKey = iterator()
			expect(iteratedKey).to.equal(nil)
		end)

		it("should iterate over tables", function()
			local children = {
				a = createElement("TextLabel"),
				b = createElement("TextLabel"),
			}

			local seenChildren = {}
			local count = 0

			for key, child in ElementUtils.iterateElements(children) do
				expect(typeof(key)).to.equal("string")
				expect(Type.of(child)).to.equal(Type.Element)
				seenChildren[child] = key
				count = count + 1
			end

			expect(count).to.equal(2)
			expect(seenChildren[children.a]).to.equal("a")
			expect(seenChildren[children.b]).to.equal("b")
		end)

		it("should return a zero-element iterator for booleans", function()
			local booleanIterator = ElementUtils.iterateElements(false)
			expect(booleanIterator()).to.equal(nil)
		end)

		it("should return a zero-element iterator for nil", function()
			local nilIterator = ElementUtils.iterateElements(nil)
			expect(nilIterator()).to.equal(nil)
		end)

		it("should throw if given an illegal value", function()
			expect(function()
				ElementUtils.iterateElements(1)
			end).to.throw()
		end)
	end)

	describe("getElementByKey", function()
		it("should return nil for booleans", function()
			expect(ElementUtils.getElementByKey(true, "test")).to.equal(nil)
		end)

		it("should return nil for nil", function()
			expect(ElementUtils.getElementByKey(nil, "test")).to.equal(nil)
		end)

		describe("single elements", function()
			local element = createElement("TextLabel")

			it("should return the element if the key is UseParentKey", function()
				expect(ElementUtils.getElementByKey(element, ElementUtils.UseParentKey)).to.equal(element)
			end)

			it("should return nil if the key is not UseParentKey", function()
				expect(ElementUtils.getElementByKey(element, "test")).to.equal(nil)
			end)
		end)

		it("should return the corresponding element from a table", function()
			local children = {
				a = createElement("TextLabel"),
				b = createElement("TextLabel"),
			}

			expect(ElementUtils.getElementByKey(children, "a")).to.equal(children.a)
			expect(ElementUtils.getElementByKey(children, "b")).to.equal(children.b)
		end)

		it("should return nil if the key does not exist", function()
			local children = createFragment({})

			expect(ElementUtils.getElementByKey(children, "a")).to.equal(nil)
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="302">
          <Properties>
            <string name="Name">GlobalConfig</string>
            <string name="Source">--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="303">
          <Properties>
            <string name="Name">GlobalConfig.spec</string>
            <string name="Source">return function()
	local GlobalConfig = require(script.Parent.GlobalConfig)

	it("should have the correct methods", function()
		expect(GlobalConfig).to.be.ok()
		expect(GlobalConfig.set).to.be.ok()
		expect(GlobalConfig.get).to.be.ok()
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="304">
          <Properties>
            <string name="Name">Logging</string>
            <string name="Source">--[[
	Centralized place to handle logging. Lets us:
	- Unit test log output via `Logging.capture`
	- Disable verbose log messages when not debugging Roact

	This should be broken out into a separate library with the addition of
	scoping and logging configuration.
]]

-- Determines whether log messages will go to stdout/stderr
local outputEnabled = true

-- A set of LogInfo objects that should have messages inserted into them.
-- This is a set so that nested calls to Logging.capture will behave.
local collectors = {}

-- A set of all stack traces that have called warnOnce.
local onceUsedLocations = {}

--[[
	Indent a potentially multi-line string with the given number of tabs, in
	addition to any indentation the string already has.
]]
local function indent(source, indentLevel)
	local indentString = ("\t"):rep(indentLevel)

	return indentString .. source:gsub("\n", "\n" .. indentString)
end

--[[
	Indents a list of strings and then concatenates them together with newlines
	into a single string.
]]
local function indentLines(lines, indentLevel)
	local outputBuffer = {}

	for _, line in ipairs(lines) do
		table.insert(outputBuffer, indent(line, indentLevel))
	end

	return table.concat(outputBuffer, "\n")
end

local logInfoMetatable = {}

--[[
	Automatic coercion to strings for LogInfo objects to enable debugging them
	more easily.
]]
function logInfoMetatable:__tostring()
	local outputBuffer = {"LogInfo {"}

	local errorCount = #self.errors
	local warningCount = #self.warnings
	local infosCount = #self.infos

	if errorCount + warningCount + infosCount == 0 then
		table.insert(outputBuffer, "\t(no messages)")
	end

	if errorCount > 0 then
		table.insert(outputBuffer, ("\tErrors (%d) {"):format(errorCount))
		table.insert(outputBuffer, indentLines(self.errors, 2))
		table.insert(outputBuffer, "\t}")
	end

	if warningCount > 0 then
		table.insert(outputBuffer, ("\tWarnings (%d) {"):format(warningCount))
		table.insert(outputBuffer, indentLines(self.warnings, 2))
		table.insert(outputBuffer, "\t}")
	end

	if infosCount > 0 then
		table.insert(outputBuffer, ("\tInfos (%d) {"):format(infosCount))
		table.insert(outputBuffer, indentLines(self.infos, 2))
		table.insert(outputBuffer, "\t}")
	end

	table.insert(outputBuffer, "}")

	return table.concat(outputBuffer, "\n")
end

local function createLogInfo()
	local logInfo = {
		errors = {},
		warnings = {},
		infos = {},
	}

	setmetatable(logInfo, logInfoMetatable)

	return logInfo
end

local Logging = {}

--[[
	Invokes `callback`, capturing all output that happens during its execution.

	Output will not go to stdout or stderr and will instead be put into a
	LogInfo object that is returned. If `callback` throws, the error will be
	bubbled up to the caller of `Logging.capture`.
]]
function Logging.capture(callback)
	local collector = createLogInfo()

	local wasOutputEnabled = outputEnabled
	outputEnabled = false
	collectors[collector] = true

	local success, result = pcall(callback)

	collectors[collector] = nil
	outputEnabled = wasOutputEnabled

	assert(success, result)

	return collector
end

--[[
	Issues a warning with an automatically attached stack trace.
]]
function Logging.warn(messageTemplate, ...)
	local message = messageTemplate:format(...)

	for collector in pairs(collectors) do
		table.insert(collector.warnings, message)
	end

	-- debug.traceback inserts a leading newline, so we trim it here
	local trace = debug.traceback("", 2):sub(2)
	local fullMessage = ("%s\n%s"):format(message, indent(trace, 1))

	if outputEnabled then
		warn(fullMessage)
	end
end

--[[
	Issues a warning like `Logging.warn`, but only outputs once per call site.

	This is useful for marking deprecated functions that might be called a lot;
	using `warnOnce` instead of `warn` will reduce output noise while still
	correctly marking all call sites.
]]
function Logging.warnOnce(messageTemplate, ...)
	local trace = debug.traceback()

	if onceUsedLocations[trace] then
		return
	end

	onceUsedLocations[trace] = true
	Logging.warn(messageTemplate, ...)
end

return Logging</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="305">
          <Properties>
            <string name="Name">None</string>
            <string name="Source">local Symbol = require(script.Parent.Symbol)

-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = Symbol.named("None")

return None</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="306">
          <Properties>
            <string name="Name">NoopRenderer</string>
            <string name="Source">--[[
	Reference renderer intended for use in tests as well as for documenting the
	minimum required interface for a Roact renderer.
]]

local NoopRenderer = {}

function NoopRenderer.isHostObject(target)
	-- Attempting to use NoopRenderer to target a Roblox instance is almost
	-- certainly a mistake.
	return target == nil
end

function NoopRenderer.mountHostNode(reconciler, node)
end

function NoopRenderer.unmountHostNode(reconciler, node)
end

function NoopRenderer.updateHostNode(reconciler, node, newElement)
	return node
end

return NoopRenderer</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="307">
          <Properties>
            <string name="Name">Portal</string>
            <string name="Source">local Symbol = require(script.Parent.Symbol)

local Portal = Symbol.named("Portal")

return Portal</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="308">
          <Properties>
            <string name="Name">PropMarkers</string>
          </Properties>
          <Item class="ModuleScript" referent="309">
            <Properties>
              <string name="Name">Change</string>
              <string name="Source"><![CDATA[--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent.Type)

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("RoactHostChangeEvent(%s)"):format(self.name)
	end,
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName,
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="310">
            <Properties>
              <string name="Name">Change.spec</string>
              <string name="Source">return function()
	local Type = require(script.Parent.Parent.Type)

	local Change = require(script.Parent.Change)

	it("should yield change listener objects when indexed", function()
		expect(Type.of(Change.Text)).to.equal(Type.HostChangeEvent)
		expect(Type.of(Change.Selected)).to.equal(Type.HostChangeEvent)
	end)

	it("should yield the same object when indexed again", function()
		local a = Change.Text
		local b = Change.Text
		local c = Change.Selected

		expect(a).to.equal(b)
		expect(a).never.to.equal(c)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="311">
            <Properties>
              <string name="Name">Children</string>
              <string name="Source">local Symbol = require(script.Parent.Parent.Symbol)

local Children = Symbol.named("Children")

return Children</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="312">
            <Properties>
              <string name="Name">Event</string>
              <string name="Source"><![CDATA[--[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent.Type)

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("RoactHostEvent(%s)"):format(self.name)
	end,
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end,
})

return Event
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="313">
            <Properties>
              <string name="Name">Event.spec</string>
              <string name="Source">return function()
	local Type = require(script.Parent.Parent.Type)

	local Event = require(script.Parent.Event)

	it("should yield event objects when indexed", function()
		expect(Type.of(Event.MouseButton1Click)).to.equal(Type.HostEvent)
		expect(Type.of(Event.Touched)).to.equal(Type.HostEvent)
	end)

	it("should yield the same object when indexed again", function()
		local a = Event.MouseButton1Click
		local b = Event.MouseButton1Click
		local c = Event.Touched

		expect(a).to.equal(b)
		expect(a).never.to.equal(c)
	end)
end</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="314">
            <Properties>
              <string name="Name">Ref</string>
              <string name="Source">local Symbol = require(script.Parent.Parent.Symbol)

local Ref = Symbol.named("Ref")

return Ref</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="315">
          <Properties>
            <string name="Name">PureComponent</string>
            <string name="Source">--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="316">
          <Properties>
            <string name="Name">PureComponent.spec</string>
            <string name="Source">return function()
	local createElement = require(script.Parent.createElement)
	local NoopRenderer = require(script.Parent.NoopRenderer)
	local createReconciler = require(script.Parent.createReconciler)

	local PureComponent = require(script.Parent.PureComponent)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be extendable", function()
		local MyComponent = PureComponent:extend("MyComponent")

		expect(MyComponent).to.be.ok()
	end)

	it("should skip updates for shallow-equal props", function()
		local updateCount = 0
		local setValue

		local PureChild = PureComponent:extend("PureChild")

		function PureChild:willUpdate()
			updateCount = updateCount + 1
		end

		function PureChild:render()
			return nil
		end

		local PureContainer = PureComponent:extend("PureContainer")

		function PureContainer:init()
			self.state = {
				value = 0,
			}
		end

		function PureContainer:didMount()
			setValue = function(value)
				self:setState({
					value = value,
				})
			end
		end

		function PureContainer:render()
			return createElement(PureChild, {
				value = self.state.value,
			})
		end

		local element = createElement(PureContainer)
		local tree = noopReconciler.mountVirtualTree(element, nil, "PureComponent Tree")

		expect(updateCount).to.equal(0)

		setValue(1)

		expect(updateCount).to.equal(1)

		setValue(1)

		expect(updateCount).to.equal(1)

		setValue(2)

		expect(updateCount).to.equal(2)

		setValue(1)

		expect(updateCount).to.equal(3)

		noopReconciler.unmountVirtualTree(tree)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="317">
          <Properties>
            <string name="Name">RobloxRenderer</string>
            <string name="Source"><![CDATA[--[[
	Renderer that deals in terms of Roblox Instances. This is the most
	well-supported renderer after NoopRenderer and is currently the only
	renderer that does anything.
]]

local Binding = require(script.Parent.Binding)
local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local SingleEventManager = require(script.Parent.SingleEventManager)
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local Ref = require(script.Parent.PropMarkers.Ref)
local Type = require(script.Parent.Type)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local applyPropsError = [[
Error applying props:
	%s
In element:
%s
]]

local updatePropsError = [[
Error updating props:
	%s
In element:
%s
]]

local function identity(...)
	return ...
end

local function applyRef(ref, newHostObject)
	if ref == nil then
		return
	end

	if typeof(ref) == "function" then
		ref(newHostObject)
	elseif Type.of(ref) == Type.Binding then
		Binding.update(ref, newHostObject)
	else
		-- TODO (#197): Better error message
		error(("Invalid ref: Expected type Binding but got %s"):format(
			typeof(ref)
		))
	end
end

local function setRobloxInstanceProperty(hostObject, key, newValue)
	if newValue == nil then
		local hostClass = hostObject.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostObject[key] = newValue

	return
end

local function removeBinding(virtualNode, key)
	local disconnect = virtualNode.bindings[key]
	disconnect()
	virtualNode.bindings[key] = nil
end

local function attachBinding(virtualNode, key, newBinding)
	local function updateBoundProperty(newValue)
		local success, errorMessage = xpcall(function()
			setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
		end, identity)

		if not success then
			local source = virtualNode.currentElement.source

			if source == nil then
				source = "<enable element tracebacks>"
			end

			local fullMessage = updatePropsError:format(errorMessage, source)
			error(fullMessage, 0)
		end
	end

	if virtualNode.bindings == nil then
		virtualNode.bindings = {}
	end

	virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function detachAllBindings(virtualNode)
	if virtualNode.bindings ~= nil then
		for _, disconnect in pairs(virtualNode.bindings) do
			disconnect()
		end
	end
end

local function applyProp(virtualNode, key, newValue, oldValue)
	if newValue == oldValue then
		return
	end

	if key == Ref or key == Children then
		-- Refs and children are handled in a separate pass
		return
	end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		if virtualNode.eventManager == nil then
			virtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			virtualNode.eventManager:connectPropertyChange(eventName, newValue)
		else
			virtualNode.eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	local newIsBinding = Type.of(newValue) == Type.Binding
	local oldIsBinding = Type.of(oldValue) == Type.Binding

	if oldIsBinding then
		removeBinding(virtualNode, key)
	end

	if newIsBinding then
		attachBinding(virtualNode, key, newValue)
	else
		setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
	end
end

local function applyProps(virtualNode, props)
	for propKey, value in pairs(props) do
		applyProp(virtualNode, propKey, value, nil)
	end
end

local function updateProps(virtualNode, oldProps, newProps)
	-- Apply props that were added or updated
	for propKey, newValue in pairs(newProps) do
		local oldValue = oldProps[propKey]

		applyProp(virtualNode, propKey, newValue, oldValue)
	end

	-- Clean up props that were removed
	for propKey, oldValue in pairs(oldProps) do
		local newValue = newProps[propKey]

		if newValue == nil then
			applyProp(virtualNode, propKey, nil, oldValue)
		end
	end
end

local RobloxRenderer = {}

function RobloxRenderer.isHostObject(target)
	return typeof(target) == "Instance"
end

function RobloxRenderer.mountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement
	local hostParent = virtualNode.hostParent
	local hostKey = virtualNode.hostKey

	if config.internalTypeChecks then
		internalAssert(ElementKind.of(element) == ElementKind.Host, "Element at given node is not a host Element")
	end
	if config.typeChecks then
		assert(element.props.Name == nil, "Name can not be specified as a prop to a host component in Roact.")
		assert(element.props.Parent == nil, "Parent can not be specified as a prop to a host component in Roact.")
	end

	local instance = Instance.new(element.component)
	virtualNode.hostObject = instance

	local success, errorMessage = xpcall(function()
		applyProps(virtualNode, element.props)
	end, identity)

	if not success then
		local source = element.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = applyPropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	instance.Name = tostring(hostKey)

	local children = element.props[Children]

	if children ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	instance.Parent = hostParent
	virtualNode.hostObject = instance

	applyRef(element.props[Ref], instance)

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end
end

function RobloxRenderer.unmountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement

	applyRef(element.props[Ref], nil)

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end

	detachAllBindings(virtualNode)

	virtualNode.hostObject:Destroy()
end

function RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)
	local oldProps = virtualNode.currentElement.props
	local newProps = newElement.props

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:suspend()
	end

	-- If refs changed, detach the old ref and attach the new one
	if oldProps[Ref] ~= newProps[Ref] then
		applyRef(oldProps[Ref], nil)
		applyRef(newProps[Ref], virtualNode.hostObject)
	end

	local success, errorMessage = xpcall(function()
		updateProps(virtualNode, oldProps, newProps)
	end, identity)

	if not success then
		local source = newElement.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = updatePropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	local children = newElement.props[Children]
	if children ~= nil or oldProps[Children] ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end

	return virtualNode
end

return RobloxRenderer
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="318">
          <Properties>
            <string name="Name">RobloxRenderer.spec</string>
            <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.assertDeepEqual)
	local Binding = require(script.Parent.Binding)
	local Children = require(script.Parent.PropMarkers.Children)
	local Component = require(script.Parent.Component)
	local createElement = require(script.Parent.createElement)
	local createFragment = require(script.Parent.createFragment)
	local createReconciler = require(script.Parent.createReconciler)
	local createRef = require(script.Parent.createRef)
	local createSpy = require(script.Parent.createSpy)
	local GlobalConfig = require(script.Parent.GlobalConfig)
	local Portal = require(script.Parent.Portal)
	local Ref = require(script.Parent.PropMarkers.Ref)

	local RobloxRenderer = require(script.Parent.RobloxRenderer)

	local reconciler = createReconciler(RobloxRenderer)

	describe("mountHostNode", function()
		it("should create instances with correct props", function()
			local parent = Instance.new("Folder")
			local value = "Hello!"
			local key = "Some Key"

			local element = createElement("StringValue", {
				Value = value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local root = parent:GetChildren()[1]

			expect(root.ClassName).to.equal("StringValue")
			expect(root.Value).to.equal(value)
			expect(root.Name).to.equal(key)
		end)

		it("should create children with correct names and props", function()
			local parent = Instance.new("Folder")
			local rootValue = "Hey there!"
			local childValue = 173
			local key = "Some Key"

			local element = createElement("StringValue", {
				Value = rootValue,
			}, {
				ChildA = createElement("IntValue", {
					Value = childValue,
				}),

				ChildB = createElement("Folder"),
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local root = parent:GetChildren()[1]

			expect(root.ClassName).to.equal("StringValue")
			expect(root.Value).to.equal(rootValue)
			expect(root.Name).to.equal(key)

			expect(#root:GetChildren()).to.equal(2)

			local childA = root.ChildA
			local childB = root.ChildB

			expect(childA).to.be.ok()
			expect(childB).to.be.ok()

			expect(childA.ClassName).to.equal("IntValue")
			expect(childA.Value).to.equal(childValue)

			expect(childB.ClassName).to.equal("Folder")
		end)

		it("should attach Bindings to Roblox properties", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local binding, update = Binding.create(10)
			local element = createElement("IntValue", {
				Value = binding,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(instance.ClassName).to.equal("IntValue")
			expect(instance.Value).to.equal(10)

			update(20)

			expect(instance.Value).to.equal(20)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should connect Binding refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local ref = createRef()
			local element = createElement("Frame", {
				[Ref] = ref,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(ref.current).to.be.ok()
			expect(ref.current).to.equal(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should call function refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRef = createSpy()
			local element = createElement("Frame", {
				[Ref] = spyRef.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(spyRef.callCount).to.equal(1)
			spyRef:assertCalledWith(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should throw if setting invalid instance properties", function()
			local configValues = {
				elementTracing = true,
			}

			GlobalConfig.scoped(configValues, function()
				local parent = Instance.new("Folder")
				local key = "Some Key"

				local element = createElement("Frame", {
					Frob = 6,
				})

				local node = reconciler.createVirtualNode(element, parent, key)

				local success, message = pcall(RobloxRenderer.mountHostNode, reconciler, node)
				assert(not success, "Expected call to fail")

				expect(message:find("Frob")).to.be.ok()
				expect(message:find("Frame")).to.be.ok()
				expect(message:find("RobloxRenderer%.spec")).to.be.ok()
			end)
		end)
	end)

	describe("updateHostNode", function()
		it("should update node props and children", function()
			-- TODO: Break up test

			local parent = Instance.new("Folder")
			local key = "updateHostNodeTest"
			local firstValue = "foo"
			local newValue = "bar"

			local defaultStringValue = Instance.new("StringValue").Value

			local element = createElement("StringValue", {
				Value = firstValue
			}, {
				ChildA = createElement("IntValue", {
					Value = 1
				}),
				ChildB = createElement("BoolValue", {
					Value = true,
				}),
				ChildC = createElement("StringValue", {
					Value = "test",
				}),
				ChildD = createElement("StringValue", {
					Value = "test",
				})
			})

			local node = reconciler.createVirtualNode(element, parent, key)
			RobloxRenderer.mountHostNode(reconciler, node)

			-- Not testing mountHostNode's work here, only testing that the
			-- node is properly updated.

			local newElement = createElement("StringValue", {
				Value = newValue,
			}, {
				-- ChildA changes element type.
				ChildA = createElement("StringValue", {
					Value = "test"
				}),
				-- ChildB changes child properties.
				ChildB = createElement("BoolValue", {
					Value = false,
				}),
				-- ChildC should reset its Value property back to the default.
				ChildC = createElement("StringValue", {}),
				-- ChildD is deleted.
				-- ChildE is added.
				ChildE = createElement("Folder", {}),
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			local root = parent[key]
			expect(root.ClassName).to.equal("StringValue")
			expect(root.Value).to.equal(newValue)
			expect(#root:GetChildren()).to.equal(4)

			local childA = root.ChildA
			expect(childA.ClassName).to.equal("StringValue")
			expect(childA.Value).to.equal("test")

			local childB = root.ChildB
			expect(childB.ClassName).to.equal("BoolValue")
			expect(childB.Value).to.equal(false)

			local childC = root.ChildC
			expect(childC.ClassName).to.equal("StringValue")
			expect(childC.Value).to.equal(defaultStringValue)

			local childE = root.ChildE
			expect(childE.ClassName).to.equal("Folder")
		end)

		it("should update Bindings", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local bindingA, updateA = Binding.create(10)
			local element = createElement("IntValue", {
				Value = bindingA,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			local instance = parent:GetChildren()[1]

			expect(instance.Value).to.equal(10)

			local bindingB, updateB = Binding.create(99)
			local newElement = createElement("IntValue", {
				Value = bindingB,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			expect(instance.Value).to.equal(99)

			updateA(123)

			expect(instance.Value).to.equal(99)

			updateB(123)

			expect(instance.Value).to.equal(123)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should update Binding refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local refA = createRef()
			local refB = createRef()

			local element = createElement("Frame", {
				[Ref] = refA,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(refA.current).to.equal(instance)
			expect(refB.current).never.to.be.ok()

			local newElement = createElement("Frame", {
				[Ref] = refB,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			expect(refA.current).never.to.be.ok()
			expect(refB.current).to.equal(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should call old function refs with nil and new function refs with a valid rbx", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRefA = createSpy()
			local spyRefB = createSpy()

			local element = createElement("Frame", {
				[Ref] = spyRefA.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(spyRefA.callCount).to.equal(1)
			spyRefA:assertCalledWith(instance)
			expect(spyRefB.callCount).to.equal(0)

			local newElement = createElement("Frame", {
				[Ref] = spyRefB.value,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			expect(spyRefA.callCount).to.equal(2)
			spyRefA:assertCalledWith(nil)
			expect(spyRefB.callCount).to.equal(1)
			spyRefB:assertCalledWith(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should not call function refs again if they didn't change", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRef = createSpy()

			local element = createElement("Frame", {
				Size = UDim2.new(1, 0, 1, 0),
				[Ref] = spyRef.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(spyRef.callCount).to.equal(1)
			spyRef:assertCalledWith(instance)

			local newElement = createElement("Frame", {
				Size = UDim2.new(0.5, 0, 0.5, 0),
				[Ref] = spyRef.value,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			-- Not called again
			expect(spyRef.callCount).to.equal(1)
		end)

		it("should throw if setting invalid instance properties", function()
			local configValues = {
				elementTracing = true,
			}

			GlobalConfig.scoped(configValues, function()
				local parent = Instance.new("Folder")
				local key = "Some Key"

				local firstElement = createElement("Frame")
				local secondElement = createElement("Frame", {
					Frob = 6,
				})

				local node = reconciler.createVirtualNode(firstElement, parent, key)
				RobloxRenderer.mountHostNode(reconciler, node)

				local success, message = pcall(RobloxRenderer.updateHostNode, reconciler, node, secondElement)
				assert(not success, "Expected call to fail")

				expect(message:find("Frob")).to.be.ok()
				expect(message:find("Frame")).to.be.ok()
				expect(message:find("RobloxRenderer%.spec")).to.be.ok()
			end)
		end)

		it("should delete instances when reconciling to nil children", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local element = createElement("Frame", {
				Size = UDim2.new(1, 0, 1, 0),
			}, {
				child = createElement("Frame"),
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]
			expect(#instance:GetChildren()).to.equal(1)

			local newElement = createElement("Frame", {
				Size = UDim2.new(0.5, 0, 0.5, 0),
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)
			expect(#instance:GetChildren()).to.equal(0)
		end)
	end)

	describe("unmountHostNode", function()
		it("should delete instances from the inside-out", function()
			local parent = Instance.new("Folder")
			local key = "Root"
			local element = createElement("Folder", nil, {
				Child = createElement("Folder", nil, {
					Grandchild = createElement("Folder"),
				}),
			})

			local node = reconciler.mountVirtualNode(element, parent, key)

			expect(#parent:GetChildren()).to.equal(1)

			local root = parent:GetChildren()[1]
			expect(#root:GetChildren()).to.equal(1)

			local child = root:GetChildren()[1]
			expect(#child:GetChildren()).to.equal(1)

			local grandchild = child:GetChildren()[1]

			RobloxRenderer.unmountHostNode(reconciler, node)

			expect(grandchild.Parent).to.equal(nil)
			expect(child.Parent).to.equal(nil)
			expect(root.Parent).to.equal(nil)
		end)

		it("should unsubscribe from any Bindings", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local binding, update = Binding.create(10)
			local element = createElement("IntValue", {
				Value = binding,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			local instance = parent:GetChildren()[1]

			expect(instance.Value).to.equal(10)

			RobloxRenderer.unmountHostNode(reconciler, node)
			update(56)

			expect(instance.Value).to.equal(10)
		end)

		it("should clear Binding refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local ref = createRef()
			local element = createElement("Frame", {
				[Ref] = ref,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(ref.current).to.be.ok()

			RobloxRenderer.unmountHostNode(reconciler, node)

			expect(ref.current).never.to.be.ok()
		end)

		it("should call function refs with nil", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRef = createSpy()
			local element = createElement("Frame", {
				[Ref] = spyRef.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(spyRef.callCount).to.equal(1)

			RobloxRenderer.unmountHostNode(reconciler, node)

			expect(spyRef.callCount).to.equal(2)
			spyRef:assertCalledWith(nil)
		end)
	end)

	describe("Portals", function()
		it("should create and destroy instances as children of `target`", function()
			local target = Instance.new("Folder")

			local function FunctionComponent(props)
				return createElement("IntValue", {
					Value = props.value,
				})
			end

			local element = createElement(Portal, {
				target = target,
			}, {
				folderOne = createElement("Folder"),
				folderTwo = createElement("Folder"),
				intValueOne = createElement(FunctionComponent, {
					value = 42,
				}),
			})
			local hostParent = nil
			local hostKey = "Some Key"
			local node = reconciler.mountVirtualNode(element, hostParent, hostKey)

			expect(#target:GetChildren()).to.equal(3)

			expect(target:FindFirstChild("folderOne")).to.be.ok()
			expect(target:FindFirstChild("folderTwo")).to.be.ok()
			expect(target:FindFirstChild("intValueOne")).to.be.ok()
			expect(target:FindFirstChild("intValueOne").Value).to.equal(42)

			reconciler.unmountVirtualNode(node)

			expect(#target:GetChildren()).to.equal(0)
		end)

		it("should pass prop updates through to children", function()
			local target = Instance.new("Folder")

			local firstElement = createElement(Portal, {
				target = target,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 1,
				}),
			})

			local secondElement = createElement(Portal, {
				target = target,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 2,
				}),
			})

			local hostParent = nil
			local hostKey = "A Host Key"
			local node = reconciler.mountVirtualNode(firstElement, hostParent, hostKey)

			expect(#target:GetChildren()).to.equal(1)

			local firstValue = target.ChildValue
			expect(firstValue.Value).to.equal(1)

			node = reconciler.updateVirtualNode(node, secondElement)

			expect(#target:GetChildren()).to.equal(1)

			local secondValue = target.ChildValue
			expect(firstValue).to.equal(secondValue)
			expect(secondValue.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#target:GetChildren()).to.equal(0)
		end)

		it("should throw if `target` is nil", function()
			-- TODO: Relax this restriction?
			local element = createElement(Portal)
			local hostParent = nil
			local hostKey = "Keys for Everyone"

			expect(function()
				reconciler.mountVirtualNode(element, hostParent, hostKey)
			end).to.throw()
		end)

		it("should throw if `target` is not a Roblox instance", function()
			local element = createElement(Portal, {
				target = {},
			})
			local hostParent = nil
			local hostKey = "Unleash the keys!"

			expect(function()
				reconciler.mountVirtualNode(element, hostParent, hostKey)
			end).to.throw()
		end)

		it("should recreate instances if `target` changes in an update", function()
			local firstTarget = Instance.new("Folder")
			local secondTarget = Instance.new("Folder")

			local firstElement = createElement(Portal, {
				target = firstTarget,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 1,
				}),
			})

			local secondElement = createElement(Portal, {
				target = secondTarget,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 2,
				}),
			})

			local hostParent = nil
			local hostKey = "Some Key"
			local node = reconciler.mountVirtualNode(firstElement, hostParent, hostKey)

			expect(#firstTarget:GetChildren()).to.equal(1)
			expect(#secondTarget:GetChildren()).to.equal(0)

			local firstChild = firstTarget.ChildValue
			expect(firstChild.Value).to.equal(1)

			node = reconciler.updateVirtualNode(node, secondElement)

			expect(#firstTarget:GetChildren()).to.equal(0)
			expect(#secondTarget:GetChildren()).to.equal(1)

			local secondChild = secondTarget.ChildValue
			expect(secondChild.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#firstTarget:GetChildren()).to.equal(0)
			expect(#secondTarget:GetChildren()).to.equal(0)
		end)
	end)

	describe("Fragments", function()
		it("should parent the fragment's elements into the fragment's parent", function()
			local hostParent = Instance.new("Folder")

			local fragment = createFragment({
				key = createElement("IntValue", {
					Value = 1,
				}),
				key2 = createElement("IntValue", {
					Value = 2,
				}),
			})

			local node = reconciler.mountVirtualNode(fragment, hostParent, "test")

			expect(hostParent:FindFirstChild("key")).to.be.ok()
			expect(hostParent.key.ClassName).to.equal("IntValue")
			expect(hostParent.key.Value).to.equal(1)

			expect(hostParent:FindFirstChild("key2")).to.be.ok()
			expect(hostParent.key2.ClassName).to.equal("IntValue")
			expect(hostParent.key2.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)

		it("should allow sibling fragment to have common keys", function()
			local hostParent = Instance.new("Folder")
			local hostKey = "Test"

			local function parent(props)
				return createElement("IntValue", {}, {
					fragmentA = createFragment({
						key = createElement("StringValue", {
							Value = "A",
						}),
						key2 = createElement("StringValue", {
							Value = "B",
						}),
					}),
					fragmentB = createFragment({
						key = createElement("StringValue", {
							Value = "C",
						}),
						key2 = createElement("StringValue", {
							Value = "D",
						}),
					}),
				})
			end

			local node = reconciler.mountVirtualNode(createElement(parent), hostParent, hostKey)
			local parentChildren = hostParent[hostKey]:GetChildren()

			expect(#parentChildren).to.equal(4)

			local childValues = {}

			for _, child in pairs(parentChildren) do
				expect(child.ClassName).to.equal("StringValue")
				childValues[child.Value] = 1 + (childValues[child.Value] or 0)
			end

			-- check if the StringValues have not collided
			expect(childValues.A).to.equal(1)
			expect(childValues.B).to.equal(1)
			expect(childValues.C).to.equal(1)
			expect(childValues.D).to.equal(1)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)

		it("should render nested fragments", function()
			local hostParent = Instance.new("Folder")

			local fragment = createFragment({
				key = createFragment({
					TheValue = createElement("IntValue", {
						Value = 1,
					}),
					TheOtherValue = createElement("IntValue", {
						Value = 2,
					})
				})
			})

			local node = reconciler.mountVirtualNode(fragment, hostParent, "Test")

			expect(hostParent:FindFirstChild("TheValue")).to.be.ok()
			expect(hostParent.TheValue.ClassName).to.equal("IntValue")
			expect(hostParent.TheValue.Value).to.equal(1)

			expect(hostParent:FindFirstChild("TheOtherValue")).to.be.ok()
			expect(hostParent.TheOtherValue.ClassName).to.equal("IntValue")
			expect(hostParent.TheOtherValue.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)

		it("should not add any instances if the fragment is empty", function()
			local hostParent = Instance.new("Folder")

			local node = reconciler.mountVirtualNode(createFragment({}), hostParent, "test")

			expect(#hostParent:GetChildren()).to.equal(0)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)
	end)

	describe("Context", function()
		it("should pass context values through Roblox host nodes", function()
			local Consumer = Component:extend("Consumer")

			local capturedContext
			function Consumer:init()
				capturedContext = {
					hello = self:__getContext("hello")
				}
			end

			function Consumer:render()
			end

			local element = createElement("Folder", nil, {
				Consumer = createElement(Consumer)
			})
			local hostParent = nil
			local hostKey = "Context Test"
			local context = {
				hello = "world",
			}
			local node = reconciler.mountVirtualNode(element, hostParent, hostKey, context)

			expect(capturedContext).never.to.equal(context)
			assertDeepEqual(capturedContext, context)

			reconciler.unmountVirtualNode(node)
		end)

		it("should pass context values through portal nodes", function()
			local target = Instance.new("Folder")

			local Provider = Component:extend("Provider")

			function Provider:init()
				self:__addContext("foo", "bar")
			end

			function Provider:render()
				return createElement("Folder", nil, self.props[Children])
			end

			local Consumer = Component:extend("Consumer")

			local capturedContext
			function Consumer:init()
				capturedContext = {
					foo = self:__getContext("foo"),
				}
			end

			function Consumer:render()
				return nil
			end

			local element = createElement(Provider, nil, {
				Portal = createElement(Portal, {
					target = target,
				}, {
					Consumer = createElement(Consumer),
				})
			})
			local hostParent = nil
			local hostKey = "Some Key"
			reconciler.mountVirtualNode(element, hostParent, hostKey)

			assertDeepEqual(capturedContext, {
				foo = "bar"
			})
		end)
	end)

	describe("Legacy context", function()
		it("should pass context values through Roblox host nodes", function()
			local Consumer = Component:extend("Consumer")

			local capturedContext
			function Consumer:init()
				capturedContext = self._context
			end

			function Consumer:render()
			end

			local element = createElement("Folder", nil, {
				Consumer = createElement(Consumer)
			})
			local hostParent = nil
			local hostKey = "Context Test"
			local context = {
				hello = "world",
			}
			local node = reconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)

			expect(capturedContext).never.to.equal(context)
			assertDeepEqual(capturedContext, context)

			reconciler.unmountVirtualNode(node)
		end)

		it("should pass context values through portal nodes", function()
			local target = Instance.new("Folder")

			local Provider = Component:extend("Provider")

			function Provider:init()
				self._context.foo = "bar"
			end

			function Provider:render()
				return createElement("Folder", nil, self.props[Children])
			end

			local Consumer = Component:extend("Consumer")

			local capturedContext
			function Consumer:init()
				capturedContext = self._context
			end

			function Consumer:render()
				return nil
			end

			local element = createElement(Provider, nil, {
				Portal = createElement(Portal, {
					target = target,
				}, {
					Consumer = createElement(Consumer),
				})
			})
			local hostParent = nil
			local hostKey = "Some Key"
			reconciler.mountVirtualNode(element, hostParent, hostKey)

			assertDeepEqual(capturedContext, {
				foo = "bar"
			})
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="319">
          <Properties>
            <string name="Name">SingleEventManager</string>
            <string name="Source">--[[
	A manager for a single host virtual node's connected events.
]]

local Logging = require(script.Parent.Logging)

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance)
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return self
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local success, event = pcall(function()
		return self._instance:GetPropertyChangedSignal(key)
	end)

	if not success then
		error(("Cannot get changed signal on property %q: %s"):format(
			tostring(key),
			event
		), 0)
	end

	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	local index = 1

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	while index &lt;= #self._suspendedEventQueue do
		local eventInvocation = self._suspendedEventQueue[index]
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount))

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				Logging.warn("%s", result)
			end
		end

		index = index + 1
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	self._suspendedEventQueue = {}
end

return SingleEventManager</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="320">
          <Properties>
            <string name="Name">SingleEventManager.spec</string>
            <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.assertDeepEqual)
	local createSpy = require(script.Parent.createSpy)
	local Logging = require(script.Parent.Logging)

	local SingleEventManager = require(script.Parent.SingleEventManager)

	describe("new", function()
		it("should create a SingleEventManager", function()
			local manager = SingleEventManager.new()

			expect(manager).to.be.ok()
		end)
	end)

	describe("connectEvent", function()
		it("should connect to events", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)
			manager:resume()

			instance:Fire("foo")
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance, "foo")

			instance:Fire("bar")
			expect(eventSpy.callCount).to.equal(2)
			eventSpy:assertCalledWith(instance, "bar")

			manager:connectEvent("Event", nil)

			instance:Fire("baz")
			expect(eventSpy.callCount).to.equal(2)
		end)

		it("should drop events until resumed initially", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)

			instance:Fire("foo")
			expect(eventSpy.callCount).to.equal(0)

			manager:resume()

			instance:Fire("bar")
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance, "bar")
		end)

		it("should invoke suspended events when resumed", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)
			manager:resume()

			instance:Fire("foo")
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance, "foo")

			manager:suspend()

			instance:Fire("bar")
			expect(eventSpy.callCount).to.equal(1)

			manager:resume()
			expect(eventSpy.callCount).to.equal(2)
			eventSpy:assertCalledWith(instance, "bar")
		end)

		it("should invoke events triggered during resumption in the correct order", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			local recordedValues = {}
			local eventSpy = createSpy(function(_, value)
				table.insert(recordedValues, value)

				if value == 2 then
					instance:Fire(3)
				elseif value == 3 then
					instance:Fire(4)
				end
			end)

			manager:connectEvent("Event", eventSpy.value)
			manager:suspend()

			instance:Fire(1)
			instance:Fire(2)

			manager:resume()
			expect(eventSpy.callCount).to.equal(4)
			assertDeepEqual(recordedValues, {1, 2, 3, 4})
		end)

		it("should not invoke events fired during suspension but disconnected before resumption", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)
			manager:suspend()

			instance:Fire(1)

			manager:connectEvent("Event", nil)

			manager:resume()
			expect(eventSpy.callCount).to.equal(0)
		end)

		it("should not yield events through the SingleEventManager when resuming", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			manager:connectEvent("Event", function()
				coroutine.yield()
			end)

			manager:resume()

			local co = coroutine.create(function()
				instance:Fire(5)
			end)

			assert(coroutine.resume(co))
			expect(coroutine.status(co)).to.equal("dead")

			manager:suspend()
			instance:Fire(5)

			co = coroutine.create(function()
				manager:resume()
			end)

			assert(coroutine.resume(co))
			expect(coroutine.status(co)).to.equal("dead")
		end)

		it("should not throw errors through SingleEventManager when resuming", function()
			local errorText = "Error from SingleEventManager test"

			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			manager:connectEvent("Event", function()
				error(errorText)
			end)

			manager:resume()

			-- If we call instance:Fire() here, the error message will leak to
			-- the console since the thread's resumption will be handled by
			-- Roblox's scheduler.

			manager:suspend()
			instance:Fire(5)

			local logInfo = Logging.capture(function()
				manager:resume()
			end)

			expect(#logInfo.errors).to.equal(0)
			expect(#logInfo.warnings).to.equal(1)
			expect(#logInfo.infos).to.equal(0)

			expect(logInfo.warnings[1]:find(errorText)).to.be.ok()
		end)

		it("should not overflow with events if manager:resume() is invoked when resuming a suspended event", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			-- This connection emulates what happens if reconciliation is
			-- triggered again in response to reconciliation. Without
			-- appropriate guards, the inner resume() call will process the
			-- Fire(1) event again, causing a nasty stack overflow.
			local eventSpy = createSpy(function(_, value)
				if value == 1 then
					manager:suspend()
					instance:Fire(2)
					manager:resume()
				end
			end)

			manager:connectEvent("Event", eventSpy.value)

			manager:suspend()
			instance:Fire(1)
			manager:resume()

			expect(eventSpy.callCount).to.equal(2)
		end)
	end)

	describe("connectPropertyChange", function()
		-- Since property changes utilize the same mechanisms as other events,
		-- the tests here are slimmed down to reduce redundancy.

		it("should connect to property changes", function()
			local instance = Instance.new("Folder")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectPropertyChange("Name", eventSpy.value)
			manager:resume()

			instance.Name = "foo"
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance)

			instance.Name = "bar"
			expect(eventSpy.callCount).to.equal(2)
			eventSpy:assertCalledWith(instance)

			manager:connectPropertyChange("Name")

			instance.Name = "baz"
			expect(eventSpy.callCount).to.equal(2)
		end)

		it("should throw an error if the property is invalid", function()
			local instance = Instance.new("Folder")
			local manager = SingleEventManager.new(instance)

			expect(function()
				manager:connectPropertyChange("foo", function() end)
			end).to.throw()
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="321">
          <Properties>
            <string name="Name">Symbol</string>
            <string name="Source">--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="322">
          <Properties>
            <string name="Name">Symbol.spec</string>
            <string name="Source">return function()
	local Symbol = require(script.Parent.Symbol)

	describe("named", function()
		it("should give an opaque object", function()
			local symbol = Symbol.named("foo")

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to the given name", function()
			local symbol = Symbol.named("foo")

			expect(tostring(symbol):find("foo")).to.be.ok()
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.named("abc")
			local symbolB = Symbol.named("abc")

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="323">
          <Properties>
            <string name="Name">Type</string>
            <string name="Source">--[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("Binding")
addType("Element")
addType("HostChangeEvent")
addType("HostEvent")
addType("StatefulComponentClass")
addType("StatefulComponentInstance")
addType("VirtualNode")
addType("VirtualTree")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

strict(TypeInternal, "Type")

return Type</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="324">
          <Properties>
            <string name="Name">Type.spec</string>
            <string name="Source">return function()
	local Type = require(script.Parent.Type)

	describe("of", function()
		it("should return nil if the value is not a table", function()
			expect(Type.of(1)).to.equal(nil)
			expect(Type.of(true)).to.equal(nil)
			expect(Type.of("test")).to.equal(nil)
			expect(Type.of(print)).to.equal(nil)
		end)

		it("should return nil if the table has no type", function()
			expect(Type.of({})).to.equal(nil)
		end)

		it("should return the assigned type", function()
			local test = {
				[Type] = Type.Element
			}

			expect(Type.of(test)).to.equal(Type.Element)
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="325">
          <Properties>
            <string name="Name">assertDeepEqual</string>
            <string name="Source">--[[
	A utility used to assert that two objects are value-equal recursively. It
	outputs fairly nicely formatted messages to help diagnose why two objects
	would be different.

	This should only be used in tests.
]]

local function deepEqual(a, b)
	if typeof(a) ~= typeof(b) then
		local message = ("{1} is of type %s, but {2} is of type %s"):format(
			typeof(a),
			typeof(b)
		)
		return false, message
	end

	if typeof(a) == "table" then
		local visitedKeys = {}

		for key, value in pairs(a) do
			visitedKeys[key] = true

			local success, innerMessage = deepEqual(value, b[key])
			if not success then
				local message = innerMessage
					:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
					:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

				return false, message
			end
		end

		for key, value in pairs(b) do
			if not visitedKeys[key] then
				local success, innerMessage = deepEqual(value, a[key])

				if not success then
					local message = innerMessage
						:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
						:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

					return false, message
				end
			end
		end

		return true
	end

	if a == b then
		return true
	end

	local message = "{1} ~= {2}"
	return false, message
end

local function assertDeepEqual(a, b)
	local success, innerMessageTemplate = deepEqual(a, b)

	if not success then
		local innerMessage = innerMessageTemplate
			:gsub("{1}", "first")
			:gsub("{2}", "second")

		local message = ("Values were not deep-equal.\n%s"):format(innerMessage)

		error(message, 2)
	end
end

return assertDeepEqual</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="326">
          <Properties>
            <string name="Name">assertDeepEqual.spec</string>
            <string name="Source">return function()
	local assertDeepEqual = require(script.Parent.assertDeepEqual)

	it("should fail with a message when args are not equal", function()
		local success, message = pcall(assertDeepEqual, 1, 2)

		expect(success).to.equal(false)
		expect(message:find("first ~= second")).to.be.ok()

		success, message = pcall(assertDeepEqual, {
			foo = 1,
		}, {
			foo = 2,
		})

		expect(success).to.equal(false)
		expect(message:find("first%[foo%] ~= second%[foo%]")).to.be.ok()
	end)

	it("should compare non-table values using standard '==' equality", function()
		assertDeepEqual(1, 1)
		assertDeepEqual("hello", "hello")
		assertDeepEqual(nil, nil)

		local someFunction = function() end
		local theSameFunction = someFunction

		assertDeepEqual(someFunction, theSameFunction)

		local A = {
			foo = someFunction
		}
		local B = {
			foo = theSameFunction
		}

		assertDeepEqual(A, B)
	end)

	it("should fail when types differ", function()
		local success, message = pcall(assertDeepEqual, 1, "1")

		expect(success).to.equal(false)
		expect(message:find("first is of type number, but second is of type string")).to.be.ok()
	end)

	it("should compare (and report about) nested tables", function()
		local A = {
			foo = "bar",
			nested = {
				foo = 1,
				bar = 2,
			}
		}
		local B = {
			foo = "bar",
			nested = {
				foo = 1,
				bar = 2,
			}
		}

		assertDeepEqual(A, B)

		local C = {
			foo = "bar",
			nested = {
				foo = 1,
				bar = 3,
			}
		}

		local success, message = pcall(assertDeepEqual, A, C)

		expect(success).to.equal(false)
		expect(message:find("first%[nested%]%[bar%] ~= second%[nested%]%[bar%]")).to.be.ok()
	end)

	it("should be commutative", function()
		local equalArgsA = {
			foo = "bar",
			hello = "world",
		}
		local equalArgsB = {
			foo = "bar",
			hello = "world",
		}

		assertDeepEqual(equalArgsA, equalArgsB)
		assertDeepEqual(equalArgsB, equalArgsA)

		local nonEqualArgs = {
			foo = "bar",
		}

		expect(function() assertDeepEqual(equalArgsA, nonEqualArgs) end).to.throw()
		expect(function() assertDeepEqual(nonEqualArgs, equalArgsA) end).to.throw()
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="327">
          <Properties>
            <string name="Name">assign</string>
            <string name="Source">local None = require(script.Parent.None)

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
local function assign(target, ...)
	for index = 1, select("#", ...) do
		local source = select(index, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					target[key] = nil
				else
					target[key] = value
				end
			end
		end
	end

	return target
end

return assign</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="328">
          <Properties>
            <string name="Name">assign.spec</string>
            <string name="Source">return function()
	local None = require(script.Parent.None)

	local assign = require(script.Parent.assign)

	it("should accept zero additional tables", function()
		local input = {}
		local result = assign(input)

		expect(input).to.equal(result)
	end)

	it("should merge multiple tables onto the given target table", function()
		local target = {
			a = 5,
			b = 6,
		}

		local source1 = {
			b = 7,
			c = 8,
		}

		local source2 = {
			b = 8,
		}

		assign(target, source1, source2)

		expect(target.a).to.equal(5)
		expect(target.b).to.equal(source2.b)
		expect(target.c).to.equal(source1.c)
	end)

	it("should remove keys if specified as None", function()
		local target = {
			foo = 2,
			bar = 3,
		}

		local source = {
			foo = None,
		}

		assign(target, source)

		expect(target.foo).to.equal(nil)
		expect(target.bar).to.equal(3)
	end)

	it("should re-add keys if specified after None", function()
		local target = {
			foo = 2,
		}

		local source1 = {
			foo = None,
		}

		local source2 = {
			foo = 3,
		}

		assign(target, source1, source2)

		expect(target.foo).to.equal(source2.foo)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="329">
          <Properties>
            <string name="Name">createContext</string>
            <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local createFragment = require(script.Parent.createFragment)
local createSignal = require(script.Parent.createSignal)
local Children = require(script.Parent.PropMarkers.Children)
local Component = require(script.Parent.Component)

--[[
	Construct the value that is assigned to Roact's context storage.
]]
local function createContextEntry(currentValue)
	return {
		value = currentValue,
		onUpdate = createSignal(),
	}
end

local function createProvider(context)
	local Provider = Component:extend("Provider")

	function Provider:init(props)
		self.contextEntry = createContextEntry(props.value)
		self:__addContext(context.key, self.contextEntry)
	end

	function Provider:willUpdate(nextProps)
		-- If the provided value changed, immediately update the context entry.
		--
		-- During this update, any components that are reachable will receive
		-- this updated value at the same time as any props and state updates
		-- that are being applied.
		if nextProps.value ~= self.props.value then
			self.contextEntry.value = nextProps.value
		end
	end

	function Provider:didUpdate(prevProps)
		-- If the provided value changed, after we've updated every reachable
		-- component, fire a signal to update the rest.
		--
		-- This signal will notify all context consumers. It's expected that
		-- they will compare the last context value they updated with and only
		-- trigger an update on themselves if this value is different.
		--
		-- This codepath will generally only update consumer components that has
		-- a component implementing shouldUpdate between them and the provider.
		if prevProps.value ~= self.props.value then
			self.contextEntry.onUpdate:fire(self.props.value)
		end
	end

	function Provider:render()
		return createFragment(self.props[Children])
	end

	return Provider
end

local function createConsumer(context)
	local Consumer = Component:extend("Consumer")

	function Consumer.validateProps(props)
		if type(props.render) ~= "function" then
			return false, "Consumer expects a `render` function"
		else
			return true
		end
	end

	function Consumer:init(props)
		-- This value may be nil, which indicates that our consumer is not a
		-- descendant of a provider for this context item.
		self.contextEntry = self:__getContext(context.key)
	end

	function Consumer:render()
		-- Render using the latest available for this context item.
		--
		-- We don't store this value in state in order to have more fine-grained
		-- control over our update behavior.
		local value
		if self.contextEntry ~= nil then
			value = self.contextEntry.value
		else
			value = context.defaultValue
		end

		return self.props.render(value)
	end

	function Consumer:didUpdate()
		-- Store the value that we most recently updated with.
		--
		-- This value is compared in the contextEntry onUpdate hook below.
		if self.contextEntry ~= nil then
			self.lastValue = self.contextEntry.value
		end
	end

	function Consumer:didMount()
		if self.contextEntry ~= nil then
			-- When onUpdate is fired, a new value has been made available in
			-- this context entry, but we may have already updated in the same
			-- update cycle.
			--
			-- To avoid sending a redundant update, we compare the new value
			-- with the last value that we updated with (set in didUpdate) and
			-- only update if they differ. This may happen when an update from a
			-- provider was blocked by an intermediate component that returned
			-- false from shouldUpdate.
			self.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)
				if newValue ~= self.lastValue then
					-- Trigger a dummy state update.
					self:setState({})
				end
			end)
		end
	end

	function Consumer:willUnmount()
		if self.disconnect ~= nil then
			self.disconnect()
		end
	end

	return Consumer
end

local Context = {}
Context.__index = Context

function Context.new(defaultValue)
	return setmetatable({
		defaultValue = defaultValue,
		key = Symbol.named("ContextKey"),
	}, Context)
end

function Context:__tostring()
	return "RoactContext"
end

local function createContext(defaultValue)
	local context = Context.new(defaultValue)

	return {
		Provider = createProvider(context),
		Consumer = createConsumer(context),
	}
end

return createContext
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="330">
          <Properties>
            <string name="Name">createContext.spec</string>
            <string name="Source">return function()
	local Component = require(script.Parent.Component)
	local NoopRenderer = require(script.Parent.NoopRenderer)
	local Children = require(script.Parent.PropMarkers.Children)
	local createContext = require(script.Parent.createContext)
	local createElement = require(script.Parent.createElement)
	local createFragment = require(script.Parent.createFragment)
	local createReconciler = require(script.Parent.createReconciler)
	local createSpy = require(script.Parent.createSpy)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should return a table", function()
		local context = createContext("Test")
		expect(context).to.be.ok()
		expect(type(context)).to.equal("table")
	end)

	it("should contain a Provider and a Consumer", function()
		local context = createContext("Test")
		expect(context.Provider).to.be.ok()
		expect(context.Consumer).to.be.ok()
	end)

	describe("Provider", function()
		it("should render its children", function()
			local context = createContext("Test")

			local Listener = createSpy(function()
				return nil
			end)

			local element = createElement(context.Provider, {
				value = "Test",
			}, {
				Listener = createElement(Listener.value),
			})

			local tree = noopReconciler.mountVirtualTree(element, nil, "Provide Tree")
			noopReconciler.unmountVirtualTree(tree)

			expect(Listener.callCount).to.equal(1)
		end)
	end)

	describe("Consumer", function()
		it("should expect a render function", function()
			local context = createContext("Test")
			local element = createElement(context.Consumer)

			expect(function()
				noopReconciler.mountVirtualTree(element, nil, "Provide Tree")
			end).to.throw()
		end)

		it("should return the default value if there is no Provider", function()
			local valueSpy = createSpy()
			local context = createContext("Test")

			local element = createElement(context.Consumer, {
				render = valueSpy.value,
			})

			local tree = noopReconciler.mountVirtualTree(element, nil, "Provide Tree")
			noopReconciler.unmountVirtualTree(tree)

			valueSpy:assertCalledWith("Test")
		end)

		it("should pass the value to the render function", function()
			local valueSpy = createSpy()
			local context = createContext("Test")

			local function Listener()
				return createElement(context.Consumer, {
					render = valueSpy.value,
				})
			end

			local element = createElement(context.Provider, {
				value = "NewTest",
			}, {
				Listener = createElement(Listener),
			})

			local tree = noopReconciler.mountVirtualTree(element, nil, "Provide Tree")
			noopReconciler.unmountVirtualTree(tree)

			valueSpy:assertCalledWith("NewTest")
		end)

		it("should update when the value updates", function()
			local valueSpy = createSpy()
			local context = createContext("Test")

			local function Listener()
				return createElement(context.Consumer, {
					render = valueSpy.value,
				})
			end

			local element = createElement(context.Provider, {
				value = "NewTest",
			}, {
				Listener = createElement(Listener),
			})

			local tree = noopReconciler.mountVirtualTree(element, nil, "Provide Tree")

			expect(valueSpy.callCount).to.equal(1)
			valueSpy:assertCalledWith("NewTest")

			noopReconciler.updateVirtualTree(tree, createElement(context.Provider, {
				value = "ThirdTest",
			}, {
				Listener = createElement(Listener),
			}))

			expect(valueSpy.callCount).to.equal(2)
			valueSpy:assertCalledWith("ThirdTest")

			noopReconciler.unmountVirtualTree(tree)
		end)

		--[[
			This test is the same as the one above, but with a component that
			always blocks updates in the middle. We expect behavior to be the
			same.
		]]
		it("should update when the value updates through an update blocking component", function()
			local valueSpy = createSpy()
			local context = createContext("Test")

			local UpdateBlocker = Component:extend("UpdateBlocker")

			function UpdateBlocker:render()
				return createFragment(self.props[Children])
			end

			function UpdateBlocker:shouldUpdate()
				return false
			end

			local function Listener()
				return createElement(context.Consumer, {
					render = valueSpy.value,
				})
			end

			local element = createElement(context.Provider, {
				value = "NewTest",
			}, {
				Blocker = createElement(UpdateBlocker, nil, {
					Listener = createElement(Listener),
				}),
			})

			local tree = noopReconciler.mountVirtualTree(element, nil, "Provide Tree")

			expect(valueSpy.callCount).to.equal(1)
			valueSpy:assertCalledWith("NewTest")

			noopReconciler.updateVirtualTree(tree, createElement(context.Provider, {
				value = "ThirdTest",
			}, {
				Blocker = createElement(UpdateBlocker, nil, {
					Listener = createElement(Listener),
				}),
			}))

			expect(valueSpy.callCount).to.equal(2)
			valueSpy:assertCalledWith("ThirdTest")

			noopReconciler.unmountVirtualTree(tree)
		end)

		it("should behave correctly when the default value is nil", function()
			local context = createContext(nil)

			local valueSpy = createSpy()
			local function Listener()
				return createElement(context.Consumer, {
					render = valueSpy.value,
				})
			end

			local tree = noopReconciler.mountVirtualTree(createElement(Listener), nil, "Provide Tree")
			expect(valueSpy.callCount).to.equal(1)
			valueSpy:assertCalledWith(nil)

			tree = noopReconciler.updateVirtualTree(tree, createElement(Listener))
			noopReconciler.unmountVirtualTree(tree)

			expect(valueSpy.callCount).to.equal(2)
			valueSpy:assertCalledWith(nil)
		end)
	end)

	describe("Update order", function()
		--[[
			This test ensures that there is no scenario where we can observe
			'update tearing' when props and context are updated at the same
			time.

			Update tearing is scenario where a single update is partially
			applied in multiple steps instead of atomically. This is observable
			by components and can lead to strange bugs or errors.

			This instance of update tearing happens when updating a prop and a
			context value in the same update. Image we represent our tree's
			state as the current prop and context versions. Our initial state
			is:

			(prop_1, context_1)

			The next state we would like to update to is:

			(prop_2, context_2)

			Under the bug reported in issue 259, Roact reaches three different
			states in sequence:

			1: (prop_1, context_1) - the initial state
			2: (prop_2, context_1) - woops!
			3: (prop_2, context_2) - correct end state

			In state 2, a user component was added that tried to access the
			current context value, which was not set at the time. This raised an
			error, because this state is not valid!

			The first proposed solution was to move the context update to happen
			before the props update. It is easy to show that this will still
			result in update tearing:

			1: (prop_1, context_1)
			2: (prop_1, context_2)
			3: (prop_2, context_2)

			Although the initial concern about newly added components observing
			old context values is fixed, there is still a state
			desynchronization between props and state.

			We would instead like the following update sequence:

			1: (prop_1, context_1)
			2: (prop_2, context_2)

			This test tries to ensure that is the case.

			The initial bug report is here:
			https://github.com/Roblox/roact/issues/259
		]]
		it("should update context at the same time as props", function()
			-- These values are used to make sure we reach both the first and
			-- second state combinations we want to visit.
			local observedA = false
			local observedB = false
			local updateCount = 0

			local context = createContext("default")

			local function Listener(props)
				return createElement(context.Consumer, {
					render = function(value)
						updateCount = updateCount + 1

						if value == "context_1" then
							expect(props.someProp).to.equal("prop_1")
							observedA = true
						elseif value == "context_2" then
							expect(props.someProp).to.equal("prop_2")
							observedB = true
						else
							error("Unexpected context value")
						end
					end,
				})
			end

			local element1 = createElement(context.Provider, {
				value = "context_1",
			}, {
				Child = createElement(Listener, {
					someProp = "prop_1",
				}),
			})

			local element2 = createElement(context.Provider, {
				value = "context_2",
			}, {
				Child = createElement(Listener, {
					someProp = "prop_2",
				}),
			})

			local tree = noopReconciler.mountVirtualTree(element1, nil, "UpdateObservationIsFun")
			noopReconciler.updateVirtualTree(tree, element2)

			expect(updateCount).to.equal(2)
			expect(observedA).to.equal(true)
			expect(observedB).to.equal(true)
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="331">
          <Properties>
            <string name="Name">createElement</string>
            <string name="Source">local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local Logging = require(script.Parent.Logging)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local multipleChildrenMessage = [[
The prop `Roact.Children` was defined but was overriden by the third parameter to createElement!
This can happen when a component passes props through to a child element but also uses the `children` argument:

	Roact.createElement("Frame", passedProps, {
		child = ...
	})

Instead, consider using a utility function to merge tables of children together:

	local children = mergeTables(passedProps[Roact.Children], {
		child = ...
	})

	local fullProps = mergeTables(passedProps, {
		[Roact.Children] = children
	})

	Roact.createElement("Frame", fullProps)]]

--[[
	Creates a new element representing the given component.

	Elements are lightweight representations of what a component instance should
	look like.

	Children is a shorthand for specifying `Roact.Children` as a key inside
	props. If specified, the passed `props` table is mutated!
]]
local function createElement(component, props, children)
	if config.typeChecks then
		assert(component ~= nil, "`component` is required")
		assert(typeof(props) == "table" or props == nil, "`props` must be a table or nil")
		assert(typeof(children) == "table" or children == nil, "`children` must be a table or nil")
	end

	if props == nil then
		props = {}
	end

	if children ~= nil then
		if props[Children] ~= nil then
			Logging.warnOnce(multipleChildrenMessage)
		end

		props[Children] = children
	end

	local elementKind = ElementKind.fromComponent(component)

	local element = {
		[Type] = Type.Element,
		[ElementKind] = elementKind,
		component = component,
		props = props,
	}

	if config.elementTracing then
		-- We trim out the leading newline since there's no way to specify the
		-- trace level without also specifying a message.
		element.source = debug.traceback("", 2):sub(2)
	end

	return element
end

return createElement</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="332">
          <Properties>
            <string name="Name">createElement.spec</string>
            <string name="Source">return function()
	local Component = require(script.Parent.Component)
	local ElementKind = require(script.Parent.ElementKind)
	local GlobalConfig = require(script.Parent.GlobalConfig)
	local Logging = require(script.Parent.Logging)
	local Type = require(script.Parent.Type)
	local Portal = require(script.Parent.Portal)
	local Children = require(script.Parent.PropMarkers.Children)

	local createElement = require(script.Parent.createElement)

	it("should create new primitive elements", function()
		local element = createElement("Frame")

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Host)
	end)

	it("should create new functional elements", function()
		local element = createElement(function()
		end)

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Function)
	end)

	it("should create new stateful components", function()
		local Foo = Component:extend("Foo")

		local element = createElement(Foo)

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Stateful)
	end)

	it("should create new portal elements", function()
		local element = createElement(Portal)

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Portal)
	end)

	it("should accept props", function()
		local element = createElement("StringValue", {
			Value = "Foo",
		})

		expect(element).to.be.ok()
		expect(element.props.Value).to.equal("Foo")
	end)

	it("should accept props and children", function()
		local child = createElement("IntValue")

		local element = createElement("StringValue", {
			Value = "Foo",
		}, {
			Child = child,
		})

		expect(element).to.be.ok()
		expect(element.props.Value).to.equal("Foo")
		expect(element.props[Children]).to.be.ok()
		expect(element.props[Children].Child).to.equal(child)
	end)

	it("should accept children with without props", function()
		local child = createElement("IntValue")

		local element = createElement("StringValue", nil, {
			Child = child,
		})

		expect(element).to.be.ok()
		expect(element.props[Children]).to.be.ok()
		expect(element.props[Children].Child).to.equal(child)
	end)

	it("should warn once if children is specified in two different ways", function()
		local logInfo = Logging.capture(function()
			-- Using a loop here to ensure that multiple occurences of the same
			-- warning only cause output once.
			for _ = 1, 2 do
				createElement("Frame", {
					[Children] = {},
				}, {})
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("createElement")).to.be.ok()
		expect(logInfo.warnings[1]:find("Children")).to.be.ok()
	end)

	it("should have a `source` member if elementTracing is set", function()
		local config = {
			elementTracing = true,
		}

		GlobalConfig.scoped(config, function()
			local element = createElement("StringValue")

			expect(element.source).to.be.a("string")
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="333">
          <Properties>
            <string name="Name">createFragment</string>
            <string name="Source">local ElementKind = require(script.Parent.ElementKind)
local Type = require(script.Parent.Type)

local function createFragment(elements)
	return {
		[Type] = Type.Element,
		[ElementKind] = ElementKind.Fragment,
		elements = elements,
	}
end

return createFragment</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="334">
          <Properties>
            <string name="Name">createFragment.spec</string>
            <string name="Source">return function()
	local ElementKind = require(script.Parent.ElementKind)
	local Type = require(script.Parent.Type)

	local createFragment = require(script.Parent.createFragment)

	it("should create new primitive elements", function()
		local fragment = createFragment({})

		expect(fragment).to.be.ok()
		expect(Type.of(fragment)).to.equal(Type.Element)
		expect(ElementKind.of(fragment)).to.equal(ElementKind.Fragment)
	end)

	it("should accept children", function()
		local subFragment = createFragment({})
		local fragment = createFragment({key = subFragment})

		expect(fragment.elements.key).to.equal(subFragment)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="335">
          <Properties>
            <string name="Name">createReconciler</string>
            <string name="Source"><![CDATA[local Type = require(script.Parent.Type)
local ElementKind = require(script.Parent.ElementKind)
local ElementUtils = require(script.Parent.ElementUtils)
local Children = require(script.Parent.PropMarkers.Children)
local Symbol = require(script.Parent.Symbol)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local InternalData = Symbol.named("InternalData")

--[[
	The reconciler is the mechanism in Roact that constructs the virtual tree
	that later gets turned into concrete objects by the renderer.

	Roact's reconciler is constructed with the renderer as an argument, which
	enables switching to different renderers for different platforms or
	scenarios.

	When testing the reconciler itself, it's common to use `NoopRenderer` with
	spies replacing some methods. The default (and only) reconciler interface
	exposed by Roact right now uses `RobloxRenderer`.
]]
local function createReconciler(renderer)
	local reconciler
	local mountVirtualNode
	local updateVirtualNode
	local unmountVirtualNode

	--[[
		Unmount the given virtualNode, replacing it with a new node described by
		the given element.

		Preserves host properties, depth, and legacyContext from parent.
	]]
	local function replaceVirtualNode(virtualNode, newElement)
		local hostParent = virtualNode.hostParent
		local hostKey = virtualNode.hostKey
		local depth = virtualNode.depth

		-- If the node that is being replaced has modified context, we need to
		-- use the original *unmodified* context for the new node
		-- The `originalContext` field will be nil if the context was unchanged
		local context = virtualNode.originalContext or virtualNode.context
		local parentLegacyContext = virtualNode.parentLegacyContext

		unmountVirtualNode(virtualNode)
		local newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)

		-- mountVirtualNode can return nil if the element is a boolean
		if newNode ~= nil then
			newNode.depth = depth
		end

		return newNode
	end

	--[[
		Utility to update the children of a virtual node based on zero or more
		updated children given as elements.
	]]
	local function updateChildren(virtualNode, hostParent, newChildElements)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local removeKeys = {}

		-- Changed or removed children
		for childKey, childNode in pairs(virtualNode.children) do
			local newElement = ElementUtils.getElementByKey(newChildElements, childKey)
			local newNode = updateVirtualNode(childNode, newElement)

			if newNode ~= nil then
				virtualNode.children[childKey] = newNode
			else
				removeKeys[childKey] = true
			end
		end

		for childKey in pairs(removeKeys) do
			virtualNode.children[childKey] = nil
		end

		-- Added children
		for childKey, newElement in ElementUtils.iterateElements(newChildElements) do
			local concreteKey = childKey
			if childKey == ElementUtils.UseParentKey then
				concreteKey = virtualNode.hostKey
			end

			if virtualNode.children[childKey] == nil then
				local childNode = mountVirtualNode(
					newElement,
					hostParent,
					concreteKey,
					virtualNode.context,
					virtualNode.legacyContext
				)

				-- mountVirtualNode can return nil if the element is a boolean
				if childNode ~= nil then
					childNode.depth = virtualNode.depth + 1
					virtualNode.children[childKey] = childNode
				end
			end
		end
	end

	local function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)
		updateChildren(virtualNode, hostParent, newChildElements)
	end

	local function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)
		if Type.of(renderResult) == Type.Element
			or renderResult == nil
			or typeof(renderResult) == "boolean"
		then
			updateChildren(virtualNode, hostParent, renderResult)
		else
			error(("%s\n%s"):format(
				"Component returned invalid children:",
				virtualNode.currentElement.source or "<enable element tracebacks>"
			), 0)
		end
	end

	--[[
		Unmounts the given virtual node and releases any held resources.
	]]
	function unmountVirtualNode(virtualNode)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local kind = ElementKind.of(virtualNode.currentElement)

		if kind == ElementKind.Host then
			renderer.unmountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Stateful then
			virtualNode.instance:__unmount()
		elseif kind == ElementKind.Portal then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Fragment then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end
	end

	local function updateFunctionVirtualNode(virtualNode, newElement)
		local children = newElement.component(newElement.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)

		return virtualNode
	end

	local function updatePortalVirtualNode(virtualNode, newElement)
		local oldElement = virtualNode.currentElement
		local oldTargetHostParent = oldElement.props.target

		local targetHostParent = newElement.props.target

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		if targetHostParent ~= oldTargetHostParent then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local children = newElement.props[Children]

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)

		return virtualNode
	end

	local function updateFragmentVirtualNode(virtualNode, newElement)
		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)

		return virtualNode
	end

	--[[
		Update the given virtual node using a new element describing what it
		should transform into.

		`updateVirtualNode` will return a new virtual node that should replace
		the passed in virtual node. This is because a virtual node can be
		updated with an element referencing a different component!

		In that case, `updateVirtualNode` will unmount the input virtual node,
		mount a new virtual node, and return it in this case, while also issuing
		a warning to the user.
	]]
	function updateVirtualNode(virtualNode, newElement, newState)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end
		if config.typeChecks then
			assert(
				Type.of(newElement) == Type.Element or typeof(newElement) == "boolean" or newElement == nil,
				"Expected arg #2 to be of type Element, boolean, or nil"
			)
		end

		-- If nothing changed, we can skip this update
		if virtualNode.currentElement == newElement and newState == nil then
			return virtualNode
		end

		if typeof(newElement) == "boolean" or newElement == nil then
			unmountVirtualNode(virtualNode)
			return nil
		end

		if virtualNode.currentElement.component ~= newElement.component then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local kind = ElementKind.of(newElement)

		local shouldContinueUpdate = true

		if kind == ElementKind.Host then
			virtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)
		elseif kind == ElementKind.Function then
			virtualNode = updateFunctionVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Stateful then
			shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)
		elseif kind == ElementKind.Portal then
			virtualNode = updatePortalVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Fragment then
			virtualNode = updateFragmentVirtualNode(virtualNode, newElement)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		-- Stateful components can abort updates via shouldUpdate. If that
		-- happens, we should stop doing stuff at this point.
		if not shouldContinueUpdate then
			return virtualNode
		end

		virtualNode.currentElement = newElement

		return virtualNode
	end

	--[[
		Constructs a new virtual node but not does mount it.
	]]
	local function createVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		return {
			[Type] = Type.VirtualNode,
			currentElement = element,
			depth = 1,
			children = {},
			hostParent = hostParent,
			hostKey = hostKey,

			-- Legacy Context API
			-- A table of context values inherited from the parent node
			legacyContext = legacyContext,

			-- A saved copy of the parent context, used when replacing a node
			parentLegacyContext = legacyContext,

			-- Context API
			-- A table of context values inherited from the parent node
			context = context or {},

			-- A saved copy of the unmodified context; this will be updated when
			-- a component adds new context and used when a node is replaced
			originalContext = nil,
		}
	end

	local function mountFunctionVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local children = element.component(element.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)
	end

	local function mountPortalVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local targetHostParent = element.props.target
		local children = element.props[Children]

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)
	end

	local function mountFragmentVirtualNode(virtualNode)
		local element = virtualNode.currentElement
		local children = element.elements

		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)
	end

	--[[
		Constructs a new virtual node and mounts it, but does not place it into
		the tree.
	]]
	function mountVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		-- Boolean values render as nil to enable terse conditional rendering.
		if typeof(element) == "boolean" then
			return nil
		end

		local kind = ElementKind.of(element)

		local virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)

		if kind == ElementKind.Host then
			renderer.mountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			mountFunctionVirtualNode(virtualNode)
		elseif kind == ElementKind.Stateful then
			element.component:__mount(reconciler, virtualNode)
		elseif kind == ElementKind.Portal then
			mountPortalVirtualNode(virtualNode)
		elseif kind == ElementKind.Fragment then
			mountFragmentVirtualNode(virtualNode)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		return virtualNode
	end

	--[[
		Constructs a new Roact virtual tree, constructs a root node for
		it, and mounts it.
	]]
	local function mountVirtualTree(element, hostParent, hostKey)
		if config.typeChecks then
			assert(Type.of(element) == Type.Element, "Expected arg #1 to be of type Element")
			assert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
		end

		if hostKey == nil then
			hostKey = "RoactTree"
		end

		local tree = {
			[Type] = Type.VirtualTree,
			[InternalData] = {
				-- The root node of the tree, which starts into the hierarchy of
				-- Roact component instances.
				rootNode = nil,
				mounted = true,
			},
		}

		tree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)

		return tree
	end

	--[[
		Unmounts the virtual tree, freeing all of its resources.

		No further operations should be done on the tree after it's been
		unmounted, as indicated by its the `mounted` field.
	]]
	local function unmountVirtualTree(tree)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(internalData.mounted, "Cannot unmounted a Roact tree that has already been unmounted")
		end

		internalData.mounted = false

		if internalData.rootNode ~= nil then
			unmountVirtualNode(internalData.rootNode)
		end
	end

	--[[
		Utility method for updating the root node of a virtual tree given a new
		element.
	]]
	local function updateVirtualTree(tree, newElement)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(Type.of(newElement) == Type.Element, "Expected arg #2 to be a Roact Element")
		end

		internalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)

		return tree
	end

	reconciler = {
		mountVirtualTree = mountVirtualTree,
		unmountVirtualTree = unmountVirtualTree,
		updateVirtualTree = updateVirtualTree,

		createVirtualNode = createVirtualNode,
		mountVirtualNode = mountVirtualNode,
		unmountVirtualNode = unmountVirtualNode,
		updateVirtualNode = updateVirtualNode,
		updateVirtualNodeWithChildren = updateVirtualNodeWithChildren,
		updateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,
	}

	return reconciler
end

return createReconciler
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="336">
          <Properties>
            <string name="Name">createReconciler.spec</string>
            <string name="Source">return function()
	local assign = require(script.Parent.assign)
	local createElement = require(script.Parent.createElement)
	local createFragment = require(script.Parent.createFragment)
	local createSpy = require(script.Parent.createSpy)
	local NoopRenderer = require(script.Parent.NoopRenderer)
	local Type = require(script.Parent.Type)
	local ElementKind = require(script.Parent.ElementKind)

	local createReconciler = require(script.Parent.createReconciler)

	local noopReconciler = createReconciler(NoopRenderer)

	describe("tree operations", function()
		it("should mount and unmount", function()
			local tree = noopReconciler.mountVirtualTree(createElement("StringValue"))

			expect(tree).to.be.ok()

			noopReconciler.unmountVirtualTree(tree)
		end)

		it("should mount, update, and unmount", function()
			local tree = noopReconciler.mountVirtualTree(createElement("StringValue"))

			expect(tree).to.be.ok()

			noopReconciler.updateVirtualTree(tree, createElement("StringValue"))

			noopReconciler.unmountVirtualTree(tree)
		end)
	end)

	describe("booleans", function()
		it("should mount booleans as nil", function()
			local node = noopReconciler.mountVirtualNode(false, nil, "test")
			expect(node).to.equal(nil)
		end)

		it("should unmount nodes if they are updated to a boolean value", function()
			local node = noopReconciler.mountVirtualNode(createElement("StringValue"), nil, "test")

			expect(node).to.be.ok()

			node = noopReconciler.updateVirtualNode(node, true)

			expect(node).to.equal(nil)
		end)
	end)

	describe("invalid elements", function()
		it("should throw errors when attempting to mount invalid elements", function()
			-- These function components return values with incorrect types
			local returnsString = function()
				return "Hello"
			end
			local returnsNumber = function()
				return 1
			end
			local returnsFunction = function()
				return function() end
			end
			local returnsTable = function()
				return {}
			end

			local hostParent = nil
			local key = "Some Key"

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsString), hostParent, key)
			end).to.throw()

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsNumber), hostParent, key)
			end).to.throw()

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsFunction), hostParent, key)
			end).to.throw()

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsTable), hostParent, key)
			end).to.throw()
		end)
	end)

	describe("Host components", function()
		it("should invoke the renderer to mount host nodes", function()
			local mountHostNode = createSpy(NoopRenderer.mountHostNode)

			local renderer = assign({}, NoopRenderer, {
				mountHostNode = mountHostNode.value,
			})

			local reconciler = createReconciler(renderer)

			local element = createElement("StringValue")
			local hostParent = nil
			local key = "Some Key"
			local node = reconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(mountHostNode.callCount).to.equal(1)

			local values = mountHostNode:captureValues("reconciler", "node")

			expect(values.reconciler).to.equal(reconciler)
			expect(values.node).to.equal(node)
		end)

		it("should invoke the renderer to update host nodes", function()
			local updateHostNode = createSpy(NoopRenderer.updateHostNode)

			local renderer = assign({}, NoopRenderer, {
				mountHostNode = NoopRenderer.mountHostNode,
				updateHostNode = updateHostNode.value,
			})

			local reconciler = createReconciler(renderer)

			local element = createElement("StringValue")
			local hostParent = nil
			local key = "Key"
			local node = reconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			local newElement = createElement("StringValue")
			local newNode = reconciler.updateVirtualNode(node, newElement)

			expect(newNode).to.equal(node)

			expect(updateHostNode.callCount).to.equal(1)

			local values = updateHostNode:captureValues("reconciler", "node", "newElement")

			expect(values.reconciler).to.equal(reconciler)
			expect(values.node).to.equal(node)
			expect(values.newElement).to.equal(newElement)
		end)

		it("should invoke the renderer to unmount host nodes", function()
			local unmountHostNode = createSpy(NoopRenderer.unmountHostNode)

			local renderer = assign({}, NoopRenderer, {
				mountHostNode = NoopRenderer.mountHostNode,
				unmountHostNode = unmountHostNode.value,
			})

			local reconciler = createReconciler(renderer)

			local element = createElement("StringValue")
			local hostParent = nil
			local key = "Key"
			local node = reconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			reconciler.unmountVirtualNode(node)

			expect(unmountHostNode.callCount).to.equal(1)

			local values = unmountHostNode:captureValues("reconciler", "node")

			expect(values.reconciler).to.equal(reconciler)
			expect(values.node).to.equal(node)
		end)
	end)

	describe("Function components", function()
		it("should mount and unmount function components", function()
			local componentSpy = createSpy(function(props)
				return nil
			end)

			local element = createElement(componentSpy.value, {
				someValue = 5,
			})
			local hostParent = nil
			local key = "A Key"
			local node = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(componentSpy.callCount).to.equal(1)

			local calledWith = componentSpy:captureValues("props")

			expect(calledWith.props).to.be.a("table")
			expect(calledWith.props.someValue).to.equal(5)

			noopReconciler.unmountVirtualNode(node)

			expect(componentSpy.callCount).to.equal(1)
		end)

		it("should mount single children of function components", function()
			local childComponentSpy = createSpy(function(props)
				return nil
			end)

			local parentComponentSpy = createSpy(function(props)
				return createElement(childComponentSpy.value, {
					value = props.value + 1,
				})
			end)

			local element = createElement(parentComponentSpy.value, {
				value = 13,
			})
			local hostParent = nil
			local key = "A Key"
			local node = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childComponentSpy.callCount).to.equal(1)

			local parentCalledWith = parentComponentSpy:captureValues("props")
			local childCalledWith = childComponentSpy:captureValues("props")

			expect(parentCalledWith.props).to.be.a("table")
			expect(parentCalledWith.props.value).to.equal(13)

			expect(childCalledWith.props).to.be.a("table")
			expect(childCalledWith.props.value).to.equal(14)

			noopReconciler.unmountVirtualNode(node)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childComponentSpy.callCount).to.equal(1)
		end)

		it("should mount fragments returned by function components", function()
			local childAComponentSpy = createSpy(function(props)
				return nil
			end)

			local childBComponentSpy = createSpy(function(props)
				return nil
			end)

			local parentComponentSpy = createSpy(function(props)
				return createFragment({
					A = createElement(childAComponentSpy.value, {
						value = props.value + 1,
					}),
					B = createElement(childBComponentSpy.value, {
						value = props.value + 5,
					}),
				})
			end)

			local element = createElement(parentComponentSpy.value, {
				value = 17,
			})
			local hostParent = nil
			local key = "A Key"
			local node = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childAComponentSpy.callCount).to.equal(1)
			expect(childBComponentSpy.callCount).to.equal(1)

			local parentCalledWith = parentComponentSpy:captureValues("props")
			local childACalledWith = childAComponentSpy:captureValues("props")
			local childBCalledWith = childBComponentSpy:captureValues("props")

			expect(parentCalledWith.props).to.be.a("table")
			expect(parentCalledWith.props.value).to.equal(17)

			expect(childACalledWith.props).to.be.a("table")
			expect(childACalledWith.props.value).to.equal(18)

			expect(childBCalledWith.props).to.be.a("table")
			expect(childBCalledWith.props.value).to.equal(22)

			noopReconciler.unmountVirtualNode(node)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childAComponentSpy.callCount).to.equal(1)
			expect(childBComponentSpy.callCount).to.equal(1)
		end)
	end)

	describe("Fragments", function()
		it("should mount fragments", function()
			local fragment = createFragment({})
			local node = noopReconciler.mountVirtualNode(fragment, nil, "test")

			expect(node).to.be.ok()
			expect(ElementKind.of(node.currentElement)).to.equal(ElementKind.Fragment)
		end)

		it("should mount an empty fragment", function()
			local emptyFragment = createFragment({})
			local node = noopReconciler.mountVirtualNode(emptyFragment, nil, "test")

			expect(node).to.be.ok()
			expect(next(node.children)).to.never.be.ok()
		end)

		it("should mount all fragment's children", function()
			local childComponentSpy = createSpy(function(props)
				return nil
			end)
			local elements = {}
			local totalElements = 5

			for i=1, totalElements do
				elements["key"..tostring(i)] = createElement(childComponentSpy.value, {})
			end

			local fragments = createFragment(elements)
			local node = noopReconciler.mountVirtualNode(fragments, nil, "test")

			expect(node).to.be.ok()
			expect(childComponentSpy.callCount).to.equal(totalElements)
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="337">
          <Properties>
            <string name="Name">createReconcilerCompat</string>
            <string name="Source">--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Logging = require(script.Parent.Logging)

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local reconcileMessage = [[
Roact.reconcile has been renamed to Roact.update and will be removed in a future release.
Check the call to Roact.reconcile at:
]]

local function createReconcilerCompat(reconciler)
	local compat = {}

	function compat.reify(...)
		Logging.warnOnce(reifyMessage)

		return reconciler.mountVirtualTree(...)
	end

	function compat.teardown(...)
		Logging.warnOnce(teardownMessage)

		return reconciler.unmountVirtualTree(...)
	end

	function compat.reconcile(...)
		Logging.warnOnce(reconcileMessage)

		return reconciler.updateVirtualTree(...)
	end

	return compat
end

return createReconcilerCompat</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="338">
          <Properties>
            <string name="Name">createReconcilerCompat.spec</string>
            <string name="Source">return function()
	local createElement = require(script.Parent.createElement)
	local createReconciler = require(script.Parent.createReconciler)
	local Logging = require(script.Parent.Logging)
	local NoopRenderer = require(script.Parent.NoopRenderer)

	local createReconcilerCompat = require(script.Parent.createReconcilerCompat)

	local noopReconciler = createReconciler(NoopRenderer)
	local compatReconciler = createReconcilerCompat(noopReconciler)

	it("reify should only warn once per call site", function()
		local logInfo = Logging.capture(function()
			-- We're using a loop so that we get the same stack trace and only one
			-- warning hopefully.
			for _ = 1, 2 do
				local handle = compatReconciler.reify(createElement("StringValue"))
				noopReconciler.unmountVirtualTree(handle)
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reify")).to.be.ok()

		logInfo = Logging.capture(function()
			-- This is a different call site, which should trigger another warning.
			local handle = compatReconciler.reify(createElement("StringValue"))
			noopReconciler.unmountVirtualTree(handle)
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reify")).to.be.ok()
	end)

	it("teardown should only warn once per call site", function()
		local logInfo = Logging.capture(function()
			-- We're using a loop so that we get the same stack trace and only one
			-- warning hopefully.
			for _ = 1, 2 do
				local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
				compatReconciler.teardown(handle)
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("teardown")).to.be.ok()

		logInfo = Logging.capture(function()
			-- This is a different call site, which should trigger another warning.
			local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
			compatReconciler.teardown(handle)
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("teardown")).to.be.ok()
	end)

	it("update should only warn once per call site", function()
		local logInfo = Logging.capture(function()
			-- We're using a loop so that we get the same stack trace and only one
			-- warning hopefully.
			for _ = 1, 2 do
				local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
				compatReconciler.reconcile(handle, createElement("StringValue"))
				noopReconciler.unmountVirtualTree(handle)
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reconcile")).to.be.ok()

		logInfo = Logging.capture(function()
			-- This is a different call site, which should trigger another warning.
			local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
			compatReconciler.reconcile(handle, createElement("StringValue"))
			noopReconciler.unmountVirtualTree(handle)
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reconcile")).to.be.ok()
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="339">
          <Properties>
            <string name="Name">createRef</string>
            <string name="Source">--[[
	A ref is nothing more than a binding with a special field 'current'
	that maps to the getValue method of the binding
]]
local Binding = require(script.Parent.Binding)

local function createRef()
	local binding, _ = Binding.create(nil)

	local ref = {}

	--[[
		A ref is just redirected to a binding via its metatable
	]]
	setmetatable(ref, {
		__index = function(self, key)
			if key == "current" then
				return binding:getValue()
			else
				return binding[key]
			end
		end,
		__newindex = function(self, key, value)
			if key == "current" then
				error("Cannot assign to the 'current' property of refs", 2)
			end

			binding[key] = value
		end,
		__tostring = function(self)
			return ("RoactRef(%s)"):format(tostring(binding:getValue()))
		end,
	})

	return ref
end

return createRef</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="340">
          <Properties>
            <string name="Name">createRef.spec</string>
            <string name="Source">return function()
	local Binding = require(script.Parent.Binding)
	local Type = require(script.Parent.Type)

	local createRef = require(script.Parent.createRef)

	it("should create refs, which are specialized bindings", function()
		local ref = createRef()

		expect(Type.of(ref)).to.equal(Type.Binding)
		expect(ref.current).to.equal(nil)
	end)

	it("should have a 'current' field that is the same as the internal binding's value", function()
		local ref = createRef()

		expect(ref.current).to.equal(nil)

		Binding.update(ref, 10)
		expect(ref.current).to.equal(10)
	end)

	it("should support tostring on refs", function()
		local ref = createRef()

		expect(ref.current).to.equal(nil)
		expect(tostring(ref)).to.equal("RoactRef(nil)")

		Binding.update(ref, 10)
		expect(tostring(ref)).to.equal("RoactRef(10)")
	end)

	it("should not allow assignments to the 'current' field", function()
		local ref = createRef()

		expect(ref.current).to.equal(nil)

		Binding.update(ref, 99)
		expect(ref.current).to.equal(99)

		expect(function()
			ref.current = 77
		end).to.throw()

		expect(ref.current).to.equal(99)
	end)

	it("should return the same thing from getValue as its current field", function()
		local ref = createRef()
		Binding.update(ref, 10)

		expect(ref:getValue()).to.equal(10)
		expect(ref:getValue()).to.equal(ref.current)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="341">
          <Properties>
            <string name="Name">createSignal</string>
            <string name="Source">--[[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
]]

local function addToMap(map, addKey, addValue)
	local new = {}

	for key, value in pairs(map) do
		new[key] = value
	end

	new[addKey] = addValue

	return new
end

local function removeFromMap(map, removeKey)
	local new = {}

	for key, value in pairs(map) do
		if key ~= removeKey then
			new[key] = value
		end
	end

	return new
end

local function createSignal()
	local connections = {}

	local function subscribe(self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
		}

		connections = addToMap(connections, callback, connection)

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections = removeFromMap(connections, callback)
		end

		return disconnect
	end

	local function fire(self, ...)
		for callback, connection in pairs(connections) do
			if not connection.disconnected then
				callback(...)
			end
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="342">
          <Properties>
            <string name="Name">createSignal.spec</string>
            <string name="Source">return function()
	local createSignal = require(script.Parent.createSignal)

	local createSpy = require(script.Parent.createSpy)

	it("should fire subscribers and disconnect them", function()
		local signal = createSignal()

		local spy = createSpy()
		local disconnect = signal:subscribe(spy.value)

		expect(spy.callCount).to.equal(0)

		local a = 1
		local b = {}
		local c = "hello"
		signal:fire(a, b, c)

		expect(spy.callCount).to.equal(1)
		spy:assertCalledWith(a, b, c)

		disconnect()

		signal:fire()

		expect(spy.callCount).to.equal(1)
	end)

	it("should handle multiple subscribers", function()
		local signal = createSignal()

		local spyA = createSpy()
		local spyB = createSpy()

		local disconnectA = signal:subscribe(spyA.value)
		local disconnectB = signal:subscribe(spyB.value)

		expect(spyA.callCount).to.equal(0)
		expect(spyB.callCount).to.equal(0)

		local a = {}
		local b = 67
		signal:fire(a, b)

		expect(spyA.callCount).to.equal(1)
		spyA:assertCalledWith(a, b)

		expect(spyB.callCount).to.equal(1)
		spyB:assertCalledWith(a, b)

		disconnectA()

		signal:fire(b, a)

		expect(spyA.callCount).to.equal(1)

		expect(spyB.callCount).to.equal(2)
		spyB:assertCalledWith(b, a)

		disconnectB()
	end)

	it("should stop firing a connection if disconnected mid-fire", function()
		local signal = createSignal()

		-- In this test, we'll connect two listeners that each try to disconnect
		-- the other. Because the order of listeners firing isn't defined, we
		-- have to be careful to handle either case.

		local disconnectA
		local disconnectB

		local spyA = createSpy(function()
			disconnectB()
		end)

		local spyB = createSpy(function()
			disconnectA()
		end)

		disconnectA = signal:subscribe(spyA.value)
		disconnectB = signal:subscribe(spyB.value)

		signal:fire()

		-- Exactly once listener should have been called.
		expect(spyA.callCount + spyB.callCount).to.equal(1)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="343">
          <Properties>
            <string name="Name">createSpy</string>
            <string name="Source">--[[
	A utility used to create a function spy that can be used to robustly test
	that functions are invoked the correct number of times and with the correct
	number of arguments.

	This should only be used in tests.
]]

local assertDeepEqual = require(script.Parent.assertDeepEqual)

local function createSpy(inner)
	local self = {
		callCount = 0,
		values = {},
		valuesLength = 0,
	}

	self.value = function(...)
		self.callCount = self.callCount + 1
		self.values = {...}
		self.valuesLength = select("#", ...)

		if inner ~= nil then
			return inner(...)
		end
	end

	self.assertCalledWith = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assert(self.values[i] == expected, "value differs")
		end
	end

	self.assertCalledWithDeepEqual = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assertDeepEqual(self.values[i], expected)
		end
	end

	self.captureValues = function(_, ...)
		local len = select("#", ...)
		local result = {}

		assert(self.valuesLength == len, "length of expected values differs from stored values")

		for i = 1, len do
			local key = select(i, ...)
			result[key] = self.values[i]
		end

		return result
	end

	setmetatable(self, {
		__index = function(_, key)
			error(("%q is not a valid member of spy"):format(key))
		end,
	})

	return self
end

return createSpy</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="344">
          <Properties>
            <string name="Name">createSpy.spec</string>
            <string name="Source">return function()
	local createSpy = require(script.Parent.createSpy)

	describe("createSpy", function()
		it("should create spies", function()
			local spy = createSpy(function() end)

			expect(spy).to.be.ok()
		end)

		it("should throw if spies are indexed by an invalid key", function()
			local spy = createSpy(function() end)

			expect(function()
				return spy.test
			end).to.throw()
		end)
	end)

	describe("value", function()
		it("should increment callCount when called", function()
			local spy = createSpy(function() end)
			spy.value()

			expect(spy.callCount).to.equal(1)
		end)

		it("should store all values passed", function()
			local spy = createSpy(function() end)
			spy.value(1, true, "3")

			expect(spy.valuesLength).to.equal(3)
			expect(spy.values[1]).to.equal(1)
			expect(spy.values[2]).to.equal(true)
			expect(spy.values[3]).to.equal("3")
		end)

		it("should return the value of the inner function", function()
			local spy = createSpy(function()
				return true
			end)

			expect(spy.value()).to.equal(true)
		end)
	end)

	describe("assertCalledWith", function()
		it("should throw if the number of values differs", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			expect(function()
				spy:assertCalledWith(1)
			end).to.throw()
		end)

		it("should throw if any value differs", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			expect(function()
				spy:assertCalledWith(1, 3)
			end).to.throw()

			expect(function()
				spy:assertCalledWith(2, 3)
			end).to.throw()
		end)
	end)

	describe("captureValues", function()
		it("should throw if the number of values differs", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			expect(function()
				spy:captureValues("a")
			end).to.throw()
		end)

		it("should capture all values in a table", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			local captured = spy:captureValues("a", "b")
			expect(captured.a).to.equal(1)
			expect(captured.b).to.equal(2)
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="345">
          <Properties>
            <string name="Name">getDefaultInstanceProperty</string>
            <string name="Source">--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="346">
          <Properties>
            <string name="Name">getDefaultInstanceProperty.spec</string>
            <string name="Source">return function()
	local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)

	it("should get default name string values", function()
		local _, defaultName = getDefaultInstanceProperty("StringValue", "Name")

		expect(defaultName).to.equal("Value")
	end)

	it("should get default empty string values", function()
		local _, defaultValue = getDefaultInstanceProperty("StringValue", "Value")

		expect(defaultValue).to.equal("")
	end)

	it("should get default number values", function()
		local _, defaultValue = getDefaultInstanceProperty("IntValue", "Value")

		expect(defaultValue).to.equal(0)
	end)

	it("should get nil default values", function()
		local _, defaultValue = getDefaultInstanceProperty("ObjectValue", "Value")

		expect(defaultValue).to.equal(nil)
	end)

	it("should get bool default values", function()
		local _, defaultValue = getDefaultInstanceProperty("BoolValue", "Value")

		expect(defaultValue).to.equal(false)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="347">
          <Properties>
            <string name="Name">init.spec</string>
            <string name="Source">return function()
	local Roact = require(script.Parent)

	it("should load with all public APIs", function()
		local publicApi = {
			createElement = "function",
			createFragment = "function",
			createRef = "function",
			createBinding = "function",
			joinBindings = "function",
			mount = "function",
			unmount = "function",
			update = "function",
			oneChild = "function",
			setGlobalConfig = "function",
			createContext = "function",

			-- These functions are deprecated and throw warnings!
			reify = "function",
			teardown = "function",
			reconcile = "function",

			Component = true,
			PureComponent = true,
			Portal = true,
			Children = true,
			Event = true,
			Change = true,
			Ref = true,
			None = true,
			UNSTABLE = true,
		}

		expect(Roact).to.be.ok()

		for key, valueType in pairs(publicApi) do
			local success
			if typeof(valueType) == "string" then
				success = typeof(Roact[key]) == valueType
			else
				success = Roact[key] ~= nil
			end

			if not success then
				local existence = typeof(valueType) == "boolean" and "present" or "of type " .. valueType
				local message = (
					"Expected public API member %q to be %s, but instead it was of type %s"
				):format(tostring(key), existence, typeof(Roact[key]))

				error(message)
			end
		end

		for key in pairs(Roact) do
			if publicApi[key] == nil then
				local message = (
					"Found unknown public API key %q!"
				):format(tostring(key))

				error(message)
			end
		end
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="348">
          <Properties>
            <string name="Name">internalAssert</string>
            <string name="Source">local function internalAssert(condition, message)
	if not condition then
		error(message .. " (This is probably a bug in Roact!)", 3)
	end
end

return internalAssert</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="349">
          <Properties>
            <string name="Name">invalidSetStateMessages</string>
            <string name="Source">--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)

local invalidSetStateMessages = {}

invalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.WillUnmount] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.Render] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, because Roact doesn't know
which part of the lifecycle this component is in.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="350">
          <Properties>
            <string name="Name">oneChild</string>
            <string name="Source">--[[
	Retrieves at most one child from the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child.
]]
local function oneChild(children)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="351">
          <Properties>
            <string name="Name">oneChild.spec</string>
            <string name="Source">return function()
	local createElement = require(script.Parent.createElement)

	local oneChild = require(script.Parent.oneChild)

	it("should get zero children from a table", function()
		local children = {}

		expect(oneChild(children)).to.equal(nil)
	end)

	it("should get exactly one child", function()
		local child = createElement("Frame")
		local children = {
			foo = child,
		}

		expect(oneChild(children)).to.equal(child)
	end)

	it("should error with more than one child", function()
		local children = {
			a = createElement("Frame"),
			b = createElement("Frame"),
		}

		expect(function()
			oneChild(children)
		end).to.throw()
	end)

	it("should handle being passed nil", function()
		expect(oneChild(nil)).to.equal(nil)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="352">
          <Properties>
            <string name="Name">strict</string>
            <string name="Source">local function strict(t, name)
	name = name or tostring(t)

	return setmetatable(t, {
		__index = function(self, key)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,

		__newindex = function(self, key, value)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,
	})
end

return strict</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="353">
          <Properties>
            <string name="Name">strict.spec</string>
            <string name="Source">return function()
	local strict = require(script.Parent.strict)

	it("should error when getting a nonexistent key", function()
		local t = strict({
			a = 1,
			b = 2,
		})

		expect(function()
			return t.c
		end).to.throw()
	end)

	it("should error when setting a nonexistent key", function()
		local t = strict({
			a = 1,
			b = 2,
		})

		expect(function()
			t.c = 3
		end).to.throw()
	end)
end</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="354">
        <Properties>
          <string name="Name">RoactRodux</string>
          <string name="Source">local StoreProvider = require(script.StoreProvider)
local connect = require(script.connect)
local getStore = require(script.getStore)
local TempConfig = require(script.TempConfig)

return {
	StoreProvider = StoreProvider,
	connect = connect,
	UNSTABLE_getStore = getStore,
	UNSTABLE_connect2 = connect,

	TEMP_CONFIG = TempConfig,
}</string>
        </Properties>
        <Item class="ModuleScript" referent="355">
          <Properties>
            <string name="Name">StoreProvider</string>
            <string name="Source">local Roact = require(script.Parent.Parent.Roact)

local storeKey = require(script.Parent.storeKey)

local StoreProvider = Roact.Component:extend("StoreProvider")

function StoreProvider:init(props)
	local store = props.store

	if store == nil then
		error("Error initializing StoreProvider. Expected a `store` prop to be a Rodux store.")
	end

	self._context[storeKey] = store
end

function StoreProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

return StoreProvider</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="356">
          <Properties>
            <string name="Name">StoreProvider.spec</string>
            <string name="Source">return function()
	local StoreProvider = require(script.Parent.StoreProvider)

	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	it("should be instantiable as a component", function()
		local store = Rodux.Store.new(function()
			return 0
		end)
		local element = Roact.createElement(StoreProvider, {
			store = store
		})

		expect(element).to.be.ok()

		local handle = Roact.mount(element, nil, "StoreProvider-test")

		Roact.unmount(handle)
		store:destruct()
	end)

	it("should expect a 'store' prop", function()
		local element = Roact.createElement(StoreProvider)

		expect(function()
			Roact.mount(element)
		end).to.throw()
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="357">
          <Properties>
            <string name="Name">Symbol</string>
            <string name="Source">--[[
	A 'Symbol' is an opaque marker type that can be used to signify unique
	statuses. Symbols have the type 'userdata', but when printed to the console,
	the name of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

--[[
	Create an unnamed Symbol. Usually, you should create a named Symbol using
	Symbol.named(name)
]]
function Symbol.unnamed()
	local self = newproxy(true)

	getmetatable(self).__tostring = function()
		return "Unnamed Symbol"
	end

	return self
end

return Symbol</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="358">
          <Properties>
            <string name="Name">Symbol.spec</string>
            <string name="Source">return function()
	local Symbol = require(script.Parent.Symbol)

	describe("named", function()
		it("should give an opaque object", function()
			local symbol = Symbol.named("foo")

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to the given name", function()
			local symbol = Symbol.named("foo")

			expect(tostring(symbol):find("foo")).to.be.ok()
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.named("abc")
			local symbolB = Symbol.named("abc")

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)

	describe("unnamed", function()
		it("should give an opaque object", function()
			local symbol = Symbol.unnamed()

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to some string", function()
			local symbol = Symbol.unnamed()

			expect(tostring(symbol)).to.be.a("string")
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.unnamed()
			local symbolB = Symbol.unnamed()

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="359">
          <Properties>
            <string name="Name">TempConfig</string>
            <string name="Source"><![CDATA[return {
	newConnectionOrder = true,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="360">
          <Properties>
            <string name="Name">connect</string>
            <string name="Source">local Roact = require(script.Parent.Parent.Roact)
local getStore = require(script.Parent.getStore)
local shallowEqual = require(script.Parent.shallowEqual)
local join = require(script.Parent.join)

local TempConfig = require(script.Parent.TempConfig)

--[[
	Formats a multi-line message with printf-style placeholders.
]]
local function formatMessage(lines, parameters)
	return table.concat(lines, "\n"):format(unpack(parameters or {}))
end

local function noop()
	return nil
end

--[[
	The stateUpdater accepts props when they update and computes the
	complete set of props that should be passed to the wrapped component.

	Each connected component will have a stateUpdater created for it.

	stateUpdater is put into the component's state in order for
	getDerivedStateFromProps to be able to access it. It is not mutated.
]]
local function makeStateUpdater(store)
	return function(nextProps, prevState, mappedStoreState)
		-- The caller can optionally provide mappedStoreState if it needed that
		-- value beforehand. Doing so is purely an optimization.
		if mappedStoreState == nil then
			mappedStoreState = prevState.mapStateToProps(store:getState(), nextProps)
		end

		local propsForChild = join(nextProps, mappedStoreState, prevState.mappedStoreDispatch)

		return {
			mappedStoreState = mappedStoreState,
			propsForChild = propsForChild,
		}
	end
end

--[[
	mapStateToProps:
		(storeState, props) -> partialProps
		OR
		() -> (storeState, props) -> partialProps
	mapDispatchToProps: (dispatch) -> partialProps
]]
local function connect(mapStateToPropsOrThunk, mapDispatchToProps)
	local connectTrace = debug.traceback()

	if mapStateToPropsOrThunk ~= nil then
		assert(typeof(mapStateToPropsOrThunk) == "function", "mapStateToProps must be a function or nil!")
	else
		mapStateToPropsOrThunk = noop
	end

	if mapDispatchToProps ~= nil then
		assert(typeof(mapDispatchToProps) == "function", "mapDispatchToProps must be a function or nil!")
	else
		mapDispatchToProps = noop
	end

	return function(innerComponent)
		if innerComponent == nil then
			local message = formatMessage({
				"connect returns a function that must be passed a component.",
				"Check the connection at:",
				"%s",
			}, {
				connectTrace,
			})

			error(message, 2)
		end

		local componentName = ("RoduxConnection(%s)"):format(tostring(innerComponent))

		local Connection = Roact.Component:extend(componentName)

		function Connection.getDerivedStateFromProps(nextProps, prevState)
			if prevState.stateUpdater ~= nil then
				return prevState.stateUpdater(nextProps, prevState)
			end
		end

		function Connection:createStoreConnection()
			self.storeChangedConnection = self.store.changed:connect(function(storeState)
				self:setState(function(prevState, props)
					local mappedStoreState = prevState.mapStateToProps(storeState, props)

					-- We run this check here so that we only check shallow
					-- equality with the result of mapStateToProps, and not the
					-- other props that could be passed through the connector.
					if shallowEqual(mappedStoreState, prevState.mappedStoreState) then
						return nil
					end

					return prevState.stateUpdater(props, prevState, mappedStoreState)
				end)
			end)
		end

		function Connection:init()
			self.store = getStore(self)

			if self.store == nil then
				local message = formatMessage({
					"Cannot initialize Roact-Rodux connection without being a descendent of StoreProvider!",
					"Tried to wrap component %q",
					"Make sure there is a StoreProvider above this component in the tree.",
				}, {
					tostring(innerComponent),
				})

				error(message)
			end

			local storeState = self.store:getState()

			local mapStateToProps = mapStateToPropsOrThunk
			local mappedStoreState = mapStateToProps(storeState, self.props)

			-- mapStateToPropsOrThunk can return a function instead of a state
			-- value. In this variant, we keep that value as mapStateToProps
			-- instead of the original mapStateToProps. This matches react-redux
			-- and enables connectors to keep instance-level state.
			if typeof(mappedStoreState) == "function" then
				mapStateToProps = mappedStoreState
				mappedStoreState = mapStateToProps(storeState, self.props)
			end

			if mappedStoreState ~= nil and typeof(mappedStoreState) ~= "table" then
				local message = formatMessage({
					"mapStateToProps must either return a table, or return another function that returns a table.",
					"Instead, it returned %q, which is of type %s.",
				}, {
					tostring(mappedStoreState),
					typeof(mappedStoreState),
				})

				error(message)
			end

			local mappedStoreDispatch = mapDispatchToProps(function(...)
				return self.store:dispatch(...)
			end)

			local stateUpdater = makeStateUpdater(self.store)

			self.state = {
				-- Combines props, mappedStoreDispatch, and the result of
				-- mapStateToProps into propsForChild. Stored in state so that
				-- getDerivedStateFromProps can access it.
				stateUpdater = stateUpdater,

				-- Used by the store changed connection and stateUpdater to
				-- construct propsForChild.
				mapStateToProps = mapStateToProps,

				-- Used by stateUpdater to construct propsForChild.
				mappedStoreDispatch = mappedStoreDispatch,

				-- Passed directly into the component that Connection is
				-- wrapping.
				propsForChild = nil,
			}

			local extraState = stateUpdater(self.props, self.state, mappedStoreState)

			for key, value in pairs(extraState) do
				self.state[key] = value
			end

			if TempConfig.newConnectionOrder then
				self:createStoreConnection()
			end
		end

		function Connection:didMount()
			if not TempConfig.newConnectionOrder then
				self:createStoreConnection()
			end
		end

		function Connection:willUnmount()
			self.storeChangedConnection:disconnect()
		end

		function Connection:render()
			return Roact.createElement(innerComponent, self.state.propsForChild)
		end

		return Connection
	end
end

return connect</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="361">
          <Properties>
            <string name="Name">connect.spec</string>
            <string name="Source">return function()
	local connect = require(script.Parent.connect)

	local StoreProvider = require(script.Parent.StoreProvider)

	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	local TempConfig = require(script.Parent.TempConfig)

	local function noop()
		return nil
	end

	local function NoopComponent()
		return nil
	end

	local function countReducer(state, action)
		state = state or 0

		if action.type == "increment" then
			return state + 1
		end

		return state
	end

	local reducer = Rodux.combineReducers({
		count = countReducer,
	})

	describe("Argument validation", function()
		it("should accept no arguments", function()
			connect()
		end)

		it("should accept one function", function()
			connect(noop)
		end)

		it("should accept two functions", function()
			connect(noop, noop)
		end)

		it("should accept only the second function", function()
			connect(nil, function() end)
		end)

		it("should throw if not passed a component", function()
			local selector = function(store)
				return {}
			end

			expect(function()
				connect(selector)(nil)
			end).to.throw()
		end)
	end)

	it("should throw if not mounted under a StoreProvider", function()
		local ConnectedSomeComponent = connect()(NoopComponent)

		expect(function()
			Roact.mount(Roact.createElement(ConnectedSomeComponent))
		end).to.throw()
	end)

	it("should accept a higher-order function mapStateToProps", function()
		local function mapStateToProps()
			return function(state)
				return {
					count = state.count,
				}
			end
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		Roact.unmount(handle)
	end)

	it("should not accept a higher-order mapStateToProps that returns a non-table value", function()
		local function mapStateToProps()
			return function(state)
				return "nope"
			end
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		expect(function()
			Roact.mount(tree)
		end).to.throw()
	end)

	it("should not accept a mapStateToProps that returns a non-table value", function()
		local function mapStateToProps()
			return "nah"
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		expect(function()
			Roact.mount(tree)
		end).to.throw()
	end)

	it("should abort renders when mapStateToProps returns the same data", function()
		local function mapStateToProps(state)
			return {
				count = state.count,
			}
		end

		local renderCount = 0
		local function SomeComponent(props)
			renderCount = renderCount + 1
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(SomeComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		expect(renderCount).to.equal(1)

		store:dispatch({ type = "an unknown action" })
		store:flush()

		expect(renderCount).to.equal(1)

		store:dispatch({ type = "increment" })
		store:flush()

		expect(renderCount).to.equal(2)

		Roact.unmount(handle)
	end)

	it("should only call mapDispatchToProps once and never re-render if no mapStateToProps was passed", function()
		local dispatchCount = 0
		local mapDispatchToProps = function(dispatch)
			dispatchCount = dispatchCount + 1

			return {
				increment = function()
					return dispatch({ type = "increment" })
				end,
			}
		end

		local renderCount = 0
		local function SomeComponent(props)
			renderCount = renderCount + 1
		end

		local ConnectedSomeComponent = connect(nil, mapDispatchToProps)(SomeComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		store:dispatch({ type = "an unknown action" })
		store:flush()

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		store:dispatch({ type = "increment" })
		store:flush()

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		Roact.unmount(handle)
	end)

	it("should return result values from the dispatch passed to mapDispatchToProps", function()
		local function reducer()
			return 0
		end

		local function fiveThunk()
			return 5
		end

		local dispatch
		local function SomeComponent(props)
			dispatch = props.dispatch
		end

		local function mapDispatchToProps(dispatch)
			return {
				dispatch = dispatch
			}
		end

		local ConnectedSomeComponent = connect(nil, mapDispatchToProps)(SomeComponent)

		-- We'll use the thunk middleware, as it should always return its result
		local store = Rodux.Store.new(reducer, nil, { Rodux.thunkMiddleware })
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent)
		})

		local handle = Roact.mount(tree)

		expect(dispatch).to.be.a("function")
		expect(dispatch(fiveThunk)).to.equal(5)

		Roact.unmount(handle)
	end)

	describe("TempConfig.newConnectionOrder = true", function()
		local oldNewConnectionOrder
		beforeAll(function()
			oldNewConnectionOrder = TempConfig.newConnectionOrder
			TempConfig.newConnectionOrder = true
		end)

		afterAll(function()
			TempConfig.newConnectionOrder = oldNewConnectionOrder
		end)

		it("should render parent elements before children", function()
			local function mapStateToProps(state)
				return {
					count = state.count,
				}
			end

			local childWasRenderedFirst = false

			local function ChildComponent(props)
				if props.count > props.parentCount then
					childWasRenderedFirst = true
				end
			end

			local ConnectedChildComponent = connect(mapStateToProps)(ChildComponent)

			local function ParentComponent(props)
				return Roact.createElement(ConnectedChildComponent, {
					parentCount = props.count,
				})
			end

			local ConnectedParentComponent = connect(mapStateToProps)(ParentComponent)

			local store = Rodux.Store.new(reducer)
			local tree = Roact.createElement(StoreProvider, {
				store = store,
			}, {
				parent = Roact.createElement(ConnectedParentComponent),
			})

			local handle = Roact.mount(tree)

			store:dispatch({ type = "increment" })
			store:flush()

			store:dispatch({ type = "increment" })
			store:flush()

			Roact.unmount(handle)

			expect(childWasRenderedFirst).to.equal(false)
		end)
	end)

	describe("TempConfig.newConnectionOrder = false", function()
		local oldNewConnectionOrder
		beforeAll(function()
			oldNewConnectionOrder = TempConfig.newConnectionOrder
			TempConfig.newConnectionOrder = false
		end)

		afterAll(function()
			TempConfig.newConnectionOrder = oldNewConnectionOrder
		end)

		it("should render child elements before children when TempConfig.newConnectionOrder is false", function()
			local function mapStateToProps(state)
				return {
					count = state.count,
				}
			end

			local childWasRenderedFirst = false

			local function ChildComponent(props)
				if props.count > props.parentCount then
					childWasRenderedFirst = true
				end
			end

			local ConnectedChildComponent = connect(mapStateToProps)(ChildComponent)

			local function ParentComponent(props)
				return Roact.createElement(ConnectedChildComponent, {
					parentCount = props.count,
				})
			end

			local ConnectedParentComponent = connect(mapStateToProps)(ParentComponent)

			local store = Rodux.Store.new(reducer)
			local tree = Roact.createElement(StoreProvider, {
				store = store,
			}, {
				parent = Roact.createElement(ConnectedParentComponent),
			})

			local handle = Roact.mount(tree)

			store:dispatch({ type = "increment" })
			store:flush()

			store:dispatch({ type = "increment" })
			store:flush()

			Roact.unmount(handle)

			expect(childWasRenderedFirst).to.equal(true)
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="362">
          <Properties>
            <string name="Name">getStore</string>
            <string name="Source">local storeKey = require(script.Parent.storeKey)

local function getStore(componentInstance)
	return componentInstance._context[storeKey]
end

return getStore</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="363">
          <Properties>
            <string name="Name">getStore.spec</string>
            <string name="Source">return function()
	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	local StoreProvider = require(script.Parent.StoreProvider)

	local getStore = require(script.Parent.getStore)

	it("should return the store when present", function()
		local function reducer()
			return 0
		end

		local store = Rodux.Store.new(reducer)
		local consumedStore = nil

		local StoreConsumer = Roact.Component:extend("StoreConsumer")

		function StoreConsumer:init()
			consumedStore = getStore(self)
		end

		function StoreConsumer:render()
			return nil
		end

		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			Consumer = Roact.createElement(StoreConsumer),
		})

		local handle = Roact.mount(tree)

		expect(consumedStore).to.equal(store)

		Roact.unmount(handle)
		store:destruct()
	end)

	it("should return nil when the store is not present", function()
		-- Use a non-nil value to know for sure if StoreConsumer:init was called
		local consumedStore = 6

		local StoreConsumer = Roact.Component:extend("StoreConsumer")

		function StoreConsumer:init()
			consumedStore = getStore(self)
		end

		function StoreConsumer:render()
			return nil
		end

		local tree = Roact.createElement(StoreConsumer)
		local handle = Roact.mount(tree)

		expect(consumedStore).to.equal(nil)

		Roact.unmount(handle)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="364">
          <Properties>
            <string name="Name">join</string>
            <string name="Source">local function join(...)
	local result = {}

	for i = 1, select("#", ...) do
		local source = select(i, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				result[key] = value
			end
		end
	end

	return result
end

return join</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="365">
          <Properties>
            <string name="Name">shallowEqual</string>
            <string name="Source">local function shallowEqual(a, b)
	if a == nil then
		return b == nil
	elseif b == nil then
		return a == nil
	end

	for key, value in pairs(a) do
		if value ~= b[key] then
			return false
		end
	end

	for key, value in pairs(b) do
		if value ~= a[key] then
			return false
		end
	end

	return true
end

return shallowEqual</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="366">
          <Properties>
            <string name="Name">shallowEqual.spec</string>
            <string name="Source">return function()
	local shallowEqual = require(script.Parent.shallowEqual)

	it("should compare dictionaries", function()
		local a = {
			a = "a",
			b = {},
			c = 6,
		}

		local b = {
			b = a.b,
			c = a.c,
			a = a.a,
		}

		local c = {
			b = {},
			a = a.a,
			c = a.c,
		}

		local d = {
			a = a.a,
			b = a.b,
			c = a.c,
			d = "hello",
		}

		expect(shallowEqual(a, a)).to.equal(true)
		expect(shallowEqual(a, b)).to.equal(true)
		expect(shallowEqual(a, c)).to.equal(false)
		expect(shallowEqual(b, c)).to.equal(false)
		expect(shallowEqual(a, d)).to.equal(false)
		expect(shallowEqual(b, d)).to.equal(false)
	end)

	it("should handle nil for either argument", function()
		local a = {}

		expect(shallowEqual(nil, nil)).to.equal(true)
		expect(shallowEqual(a, nil)).to.equal(false)
		expect(shallowEqual(nil, a)).to.equal(false)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="367">
          <Properties>
            <string name="Name">storeKey</string>
            <string name="Source">local Symbol = require(script.Parent.Symbol)

return Symbol.named("RoduxStore")</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="368">
        <Properties>
          <string name="Name">Rodux</string>
          <string name="Source"><![CDATA[local Store = require(script.Store)
local createReducer = require(script.createReducer)
local combineReducers = require(script.combineReducers)
local loggerMiddleware = require(script.loggerMiddleware)
local thunkMiddleware = require(script.thunkMiddleware)

return {
	Store = Store,
	createReducer = createReducer,
	combineReducers = combineReducers,
	loggerMiddleware = loggerMiddleware.middleware,
	thunkMiddleware = thunkMiddleware,
}
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="369">
          <Properties>
            <string name="Name">NoYield</string>
            <string name="Source">--[[
	Calls a function and throws an error if it attempts to yield.

	Pass any number of arguments to the function after the callback.

	This function supports multiple return; all results returned from the
	given function will be returned.
]]

local function resultHandler(co, ok, ...)
	if not ok then
		local message = (...)
		error(debug.traceback(co, message), 2)
	end

	if coroutine.status(co) ~= "dead" then
		error(debug.traceback(co, "Attempted to yield inside changed event!"), 2)
	end

	return ...
end

local function NoYield(callback, ...)
	local co = coroutine.create(callback)

	return resultHandler(co, coroutine.resume(co, ...))
end

return NoYield</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="370">
          <Properties>
            <string name="Name">NoYield.spec</string>
            <string name="Source">return function()
	local NoYield = require(script.Parent.NoYield)

	it("should call functions normally", function()
		local callCount = 0

		local function test(a, b)
			expect(a).to.equal(5)
			expect(b).to.equal(6)

			callCount = callCount + 1

			return 11, "hello"
		end

		local a, b = NoYield(test, 5, 6)

		expect(a).to.equal(11)
		expect(b).to.equal("hello")
	end)

	it("should throw on yield", function()
		local preCount = 0
		local postCount = 0

		local function testMethod()
			preCount = preCount + 1
			wait()
			postCount = postCount + 1
		end

		local ok, err = pcall(NoYield, testMethod)

		expect(preCount).to.equal(1)
		expect(postCount).to.equal(0)

		expect(ok).to.equal(false)
		expect(err:find("Attempted to yield inside changed event!")).to.be.ok()
		expect(err:find("NoYield.spec")).to.be.ok()
	end)

	it("should propagate error messages", function()
		local count = 0

		local function test()
			count = count + 1
			error("foo")
		end

		local ok, err = pcall(NoYield, test)

		expect(ok).to.equal(false)
		expect(err:find("foo")).to.be.ok()
		expect(err:find("NoYield.spec")).to.be.ok()
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="371">
          <Properties>
            <string name="Name">Signal</string>
            <string name="Source">--[[
	A limited, simple implementation of a Signal.

	Handlers are fired in order, and (dis)connections are properly handled when
	executing an event.
]]

local function immutableAppend(list, ...)
	local new = {}
	local len = #list

	for key = 1, len do
		new[key] = list[key]
	end

	for i = 1, select("#", ...) do
		new[len + i] = select(i, ...)
	end

	return new
end

local function immutableRemoveValue(list, removeValue)
	local new = {}

	for i = 1, #list do
		if list[i] ~= removeValue then
			table.insert(new, list[i])
		end
	end

	return new
end

local Signal = {}

Signal.__index = Signal

function Signal.new()
	local self = {
		_listeners = {}
	}

	setmetatable(self, Signal)

	return self
end

function Signal:connect(callback)
	local listener = {
		callback = callback,
		disconnected = false,
	}

	self._listeners = immutableAppend(self._listeners, listener)

	local function disconnect()
		listener.disconnected = true
		self._listeners = immutableRemoveValue(self._listeners, listener)
	end

	return {
		disconnect = disconnect
	}
end

function Signal:fire(...)
	for _, listener in ipairs(self._listeners) do
		if not listener.disconnected then
			listener.callback(...)
		end
	end
end

return Signal</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="372">
          <Properties>
            <string name="Name">Signal.spec</string>
            <string name="Source">return function()
	local Signal = require(script.Parent.Signal)

	it("should construct from nothing", function()
		local signal = Signal.new()

		expect(signal).to.be.ok()
	end)

	it("should fire connected callbacks", function()
		local callCount = 0
		local value1 = "Hello World"
		local value2 = 7

		local callback = function(arg1, arg2)
			expect(arg1).to.equal(value1)
			expect(arg2).to.equal(value2)
			callCount = callCount + 1
		end

		local signal = Signal.new()

		local connection = signal:connect(callback)
		signal:fire(value1, value2)

		expect(callCount).to.equal(1)

		connection:disconnect()
		signal:fire(value1, value2)

		expect(callCount).to.equal(1)
	end)

	it("should disconnect handlers", function()
		local callback = function()
			error("Callback was called after disconnect!")
		end

		local signal = Signal.new()

		local connection = signal:connect(callback)
		connection:disconnect()

		signal:fire()
	end)

	it("should fire handlers in order", function()
		local signal = Signal.new()
		local x = 0
		local y = 0

		local callback1 = function()
			expect(x).to.equal(0)
			expect(y).to.equal(0)
			x = x + 1
		end

		local callback2 = function()
			expect(x).to.equal(1)
			expect(y).to.equal(0)
			y = y + 1
		end

		signal:connect(callback1)
		signal:connect(callback2)
		signal:fire()

		expect(x).to.equal(1)
		expect(y).to.equal(1)
	end)

	it("should continue firing despite mid-event disconnection", function()
		local signal = Signal.new()
		local countA = 0
		local countB = 0

		local connectionA
		connectionA = signal:connect(function()
			connectionA:disconnect()
			countA = countA + 1
		end)

		signal:connect(function()
			countB = countB + 1
		end)

		signal:fire()

		expect(countA).to.equal(1)
		expect(countB).to.equal(1)
	end)

	it("should skip listeners that were disconnected during event evaluation", function()
		local signal = Signal.new()
		local countA = 0
		local countB = 0

		local connectionB

		signal:connect(function()
			countA = countA + 1
			connectionB:disconnect()
		end)

		connectionB = signal:connect(function()
			countB = countB + 1
		end)

		signal:fire()

		expect(countA).to.equal(1)
		expect(countB).to.equal(0)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="373">
          <Properties>
            <string name="Name">Store</string>
            <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Signal = require(script.Parent.Signal)
local NoYield = require(script.Parent.NoYield)

local Store = {}

-- This value is exposed as a private value so that the test code can stay in
-- sync with what event we listen to for dispatching the Changed event.
-- It may not be Heartbeat in the future.
Store._flushEvent = RunService.Heartbeat

Store.__index = Store

--[[
	Create a new Store whose state is transformed by the given reducer function.

	Each time an action is dispatched to the store, the new state of the store
	is given by:

		state = reducer(state, action)

	Reducers do not mutate the state object, so the original state is still
	valid.
]]
function Store.new(reducer, initialState, middlewares)
	assert(typeof(reducer) == "function", "Bad argument #1 to Store.new, expected function.")
	assert(middlewares == nil or typeof(middlewares) == "table", "Bad argument #3 to Store.new, expected nil or table.")

	local self = {}

	self._reducer = reducer
	self._state = reducer(initialState, {
		type = "@@INIT",
	})
	self._lastState = self._state

	self._mutatedSinceFlush = false
	self._connections = {}

	self.changed = Signal.new()

	setmetatable(self, Store)

	local connection = self._flushEvent:Connect(function()
		self:flush()
	end)
	table.insert(self._connections, connection)

	if middlewares then
		local unboundDispatch = self.dispatch
		local dispatch = function(...)
			return unboundDispatch(self, ...)
		end

		for i = #middlewares, 1, -1 do
			local middleware = middlewares[i]
			dispatch = middleware(dispatch, self)
		end

		self.dispatch = function(self, ...)
			return dispatch(...)
		end
	end

	return self
end

--[[
	Get the current state of the Store. Do not mutate this!
]]
function Store:getState()
	return self._state
end

--[[
	Dispatch an action to the store. This allows the store's reducer to mutate
	the state of the application by creating a new copy of the state.

	Listeners on the changed event of the store are notified when the state
	changes, but not necessarily on every Dispatch.
]]
function Store:dispatch(action)
	if typeof(action) == "table" then
		if action.type == nil then
			error("action does not have a type field", 2)
		end

		self._state = self._reducer(self._state, action)
		self._mutatedSinceFlush = true
	else
		error(("actions of type %q are not permitted"):format(typeof(action)), 2)
	end
end

--[[
	Marks the store as deleted, disconnecting any outstanding connections.
]]
function Store:destruct()
	for _, connection in ipairs(self._connections) do
		connection:Disconnect()
	end

	self._connections = nil
end

--[[
	Flush all pending actions since the last change event was dispatched.
]]
function Store:flush()
	if not self._mutatedSinceFlush then
		return
	end

	self._mutatedSinceFlush = false

	-- On self.changed:fire(), further actions may be immediately dispatched, in
	-- which case self._lastState will be set to the most recent self._state,
	-- unless we cache this value first
	local state = self._state

	-- If a changed listener yields, *very* surprising bugs can ensue.
	-- Because of that, changed listeners cannot yield.
	NoYield(function()
		self.changed:fire(state, self._lastState)
	end)

	self._lastState = state
end

return Store
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="374">
          <Properties>
            <string name="Name">Store.spec</string>
            <string name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)

	describe("new", function()
		it("should instantiate with a reducer", function()
			local store = Store.new(function(state, action)
				return "hello, world"
			end)

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("hello, world")

			store:destruct()
		end)

		it("should instantiate with a reducer and an initial state", function()
			local store = Store.new(function(state, action)
				return state
			end, "initial state")

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("initial state")

			store:destruct()
		end)

		it("should instantiate with a reducer, initial state, and middlewares", function()
			local store = Store.new(function(state, action)
				return state
			end, "initial state", {})

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("initial state")

			store:destruct()
		end)

		it("should modify the dispatch method when middlewares are passed", function()
			local middlewareInstantiateCount = 0
			local middlewareInvokeCount = 0
			local passedDispatch
			local passedStore
			local passedAction

			local function reducer(state, action)
				if action.type == "test" then
					return "test state"
				end

				return state
			end

			local function testMiddleware(nextDispatch, store)
				middlewareInstantiateCount = middlewareInstantiateCount + 1
				passedDispatch = nextDispatch
				passedStore = store

				return function(action)
					middlewareInvokeCount = middlewareInvokeCount + 1
					passedAction = action

					nextDispatch(action)
				end
			end

			local store = Store.new(reducer, "initial state", { testMiddleware })

			expect(middlewareInstantiateCount).to.equal(1)
			expect(middlewareInvokeCount).to.equal(0)
			expect(passedDispatch).to.be.a("function")
			expect(passedStore).to.equal(store)

			store:dispatch({
				type = "test",
			})

			expect(middlewareInstantiateCount).to.equal(1)
			expect(middlewareInvokeCount).to.equal(1)
			expect(passedAction.type).to.equal("test")

			store:flush()

			expect(store:getState()).to.equal("test state")

			store:destruct()
		end)

		it("should execute middleware left-to-right", function()
			local events = {}

			local function reducer(state)
				return state
			end

			local function middlewareA(nextDispatch, store)
				table.insert(events, "instantiate a")
				return function(action)
					table.insert(events, "execute a")
					return nextDispatch(action)
				end
			end

			local function middlewareB(nextDispatch, store)
				table.insert(events, "instantiate b")
				return function(action)
					table.insert(events, "execute b")
					return nextDispatch(action)
				end
			end

			local store = Store.new(reducer, 5, { middlewareA, middlewareB })

			expect(#events).to.equal(2)
			expect(events[1]).to.equal("instantiate b")
			expect(events[2]).to.equal("instantiate a")

			store:dispatch({
				type = "test",
			})

			expect(#events).to.equal(4)
			expect(events[3]).to.equal("execute a")
			expect(events[4]).to.equal("execute b")
		end)

		it("should send an initial action with a 'type' field", function()
			local lastAction
			local callCount = 0

			local store = Store.new(function(state, action)
				lastAction = action
				callCount = callCount + 1

				return state
			end)

			expect(callCount).to.equal(1)
			expect(lastAction).to.be.a("table")
			expect(lastAction.type).to.be.ok()

			store:destruct()
		end)
	end)

	describe("getState", function()
		it("should get the current state", function()
			local store = Store.new(function(state, action)
				return "foo"
			end)

			local state = store:getState()

			expect(state).to.equal("foo")

			store:destruct()
		end)
	end)

	describe("dispatch", function()
		it("should be sent through the reducer", function()
			local store = Store.new(function(state, action)
				state = state or "foo"

				if action.type == "act" then
					return "bar"
				end

				return state
			end)

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("foo")

			store:dispatch({
				type = "act",
			})

			store:flush()

			expect(store:getState()).to.equal("bar")

			store:destruct()
		end)

		it("should trigger the changed event after a flush", function()
			local store = Store.new(function(state, action)
				state = state or 0

				if action.type == "increment" then
					return state + 1
				end

				return state
			end)

			local callCount = 0

			store.changed:connect(function(state, oldState)
				expect(oldState).to.equal(0)
				expect(state).to.equal(1)

				callCount = callCount + 1
			end)

			store:dispatch({
				type = "increment",
			})

			store:flush()

			expect(callCount).to.equal(1)

			store:destruct()
		end)

		it("should handle actions dispatched within the changed event", function()
			local store = Store.new(function(state, action)
				state = state or {
					value = 0,
				}

				if action.type == "increment" then
					return {
						value = state.value + 1,
					}
				elseif action.type == "decrement" then
					return {
						value = state.value - 1,
					}
				end

				return state
			end)

			local changeCount = 0

			store.changed:connect(function(state, oldState)
				expect(state).never.to.equal(oldState)

				if state.value > 0 then
					store:dispatch({
						type = "decrement",
					})
				end

				changeCount = changeCount + 1
			end)

			store:dispatch({
				type = "increment",
			})
			store:flush()
			store:flush()

			expect(changeCount).to.equal(2)

			store:destruct()
		end)

		it("should prevent yielding from changed handler", function()
			local preCount = 0
			local postCount = 0

			local store = Store.new(function(state, action)
				state = state or 0
				return state + 1
			end)

			store.changed:connect(function(state, oldState)
				preCount = preCount + 1
				wait()
				postCount = postCount + 1
			end)

			store:dispatch({
				type = "increment",
			})

			expect(function()
				store:flush()
			end).to.throw()

			expect(preCount).to.equal(1)
			expect(postCount).to.equal(0)

			store:destruct()
		end)

		it("should throw if an action is dispatched without a type field", function()
			local store = Store.new(function(state, action)
				return state
			end)

			expect(function()
				store:dispatch({})
			end).to.throw()

			store:destruct()
		end)

		it("should throw if the action is not a function or table", function()
			local store = Store.new(function(state, action)
				return state
			end)

			expect(function()
				store:dispatch(1)
			end).to.throw()

			store:destruct()
		end)
	end)

	describe("flush", function()
		it("should not fire a changed event if there were no dispatches", function()
			local store = Store.new(function()
			end)

			local count = 0
			store.changed:connect(function()
				count = count + 1
			end)

			store:flush()

			expect(count).to.equal(0)

			store:dispatch({
				type = "increment",
			})
			store:flush()

			expect(count).to.equal(1)

			store:flush()

			expect(count).to.equal(1)

			store:destruct()
		end)
	end)
end
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="375">
          <Properties>
            <string name="Name">combineReducers</string>
            <string name="Source"><![CDATA[--[[
	Create a composite reducer from a map of keys and sub-reducers.
]]
local function combineReducers(map)
	return function(state, action)
		-- If state is nil, substitute it with a blank table.
		if state == nil then
			state = {}
		end

		local newState = {}

		for key, reducer in pairs(map) do
			-- Each reducer gets its own state, not the entire state table
			newState[key] = reducer(state[key], action)
		end

		return newState
	end
end

return combineReducers
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="376">
          <Properties>
            <string name="Name">combineReducers.spec</string>
            <string name="Source"><![CDATA[return function()
	local combineReducers = require(script.Parent.combineReducers)

	it("should invoke each sub-reducer for every action", function()
		local aCount = 0
		local bCount = 0

		local reducer = combineReducers({
			a = function(state, action)
				aCount = aCount + 1
			end,
			b = function(state, action)
				bCount = bCount + 1
			end,
		})

		-- Mock reducer invocation
		reducer({}, {})
		expect(aCount).to.equal(1)
		expect(bCount).to.equal(1)
	end)

	it("should assign each sub-reducer's value to the new state", function()
		local reducer = combineReducers({
			a = function(state, action)
				return (state or 0) + 1
			end,
			b = function(state, action)
				return (state or 0) + 3
			end,
		})

		local newState = reducer({}, {})
		expect(newState.a).to.equal(1)
		expect(newState.b).to.equal(3)
	end)

	it("should not throw when state is nil", function()
		local reducer = combineReducers({
			a = function(state, action)
				return (state or 0) + 1
			end,
			b = function(state, action)
				return (state or 0) + 3
			end,
		})

		expect(function()
			reducer(nil, {})
		end).to.never.throw()
	end)
end
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="377">
          <Properties>
            <string name="Name">createReducer</string>
            <string name="Source"><![CDATA[return function(initialState, handlers)
	return function(state, action)
		if state == nil then
			state = initialState
		end

		local handler = handlers[action.type]

		if handler then
			return handler(state, action)
		end

		return state
	end
end
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="378">
          <Properties>
            <string name="Name">createReducer.spec</string>
            <string name="Source"><![CDATA[return function()
	local createReducer = require(script.Parent.createReducer)

	it("should handle actions", function()
		local reducer = createReducer({
			a = 0,
			b = 0,
		}, {
			a = function(state, action)
				return {
					a = state.a + 1,
					b = state.b,
				}
			end,
			b = function(state, action)
				return {
					a = state.a,
					b = state.b + 2,
				}
			end,
		})

		local newState = reducer({
			a = 0,
			b = 0,
		}, {
			type = "a",
		})

		expect(newState.a).to.equal(1)

		newState = reducer(newState, {
			type = "b",
		})

		expect(newState.b).to.equal(2)
	end)

	it("should return the initial state if the state is nil", function()
		local reducer = createReducer({
			a = 0,
			b = 0,
		-- We don't care about the actions here
		}, {})

		local newState = reducer(nil, {})
		expect(newState).to.be.ok()
		expect(newState.a).to.equal(0)
		expect(newState.b).to.equal(0)
	end)

	it("should still run action handlers if the state is nil", function()
		local callCount = 0

		local reducer = createReducer(0, {
			foo = function(state, action)
				callCount = callCount + 1
				return nil
			end
		})

		expect(callCount).to.equal(0)

		local newState = reducer(nil, {
			type = "foo",
		})

		expect(callCount).to.equal(1)
		expect(newState).to.equal(nil)

		newState = reducer(newState, {
			type = "foo",
		})

		expect(callCount).to.equal(2)
		expect(newState).to.equal(nil)
	end)

	it("should return the same state if the action is not handled", function()
		local initialState = {
			a = 0,
			b = 0,
		}

		local reducer = createReducer(initialState, {
			a = function(state, action)
				return {
					a = state.a + 1,
					b = state.b,
				}
			end,
			b = function(state, action)
				return {
					a = state.a,
					b = state.b + 2,
				}
			end,
		})

		local newState = reducer(initialState, {
			type = "c",
		})

		expect(newState).to.equal(initialState)
	end)
end
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="379">
          <Properties>
            <string name="Name">init.spec</string>
            <string name="Source">return function()
	describe("Rodux", function()
		it("should load", function()
			local Rodux = require(script.Parent)

			expect(Rodux.Store).to.be.ok()
		end)
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="380">
          <Properties>
            <string name="Name">loggerMiddleware</string>
            <string name="Source"><![CDATA[local indent = "    "

local function prettyPrint(value, indentLevel)
	indentLevel = indentLevel or 0
	local output = {}

	if typeof(value) == "table" then
		table.insert(output, "{\n")

		for key, value in pairs(value) do
			table.insert(output, indent:rep(indentLevel + 1))
			table.insert(output, tostring(key))
			table.insert(output, " = ")

			table.insert(output, prettyPrint(value, indentLevel + 1))
			table.insert(output, "\n")
		end

		table.insert(output, indent:rep(indentLevel))
		table.insert(output, "}")
	elseif typeof(value) == "string" then
		table.insert(output, string.format("%q", value))
		table.insert(output, " (string)")
	else
		table.insert(output, tostring(value))
		table.insert(output, " (")
		table.insert(output, typeof(value))
		table.insert(output, ")")
	end

	return table.concat(output, "")
end

-- We want to be able to override outputFunction in tests, so the shape of this
-- module is kind of unconventional.
--
-- We fix it this weird shape in init.lua.
local loggerMiddleware = {
	outputFunction = print,
}

function loggerMiddleware.middleware(nextDispatch, store)
	return function(action)
		local result = nextDispatch(action)

		loggerMiddleware.outputFunction(("Action dispatched: %s\nState changed to: %s"):format(
			prettyPrint(action),
			prettyPrint(store:getState())
		))

		return result
	end
end

return loggerMiddleware
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="381">
          <Properties>
            <string name="Name">loggerMiddleware.spec</string>
            <string name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)
	local loggerMiddleware = require(script.Parent.loggerMiddleware)

	it("should print whenever an action is dispatched", function()
		local outputCount = 0
		local outputMessage

		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {
			fooValue = 12345,
			barValue = {
				bazValue = "hiBaz",
			},
		}, { loggerMiddleware.middleware })

		loggerMiddleware.outputFunction = function(message)
			outputCount = outputCount + 1
			outputMessage = message
		end

		store:dispatch({
			type = "testActionType",
		})

		expect(outputCount).to.equal(1)
		expect(outputMessage:find("testActionType")).to.be.ok()
		expect(outputMessage:find("fooValue")).to.be.ok()
		expect(outputMessage:find("12345")).to.be.ok()
		expect(outputMessage:find("barValue")).to.be.ok()
		expect(outputMessage:find("bazValue")).to.be.ok()
		expect(outputMessage:find("hiBaz")).to.be.ok()

		loggerMiddleware.outputFunction = print
	end)
end
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="382">
          <Properties>
            <string name="Name">thunkMiddleware</string>
            <string name="Source"><![CDATA[--[[
	A middleware that allows for functions to be dispatched.
	Functions will receive a single argument, the store itself.
	This middleware consumes the function; middleware further down the chain
	will not receive it.
]]
local function thunkMiddleware(nextDispatch, store)
	return function(action)
		if typeof(action) == "function" then
			return action(store)
		else
			return nextDispatch(action)
		end
	end
end

return thunkMiddleware
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="383">
          <Properties>
            <string name="Name">thunkMiddleware.spec</string>
            <string name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)
	local thunkMiddleware = require(script.Parent.thunkMiddleware)

	it("should dispatch thunks", function()
		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })
		local thunkCount = 0

		local function thunk(store)
			thunkCount = thunkCount + 1
		end

		store:dispatch(thunk)

		expect(thunkCount).to.equal(1)
	end)

	it("should allow normal actions to pass through", function()
		local reducerCount = 0

		local function reducer(state, action)
			reducerCount = reducerCount + 1
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })

		store:dispatch({
			type = "test",
		})

		-- Reducer will be invoked twice:
		-- Once when creating the store (@@INIT action)
		-- Once when the test action is dispatched
		expect(reducerCount).to.equal(2)
	end)

	it("should return the value from the thunk", function()
		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })
		local thunkValue = "test"

		local function thunk(store)
			return thunkValue
		end

		local result = store:dispatch(thunk)

		expect(result).to.equal(thunkValue)
	end)
end
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="384">
        <Properties>
          <string name="Name">t</string>
          <string name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

-- regular lua compatibility
local typeof = typeof or type

local function primitive(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

local t = {}

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false, "any expected, got nil"
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = primitive("boolean")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = primitive("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = primitive("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = primitive("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = primitive("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = primitive("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = primitive("userdata")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false, "unexpected NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	if value ~= value then
		return true
	else
		return false, "unexpected non-NaN value"
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = primitive("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = primitive("BrickColor")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = primitive("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = primitive("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = primitive("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = primitive("ColorSequenceKeypoint")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = primitive("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = primitive("Faces")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = primitive("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = primitive("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = primitive("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = primitive("NumberSequenceKeypoint")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = primitive("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = primitive("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = primitive("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = primitive("Ray")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = primitive("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = primitive("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = primitive("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = primitive("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = primitive("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = primitive("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = primitive("Vector2")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = primitive("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = primitive("Vector3int16")

-- roblox enum types

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = primitive("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = primitive("EnumItem")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = primitive("RBXScriptSignal")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = primitive("RBXScriptConnection")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false, string.format("expected %s, got %s", tostring(literal), tostring(value))
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success, errMsg = t.number(value)
	if not success then
		return false, errMsg or ""
	end

	if value % 1 == 0 then
		return true
	else
		return false, string.format("integer expected, got %s", value)
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value >= min then
			return true
		else
			return false, string.format("number >= %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg
		end

		if value <= max then
			return true
		else
			return false, string.format("number <= %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if min < value then
			return true
		else
			return false, string.format("number > %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value < max then
			return true
		else
			return false, string.format("number < %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min) and t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min) and t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess, stringErrMsg = t.string(value)
		if not stringSuccess then
			return false, stringErrMsg
		end

		if string.match(value, pattern) == nil then
			return false, string.format("%q failed to match pattern %q", value, pattern)
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success, errMsg = check(value)
		if success then
			return true
		else
			return false, string.format("(optional) %s", errMsg or "")
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = {...}
	return function(...)
		local args = {...}
		for i, check in ipairs(checks) do
			local success, errMsg = check(args[i])
			if success == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", i, errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key in pairs(value) do
			local success, errMsg = check(key)
			if success == false then
				return false, string.format("bad key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key, val in pairs(value) do
			local success, errMsg = check(val)
			if success == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck), t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess, keyErr = keyChecker(value)
		if not keySuccess then
			return false, keyErr or ""
		end

		local valueSuccess, valueErr = valueChecker(value)
		if not valueSuccess then
			return false, valueErr or ""
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
	--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[array] %s", keyErrMsg or "")
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false, string.format("[array] key %s must be sequential", tostring(key))
				end
			end

			local valueSuccess, valueErrMsg = valuesCheck(value)
			if not valueSuccess then
				return false, string.format("[array] %s", valueErrMsg or "")
			end

			return true
		end
	end

	--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[strictArray] %s", keyErrMsg or "")
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false, string.format("[strictArray] Array size exceeds limit of %d", #valueTypes)
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess, typeErrMsg = typeFn(value[idx])
				if not typeSuccess then
					return false, string.format("[strictArray] Array index #%d - %s", idx, typeErrMsg)
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
	--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = {...}
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false, "bad type for union"
		end
	end

	--[[**
		Alias for t.union
	**--]]
	t.some = t.union

	--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = {...}
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success, errMsg = check(value)
				if not success then
					return false, errMsg or ""
				end
			end

			return true
		end
	end

	--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
	--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			return true
		end
	end

	--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false, string.format("[interface] unexpected field %q", tostring(key))
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if value.ClassName ~= className then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if not value:IsA(className) then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess, enumItemErrMsg = t.EnumItem(value)
		if not enumItemSuccess then
			return false, enumItemErrMsg
		end

		if value.EnumType == enum then
			return true
		else
			return false, string.format("enum of %s expected, got enum of %s", tostring(enum), tostring(value.EnumType))
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

	--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The functon to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

	--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess, instanceErrMsg = t.Instance(value)
			if not instanceSuccess then
				return false, instanceErrMsg or ""
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false, string.format("Cannot process multiple children with the same name %q", name)
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success, errMsg = check(childrenByName[name])
				if not success then
					return false, string.format("[%s.%s] %s", value:GetFullName(), name, errMsg or "")
				end
			end

			return true
		end
	end
end

return t
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="385">
          <Properties>
            <string name="Name">init.spec</string>
            <string name="Source">return function()
	local t = require(script.Parent)

	it("should support basic types", function()
		assert(t.any(""))
		assert(t.boolean(true))
		assert(t.none(nil))
		assert(t.number(1))
		assert(t.string("foo"))
		assert(t.table({}))

		assert(not (t.any(nil)))
		assert(not (t.boolean("true")))
		assert(not (t.none(1)))
		assert(not (t.number(true)))
		assert(not (t.string(true)))
		assert(not (t.table(82)))
	end)

	it("should support special number types", function()
		local maxTen = t.numberMax(10)
		local minTwo = t.numberMin(2)
		local maxTenEx = t.numberMaxExclusive(10)
		local minTwoEx = t.numberMinExclusive(2)
		local constrainedEightToEleven = t.numberConstrained(8, 11)
		local constrainedEightToElevenEx = t.numberConstrainedExclusive(8, 11)

		assert(maxTen(5))
		assert(maxTen(10))
		assert(not (maxTen(11)))
		assert(not (maxTen()))

		assert(minTwo(5))
		assert(minTwo(2))
		assert(not (minTwo(1)))
		assert(not (minTwo()))

		assert(maxTenEx(5))
		assert(maxTenEx(9))
		assert(not (maxTenEx(10)))
		assert(not (maxTenEx()))

		assert(minTwoEx(5))
		assert(minTwoEx(3))
		assert(not (minTwoEx(2)))
		assert(not (minTwoEx()))

		assert(not (constrainedEightToEleven(7)))
		assert(constrainedEightToEleven(8))
		assert(constrainedEightToEleven(9))
		assert(constrainedEightToEleven(11))
		assert(not (constrainedEightToEleven(12)))
		assert(not (constrainedEightToEleven()))

		assert(not (constrainedEightToElevenEx(7)))
		assert(not (constrainedEightToElevenEx(8)))
		assert(constrainedEightToElevenEx(9))
		assert(not (constrainedEightToElevenEx(11)))
		assert(not (constrainedEightToElevenEx(12)))
		assert(not (constrainedEightToElevenEx()))
	end)

	it("should support optional types", function()
		local check = t.optional(t.string)
		assert(check(""))
		assert(check())
		assert(not (check(1)))
	end)

	it("should support tuple types", function()
		local myTupleCheck = t.tuple(t.number, t.string, t.optional(t.number))
		assert(myTupleCheck(1, "2", 3))
		assert(myTupleCheck(1, "2"))
		assert(not (myTupleCheck(1, "2", "3")))
	end)

	it("should support union types", function()
		local numberOrString = t.union(t.number, t.string)
		assert(numberOrString(1))
		assert(numberOrString("1"))
		assert(not (numberOrString(nil)))
	end)

	it("should support literal types", function()
		local checkSingle = t.literal("foo")
		local checkUnion = t.union(t.literal("foo"), t.literal("bar"), t.literal("oof"))

		assert(checkSingle("foo"))
		assert(checkUnion("foo"))
		assert(checkUnion("bar"))
		assert(checkUnion("oof"))

		assert(not (checkSingle("FOO")))
		assert(not (checkUnion("FOO")))
		assert(not (checkUnion("BAR")))
		assert(not (checkUnion("OOF")))
	end)

	it("should support multiple literal types", function()
		local checkSingle = t.literal("foo")
		local checkUnion = t.literal("foo", "bar", "oof")

		assert(checkSingle("foo"))
		assert(checkUnion("foo"))
		assert(checkUnion("bar"))
		assert(checkUnion("oof"))

		assert(not (checkSingle("FOO")))
		assert(not (checkUnion("FOO")))
		assert(not (checkUnion("BAR")))
		assert(not (checkUnion("OOF")))
	end)

	it("should support intersection types", function()
		local integerMax5000 = t.intersection(t.integer, t.numberMax(5000))
		assert(integerMax5000(1))
		assert(not (integerMax5000(5001)))
		assert(not (integerMax5000(1.1)))
		assert(not (integerMax5000("1")))
	end)

	describe("array", function()
		it("should support array types", function()
			local stringArray = t.array(t.string)
			local anyArray = t.array(t.any)
			local stringValues = t.values(t.string)
			assert(not (anyArray("foo")))
			assert(anyArray({1, "2", 3}))
			assert(not (stringArray({1, "2", 3})))
			assert(not (stringArray()))
			assert(not (stringValues()))
			assert(anyArray({"1", "2", "3"}, t.string))
			assert(not (anyArray({
				foo = "bar"
			})))
			assert(not (anyArray({
				[1] = "non",
				[5] = "sequential"
			})))
		end)

		it("should not be fooled by sparse arrays", function()
			local anyArray = t.array(t.any)

			assert(not (anyArray({
				[1] = 1,
				[2] = 2,
				[4] = 4,
			})))
		end)
	end)

	it("should support map types", function()
		local stringNumberMap = t.map(t.string, t.number)
		assert(stringNumberMap({}))
		assert(stringNumberMap({a = 1}))
		assert(not (stringNumberMap({[1] = "a"})))
		assert(not (stringNumberMap({a = "a"})))
		assert(not (stringNumberMap()))
	end)

	it("should support set types", function()
		local stringSet = t.set(t.string)
		assert(stringSet({}))
		assert(stringSet({a = true}))
		assert(not (stringSet({[1] = "a"})))
		assert(not (stringSet({a = "a"})))
		assert(not (stringSet({a = false})))
		assert(not (stringSet()))
	end)

	it("should support interface types", function()
		local IVector3 = t.interface({
			x = t.number,
			y = t.number,
			z = t.number,
		})

		assert(IVector3({
			w = 0,
			x = 1,
			y = 2,
			z = 3,
		}))

		assert(not (IVector3({
			w = 0,
			x = 1,
			y = 2,
		})))
	end)

	it("should support strict interface types", function()
		local IVector3 = t.strictInterface({
			x = t.number,
			y = t.number,
			z = t.number,
		})

		assert(not (IVector3(0)))

		assert(not (IVector3({
			w = 0,
			x = 1,
			y = 2,
			z = 3,
		})))

		assert(not (IVector3({
			w = 0,
			x = 1,
			y = 2,
		})))

		assert(IVector3({
			x = 1,
			y = 2,
			z = 3,
		}))
	end)

	it("should support deep interface types", function()
		local IPlayer = t.interface({
			name = t.string,
			inventory = t.interface({
				size = t.number
			})
		})

		assert(IPlayer({
			name = "TestPlayer",
			inventory = {
				size = 1
			}
		}))

		assert(not (IPlayer({
			inventory = {
				size = 1
			}
		})))

		assert(not (IPlayer({
			name = "TestPlayer",
			inventory = {
			}
		})))

		assert(not (IPlayer({
			name = "TestPlayer",
		})))
	end)

	it("should support deep optional interface types", function()
		local IPlayer = t.interface({
			name = t.string,
			inventory = t.optional(t.interface({
				size = t.number
			}))
		})

		assert(IPlayer({
			name = "TestPlayer"
		}))

		assert(not (IPlayer({
			name = "TestPlayer",
			inventory = {
			}
		})))

		assert(IPlayer({
			name = "TestPlayer",
			inventory = {
				size = 1
			}
		}))
	end)

	it("should support Roblox Instance types", function()
		local stringValueCheck = t.instanceOf("StringValue")
		local stringValue = Instance.new("StringValue")
		local boolValue = Instance.new("BoolValue")

		assert(stringValueCheck(stringValue))
		assert(not (stringValueCheck(boolValue)))
		assert(not (stringValueCheck()))
	end)

	it("should support Roblox Instance types inheritance", function()
		local guiObjectCheck = t.instanceIsA("GuiObject")
		local frame = Instance.new("Frame")
		local textLabel = Instance.new("TextLabel")
		local stringValue = Instance.new("StringValue")

		assert(guiObjectCheck(frame))
		assert(guiObjectCheck(textLabel))
		assert(not (guiObjectCheck(stringValue)))
		assert(not (guiObjectCheck()))
	end)

	it("should support Roblox Enum types", function()
		local sortOrderEnumCheck = t.enum(Enum.SortOrder)
		assert(t.Enum(Enum.SortOrder))
		assert(not (t.Enum("Enum.SortOrder")))

		assert(t.EnumItem(Enum.SortOrder.Name))
		assert(not (t.EnumItem("Enum.SortOrder.Name")))

		assert(sortOrderEnumCheck(Enum.SortOrder.Name))
		assert(sortOrderEnumCheck(Enum.SortOrder.Custom))
		assert(not (sortOrderEnumCheck(Enum.EasingStyle.Linear)))
		assert(not (sortOrderEnumCheck()))
	end)

	it("should support Roblox RBXScriptSignal", function()
		assert(t.RBXScriptSignal(game.ChildAdded))
		assert(not (t.RBXScriptSignal(nil)))
		assert(not (t.RBXScriptSignal(Vector3.new())))
	end)

	-- TODO: Add this back when Lemur supports it
	-- it("should support Roblox RBXScriptConnection", function()
	-- 	local conn = game.ChildAdded:Connect(function() end)
	-- 	assert(t.RBXScriptConnection(conn))
	-- 	assert(not (t.RBXScriptConnection(nil)))
	-- 	assert(not (t.RBXScriptConnection(Vector3.new())))
	-- end)

	it("should support wrapping function types", function()
		local checkFoo = t.tuple(t.string, t.number, t.optional(t.string))
		local foo = t.wrap(function(a, b, c)
			local result = string.format("%s %d", a, b)
			if c then
				result = result .. " " .. c
			end
			return result
		end, checkFoo)

		assert(not (pcall(foo)))
		assert(not (pcall(foo, "a")))
		assert(not (pcall(foo, 2)))
		assert(pcall(foo, "a", 1))
		assert(pcall(foo, "a", 1, "b"))
	end)

	it("should support strict types", function()
		local myType = t.strict(t.tuple(t.string, t.number))
		assert(not (pcall(function()
			myType("a", "b")
		end)))
		assert(pcall(function()
			myType("a", 1)
		end))
	end)

	it("should support common OOP types", function()
		local MyClass = {}
		MyClass.__index = MyClass

		function MyClass.new()
			local self = setmetatable({}, MyClass)
			return self
		end

		local function instanceOfClass(class)
			return function(value)
				local tableSuccess, tableErrMsg = t.table(value)
				if not tableSuccess then
					return false, tableErrMsg or ""
				end

				local mt = getmetatable(value)
				if not mt or mt.__index ~= class then
					return false, "bad member of class"
				end

				return true
			end
		end

		local instanceOfMyClass = instanceOfClass(MyClass)

		local myObject = MyClass.new()
		assert(instanceOfMyClass(myObject))
		assert(not (instanceOfMyClass({})))
		assert(not (instanceOfMyClass()))
	end)

	it("should not treat NaN as numbers", function()
		assert(t.number(1))
		assert(not (t.number(0/0)))
		assert(not (t.number("1")))
	end)

	it("should not treat numbers as NaN", function()
		assert(not (t.nan(1)))
		assert(t.nan(0/0))
		assert(not (t.nan("1")))
	end)

	it("should allow union of number and NaN", function()
		local numberOrNaN = t.union(t.number, t.nan)
		assert(numberOrNaN(1))
		assert(numberOrNaN(0/0))
		assert(not (numberOrNaN("1")))
	end)

	it("should support non-string keys for interfaces", function()
		local key = {}
		local myInterface = t.interface({ [key] = t.number })
		assert(myInterface({ [key] = 1 }))
		assert(not (myInterface({ [key] = "1" })))
	end)

	it("should support failing on non-string keys for strict interfaces", function()
		local myInterface = t.strictInterface({ a = t.number })
		assert(not (myInterface({ a = 1, [{}] = 2 })))
	end)

	it("should support children", function()
		local myInterface = t.interface({
			buttonInFrame = t.intersection(t.instanceOf("Frame"), t.children({
				MyButton = t.instanceOf("ImageButton")
			}))
		})

		assert(not (t.children({})(5)))
		assert(not (myInterface({ buttonInFrame = Instance.new("Frame") })))

		do
			local frame = Instance.new("Frame")
			local button = Instance.new("ImageButton", frame)
			button.Name = "MyButton"
			assert(myInterface({ buttonInFrame = frame }))
		end

		do
			local frame = Instance.new("Frame")
			local button = Instance.new("ImageButton", frame)
			button.Name = "NotMyButton"
			assert(not (myInterface({ buttonInFrame = frame })))
		end

		do
			local frame = Instance.new("Frame")
			local button = Instance.new("TextButton", frame)
			button.Name = "MyButton"
			assert(not (myInterface({ buttonInFrame = frame })))
		end

		do
			local frame = Instance.new("Frame")
			local button1 = Instance.new("ImageButton", frame)
			button1.Name = "MyButton"
			local button2 = Instance.new("ImageButton", frame)
			button2.Name = "MyButton"
			assert(not (myInterface({ buttonInFrame = frame })))
		end
	end)

	it("should support t.instanceOf shorthand", function()
		local myInterface = t.interface({
			buttonInFrame = t.instanceOf("Frame", {
				MyButton = t.instanceOf("ImageButton")
			})
		})

		assert(not (t.children({})(5)))
		assert(not (myInterface({ buttonInFrame = Instance.new("Frame") })))

		do
			local frame = Instance.new("Frame")
			local button = Instance.new("ImageButton", frame)
			button.Name = "MyButton"
			assert(myInterface({ buttonInFrame = frame }))
		end

		do
			local frame = Instance.new("Frame")
			local button = Instance.new("ImageButton", frame)
			button.Name = "NotMyButton"
			assert(not (myInterface({ buttonInFrame = frame })))
		end

		do
			local frame = Instance.new("Frame")
			local button = Instance.new("TextButton", frame)
			button.Name = "MyButton"
			assert(not (myInterface({ buttonInFrame = frame })))
		end

		do
			local frame = Instance.new("Frame")
			local button1 = Instance.new("ImageButton", frame)
			button1.Name = "MyButton"
			local button2 = Instance.new("ImageButton", frame)
			button2.Name = "MyButton"
			assert(not (myInterface({ buttonInFrame = frame })))
		end
	end)

	it("should support t.instanceIsA shorthand", function()
		local myInterface = t.interface({
			buttonInFrame = t.instanceIsA("Frame", {
				MyButton = t.instanceIsA("ImageButton")
			})
		})

		assert(not (t.children({})(5)))
		assert(not (myInterface({ buttonInFrame = Instance.new("Frame") })))

		do
			local frame = Instance.new("Frame")
			local button = Instance.new("ImageButton", frame)
			button.Name = "MyButton"
			assert(myInterface({ buttonInFrame = frame }))
		end

		do
			local frame = Instance.new("Frame")
			local button = Instance.new("ImageButton", frame)
			button.Name = "NotMyButton"
			assert(not (myInterface({ buttonInFrame = frame })))
		end

		do
			local frame = Instance.new("Frame")
			local button = Instance.new("TextButton", frame)
			button.Name = "MyButton"
			assert(not (myInterface({ buttonInFrame = frame })))
		end

		do
			local frame = Instance.new("Frame")
			local button1 = Instance.new("ImageButton", frame)
			button1.Name = "MyButton"
			local button2 = Instance.new("ImageButton", frame)
			button2.Name = "MyButton"
			assert(not (myInterface({ buttonInFrame = frame })))
		end
	end)

	it("should support t.match", function()
		local check = t.match("%d+")
		assert(check("123"))
		assert(not (check("abc")))
		assert(not (check()))
	end)

	it("should support t.keyOf", function()
		local myNewEnum = {
			OptionA = {},
			OptionB = {},
		}
		local check = t.keyOf(myNewEnum)
		assert(check("OptionA"))
		assert(not (check("OptionC")))
	end)

	it("should support t.valueOf", function()
		local myNewEnum = {
			OptionA = {},
			OptionB = {},
		}
		local check = t.valueOf(myNewEnum)
		assert(check(myNewEnum.OptionA))
		assert(not (check(1010)))
	end)

	it("should support t.strictArray", function()
		local fixedArrayCheck = t.strictArray(t.number, t.number)

		assert(fixedArrayCheck({1, 2}))
		assert(not fixedArrayCheck({1, 2, 3}))
		assert(not fixedArrayCheck({10}))
		assert(not fixedArrayCheck({"Hello", 10}))
		assert(not fixedArrayCheck({ Foo = "Bar" }))

		local fixedArrayCheck2 = t.strictArray(t.number, t.number, t.optional(t.string))

		assert(fixedArrayCheck2({10, 20}))
		assert(fixedArrayCheck2({10, 20, "Hello"}))
		assert(not fixedArrayCheck2({10, 20, 30}))
	end)
end</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="386">
          <Properties>
            <string name="Name">ts</string>
            <string name="Source">-- t: a runtime typechecker for Roblox

-- regular lua compatibility
local typeof = typeof or type

local function primitive(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

local t = {}

function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

t.boolean = primitive("boolean")
t.thread = primitive("thread")
t.callback = primitive("function")
t["function"] = t.callback
t.none = primitive("nil")
t["nil"] = t.none
t.string = primitive("string")
t.table = primitive("table")
t.userdata = primitive("userdata")

function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

function t.nan(value)
	if value ~= value then
		return true
	else
		return false
	end
end

-- roblox types

t.Axes = primitive("Axes")
t.BrickColor = primitive("BrickColor")
t.CFrame = primitive("CFrame")
t.Color3 = primitive("Color3")
t.ColorSequence = primitive("ColorSequence")
t.ColorSequenceKeypoint = primitive("ColorSequenceKeypoint")
t.DockWidgetPluginGuiInfo = primitive("DockWidgetPluginGuiInfo")
t.Faces = primitive("Faces")
t.Instance = primitive("Instance")
t.NumberRange = primitive("NumberRange")
t.NumberSequence = primitive("NumberSequence")
t.NumberSequenceKeypoint = primitive("NumberSequenceKeypoint")
t.PathWaypoint = primitive("PathWaypoint")
t.PhysicalProperties = primitive("PhysicalProperties")
t.Random = primitive("Random")
t.Ray = primitive("Ray")
t.Rect = primitive("Rect")
t.Region3 = primitive("Region3")
t.Region3int16 = primitive("Region3int16")
t.TweenInfo = primitive("TweenInfo")
t.UDim = primitive("UDim")
t.UDim2 = primitive("UDim2")
t.Vector2 = primitive("Vector2")
t.Vector3 = primitive("Vector3")
t.Vector3int16 = primitive("Vector3int16")
t.Enum = primitive("Enum")
t.EnumItem = primitive("EnumItem")
t.RBXScriptSignal = primitive("RBXScriptSignal")
t.RBXScriptConnection = primitive("RBXScriptConnection")

function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end
			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end
		return t.union(unpack(literals))
	end
end

t.exactly = t.literal

function t.keyOf(keyTable)
	local keys = {}
	for key in pairs(keyTable) do
		keys[#keys + 1] = key
	end
	return t.literal(unpack(keys))
end

function t.valueOf(valueTable)
	local values = {}
	for _, value in pairs(valueTable) do
		values[#values + 1] = value
	end
	return t.literal(unpack(values))
end

function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end
	if value%1 == 0 then
		return true
	else
		return false
	end
end

function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if value >= min then
			return true
		else
			return false
		end
	end
end

function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if value &lt;= max then
			return true
		else
			return false
		end
	end
end

function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if min &lt; value then
			return true
		else
			return false
		end
	end
end

function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end
		if value &lt; max then
			return true
		else
			return false
		end
	end
end

t.numberPositive = t.numberMinExclusive(0)
t.numberNegative = t.numberMaxExclusive(0)

function t.numberConstrained(min, max)
	assert(t.number(min) and t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)
	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

function t.numberConstrainedExclusive(min, max)
	assert(t.number(min) and t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)
	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end
		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

function t.tuple(...)
	local checks = {...}
	return function(...)
		local args = {...}
		for i = 1, #checks do
			local success = checks[i](args[i])
			if success == false then
				return false
			end
		end
		return true
	end
end

function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck), t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)
	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)

	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)
		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _, _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key &lt; 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes &lt; #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)

	function t.union(...)
		local checks = {...}
		assert(callbackArray(checks))
		return function(value)
			for _, check in pairs(checks) do
				if check(value) then
					return true
				end
			end
			return false
		end
	end

	function t.intersection(...)
		local checks = {...}
		assert(callbackArray(checks))
		return function(value)
			for _, check in pairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end
			return true
		end
	end
end

do
	local checkInterface = t.map(t.any, t.callback)

	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end
			return true
		end
	end

	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

function t.instanceOf(className)
	assert(t.string(className))
	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		return true
	end
end
t.instance = t.instanceOf

function t.instanceIsA(className)
	assert(t.string(className))
	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		return true
	end
end

function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in pairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end
					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return t</string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <SharedStrings>
    <SharedString md5="KVKo+PkbhmMH7yw3CVz5Ng==">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AAAANQAAADQAAAAnAAAALgAAADQAAAA1AAAAIgAAADQAAAAiAAAAJwAAADYAAAAoAAAAMQAAADYAAAAxAAAAMwAAADYAAAAzAAAAHwAAADYAAAAfAAAAKAAAADcAAAALAAAACgAAADcAAAAKAAAAFwAAADgAAAAIAAAAGgAAADgAAAAaAAAAMwAAADgAAAAzAAAAMgAAADkAAAAMAAAAGwAAADkAAAAbAAAANQAAADkAAAAZAAAADAAAADoAAAAVAAAACAAAADoAAAAIAAAAOAAAADoAAAA4AAAAMgAAADoAAAAyAAAAFgAAADoAAAAWAAAAFQAAADsAAAAmAAAAEwAAADsAAAAPAAAADgAAADsAAAATAAAADwAAADwAAAAEAAAAKQAAAD0AAAAqAAAALAAAAD0AAAAsAAAALQAAAD0AAAAtAAAAKgAAAD4AAAAhAAAAIAAAAD4AAAAgAAAAKgAAAD4AAAAqAAAAIQAAAD8AAAA8AAAAKQAAAD8AAAABAAAAFwAAAD8AAAACAAAAAQAAAD8AAAApAAAAAgAAAEAAAAAkAAAAIwAAAEAAAAAjAAAAJQAAAEAAAAAlAAAAJAAAAEEAAAALAAAANwAAAEEAAAA3AAAAFwAAAEIAAAAYAAAAHgAAAEIAAAAsAAAAKwAAAEIAAAAdAAAAGAAAAEIAAAArAAAAIAAAAEMAAAAzAAAAGgAAAEMAAAAfAAAAMwAAAEMAAAAgAAAAHwAAAEMAAAAaAAAAHQAAAEQAAAAZAAAAOQAAAEQAAAA5AAAANQAAAEQAAAAeAAAAGQAAAEQAAAA1AAAALgAAAEQAAAAuAAAALAAAAEUAAAAeAAAARAAAAEUAAABEAAAALAAAAEUAAAAsAAAAQgAAAEUAAABCAAAAHgAAAEYAAAAgAAAAQwAAAEYAAABDAAAAHQAAAEYAAAAdAAAAQgAAAEYAAABCAAAAIAAAAEcAAAAjAAAAIgAAAEcAAAA1AAAAGwAAAEcAAAAiAAAANQAAAEcAAAAbAAAAFgAAAEgAAAABAAAAAAAAAEgAAAAAAAAAMAAAAEkAAAAcAAAABgAAAEkAAAAGAAAALwAAAEoAAAAjAAAARwAAAEoAAABHAAAAFgAAAEoAAAAWAAAAMgAAAEoAAAAyAAAAIwAAAEsAAAAcAAAASQAAAEsAAABJAAAALwAAAEsAAAATAAAAHAAAAEsAAAAUAAAAEwAAAEsAAAAvAAAAFAAAAEwAAAABAAAASAAAAEwAAABIAAAAMAAAAEwAAAAcAAAAAQAAAEwAAAAHAAAAHAAAAEwAAAAwAAAABwAAAE0AAAA8AAAAPwAAAE0AAAA/AAAAFwAAAE0AAAAEAAAAPAAAAE0AAAAKAAAABAAAAE0AAAAXAAAACgAAAE4AAAAOAAAAJgAAAE4AAAAmAAAAOwAAAE4AAAA7AAAADgAAAE8AAAAXAAAAJgAAAE8AAABBAAAAFwAAAE8AAAAmAAAACwAAAE8AAAALAAAAQQAAAA==</SharedString>
    <SharedString md5="FJBsQqAd6JZHNbD3qi1kFA==">Q1NHUEhTBwAAAAIP3kZAPkg3vD6a57tOI7E8zFyFP1BIu7vaMAO8OxaCP+mBNzyqGIY/EAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPy0AAAAEAAAAwqCEvyAvoT4Q/NC9HRWpvtJyWz18Dne/T+9av20SBr+034C+KPAIv20SBr+mLj8/3aHlviAvoT58Dnc/JmSxvhEgdT/0E2C+uMo2vG0SBj9wXl2/hvCEu20SBr9wXl2/DEU+vuzFh78Q/NC9F9poPnldM799S0A/1HoTP53JuD7R91I/gkYuPuzFhz9AaiA+HcphPweOtj6tnvy+yqlXP/fQK7+86t48wqCEP9JyW7286t48TgAAAAAAAAABAAAAAgAAAAAAAAACAAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAABQAAAAAAAAAFAAAAAQAAAAEAAAAFAAAABgAAAAEAAAAGAAAABwAAAAEAAAAHAAAAAgAAAAIAAAAHAAAACAAAAAIAAAAIAAAAAwAAAAMAAAAIAAAACQAAAAMAAAAJAAAABAAAAAQAAAAKAAAACwAAAAQAAAALAAAABQAAAAQAAAAJAAAACgAAAAUAAAALAAAABgAAAAYAAAALAAAADAAAAAYAAAAMAAAABwAAAAcAAAANAAAACAAAAAcAAAAMAAAADQAAAAgAAAANAAAACQAAAAkAAAANAAAACgAAAAoAAAAMAAAACwAAAAoAAAANAAAADgAAAAoAAAAOAAAADAAAAAwAAAAOAAAADQAAAA==</SharedString>
    <SharedString md5="hocqLw6vmtVO0ScHwui/oQ==">Q1NHUEhTBwAAAALZUwhBKybkOy9cqz07pE4724/HQD4jSTxC8gE+f4K+QHpGsj5wVZtAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPzkAAAAEAAAANlulP2ikAb72tPw8z+ooP5azt75mnaS/MmtJP/Zybj8CVnS/sAmLPxeEAD+CpyQ/+Cl4P6a4Sb88oJ0+4Fwwv1swLDw4gLO/T1/8Pm2Ssz4Sscm/EPiSPuDMn78TwN09iBypvtTxlL/q6Aq/o/0PvuDMnz8hGXG/K2ghPyermT8Qk6E+h5gEvXx1vj4Ssck/ueOXPoN8175yGck/NhkTvj7ia78qJ6A/OWmZv8Ah6r6EUCw/Nlulv/nGij5XaAO9QrFEv7SBlD+jiEm+fna6vEsrmj/TGzw/KvqCv9GDOD+1wA0/ZgAAAAAAAAABAAAAAgAAAAAAAAACAAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAFAAAABgAAAAEAAAAGAAAAAgAAAAEAAAAEAAAABwAAAAEAAAAHAAAACAAAAAEAAAAIAAAABQAAAAIAAAAGAAAACQAAAAIAAAAJAAAACgAAAAIAAAAKAAAAAwAAAAMAAAAKAAAACwAAAAMAAAALAAAADAAAAAMAAAAMAAAABAAAAAQAAAAMAAAADQAAAAQAAAANAAAABwAAAAUAAAAIAAAADgAAAAUAAAAOAAAADwAAAAUAAAAPAAAAEAAAAAUAAAAQAAAACQAAAAUAAAAJAAAABgAAAAcAAAANAAAACAAAAAgAAAANAAAADgAAAAkAAAAQAAAAEQAAAAkAAAARAAAACgAAAAoAAAARAAAACwAAAAsAAAARAAAAEgAAAAsAAAASAAAADgAAAAsAAAAOAAAADQAAAAsAAAANAAAADAAAAA4AAAASAAAADwAAAA8AAAASAAAAEAAAABAAAAASAAAAEQAAAA==</SharedString>
    <SharedString md5="2f+244QVPupBDvrmXP0cmw==">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97+7S4k/ppsCvsa797+qoc0+bVZOv8i7978AbMI+PRqdvLQyZ8AAbMI+loryvhhxbsAAbMI+MP45wPX2HsDnJQxAMP45wAiGH8C2KRtArEfMvsa797/r0QdAAAAAAMHJGsASgNE+AAAAAFN7+L+83P8/AACAsSu+b8CLQOg+QGwcvxc3cMAcbto+QAcevxBAcMAsAQU/IVC4rsa7979JVqc/winpvwRGB8AIH10/wYF+v5SiQMA4MPw+gOn9vhFrbcACGyw/AlCqvBnHasA4/zU/MP45wLI9IcAx9xNAAAAAAEWvLcAAbMI+bResvgYhb8AAbMI+AACAMZ65asDUIDE/fFoDwMi797+1GZc/YSO8vsi7978jpwhAOxqWvsa7978AbMI+AAAAAEMBXcAAbMI+dUcUv5yaW8AAbMI+wSkLv4HpbsCA4cg+wetDv/zQWcAwKeA+Co4FwMa7978XopM/qe/Nvca7979kQBA/rgAAAAAAAAABAAAAAgAAAAMAAAAEAAAAAgAAAAUAAAAGAAAAAAAAAAcAAAABAAAAAAAAAAgAAAAJAAAACgAAAAsAAAAFAAAAAAAAAAsAAAAKAAAADAAAAA0AAAAJAAAACAAAAA0AAAABAAAABwAAAA4AAAAPAAAACwAAAA4AAAALAAAAAAAAAA4AAAAAAAAAAgAAAA4AAAACAAAADwAAABAAAAARAAAABgAAABAAAAAGAAAADAAAABAAAAAKAAAAEQAAABAAAAAMAAAACgAAABIAAAAFAAAACwAAABIAAAALAAAADAAAABIAAAAGAAAABQAAABIAAAAMAAAABgAAABMAAAAIAAAACgAAABMAAAABAAAACAAAABMAAAADAAAAAgAAABQAAAAKAAAACwAAABQAAAAEAAAAAwAAABQAAAADAAAACgAAABUAAAAJAAAAEQAAABUAAAARAAAACgAAABUAAAAKAAAACQAAABYAAAAGAAAABwAAABYAAAAHAAAAAAAAABcAAAAJAAAADQAAABcAAAANAAAABwAAABcAAAARAAAACQAAABcAAAAGAAAAEQAAABcAAAAHAAAABgAAABgAAAACAAAAAQAAABgAAAABAAAAEwAAABgAAAATAAAAAgAAABkAAAAKAAAAAwAAABkAAAADAAAAEwAAABkAAAATAAAACgAAABoAAAACAAAABAAAABsA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</SharedString>
    <SharedString md5="+KXn2PVkmG8K5+S8Au8qxA==">Q1NHUEhTAAAAAEJMT0NL</SharedString>
    <SharedString md5="QGFPL+mDhuS1jsPoelb+4w==">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AAAAIAAAACEAAAAQAAAAIQAAACIAAAAQAAAAIgAAACMAAAAQAAAAIwAAABEAAAARAAAAIwAAACQAAAARAAAAJAAAABIAAAASAAAAJAAAABMAAAATAAAAJQAAACYAAAATAAAAJgAAACcAAAATAAAAJwAAACgAAAATAAAAKAAAABUAAAATAAAAFQAAACkAAAATAAAAKQAAABQAAAATAAAAJAAAACUAAAAUAAAAKQAAABUAAAAWAAAAKgAAACsAAAAWAAAAKwAAABoAAAAWAAAAGgAAABkAAAAWAAAAGAAAACoAAAAYAAAALAAAAC0AAAAYAAAALQAAACoAAAAaAAAAKwAAABsAAAAbAAAAKwAAAB0AAAAbAAAAHQAAABwAAAAdAAAAKwAAAB4AAAAeAAAALgAAAC8AAAAeAAAALwAAAB8AAAAeAAAAKwAAAC4AAAAfAAAALwAAADAAAAAfAAAAMAAAADEAAAAfAAAAMQAAACAAAAAgAAAAMQAAADIAAAAgAAAAMgAAACEAAAAhAAAAMwAAACMAAAAhAAAAIwAAACIAAAAhAAAAMgAAADQAAAAhAAAANAAAADUAAAAhAAAANQAAADYAAAAhAAAANgAAADMAAAAjAAAAMwAAADcAAAAjAAAANwAAADgAAAAjAAAAOAAAACQAAAAkAAAAOAAAADkAAAAkAAAAOQAAADoAAAAkAAAAOgAAADsAAAAkAAAAOwAAACUAAAAlAAAAOwAAADwAAAAlAAAAPAAAACYAAAAmAAAAPQAAACcAAAAmAAAAPAAAADsAAAAmAAAAOwAAAD4AAAAmAAAAPgAAAD8AAAAmAAAAPwAAAD0AAAAnAAAAPQAAAEAAAAAnAAAAQAAAACgAAAAoAAAAQAAAAEEAAAAqAAAAQgAAAC4AAAAqAAAALgAAACsAAAAqAAAALQAAAEMAAAAqAAAAQwAAAEIAAAAsAAAARAAAAEUAAAAsAAAARQAAAEYAAAAsAAAARgAAAC0AAAAtAAAARgAAAEMAAAAuAAAAQgAAAC8AAAAvAAAAQgAAAEcAAAAvAAAARwAAADAAAAAwAAAARwAAAEgAAAAwAAAASAAAADIAAAAwAAAAMgAAADEAAAAyAAAASQAAADUAAAAyAAAANQAAADQAAAAyAAAASAAAAEkAAAAzAAAANgAAAEoAAAAzAAAASgAAAEsAAAAz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DDvAAAAAALr1FMFRpKrAajzbQJZ5GsHq6FfAAAAAAPoPOcH+9qXA6MQGP6MNPMFohdnAvs2KQABjOz3wHpbANK6rP7VLOcHOe1bBajzbQABjOz3mhZvAAAAAAHh2HsGJlMXAajzbQMqvNsGucqLAAAAAAGxyTcEzbfnAAAAAAN1DUcG5CAXBAAAAAN5wT8GiMCDBxCdyQHqANMFSfxTBajzbQGj2L8E2KQXBajzbQABjOz0w/JjAzMAiP0cZO8GkY0vBajzbQBLwU8HOe1bB7uA9QEjJVMHOe1bBAAAAAMLAUcG1cgbBAAAAAN28VsE7YzPBAAAAANH3V8EoFkPBAAAAALn0VME2zFTB/Ms2QG40O8Hoy0LBajzbQP64VMHOe1bBN4wyQOQAAAAAAAAAAQAAAAIAAAAAAAAAAgAAAAMAAAAAAAAAAwAAAAcAAAAAAAAABwAAABAAAAAAAAAAEAAAABcAAAAAAAAAFwAAAB0AAAAAAAAAHQAAABwAAAAAAAAAHAAAACYAAAAAAAAAJgAAAB8AAAAAAAAAHwAAABUAAAAAAAAAFQAAAAoAAAAAAAAACgAAAAQAAAAAAAAABAAAAAUAAAAAAAAABQAAAAYAAAAAAAAABgAAAAEAAAABAAAABgAAAAIAAAACAAAABwAAAAMAAAACAAAABgAAAAgAAAACAAAACAAAAAkAAAACAAAACQAAAAcAAAAEAAAACgAAAAUAAAAFAAAACwAAAAYAAAAFAAAACgAAAAwAAAAFAAAADAAAAA0AAAAFAAAADQAAAA4AAAAFAAAADgAAABYAAAAFAAAAFgAAACEAAAAFAAAAIQAAACQAAAAFAAAAJAAAACMAAAAFAAAAIwAAACIAAAAFAAAAIgAAABoAAAAFAAAAGgAAABkAAAAFAAAAGQAAABgAAAAFAAAAGAAAABEAAAAFAAAAEQAAAA8AAAAFAAAADwAAAAsAAAAGAAAACwAAAA8AAAAGAAAADwAAAAgAAAAHAAAACQAAABAAAAAIAAAADwAAABEAAAAIAAAAEQAAABIAAAAIAAAAEgAAAAkAAAAJAAAAEgAAABMAAAAJAAAAEwAAABAAAAAKAAAAFAAAAB4AAAAKAAAAHgAAABYAAAAKAAAAFgAAAA4AAAAKAAAADgAAAA0AAAAKAAAADQAAAAwAAAAKAAAAFQAAABQAAAAQAAAAEwAAABcAAAARAAAAGAAAABIAAAASAAAAGAAAABkAAAASAAAAGQAAABMAAAATAAAAGQAAABoAAAATAAAAGgAAABsAAAATAAAAGwAAABwAAAATAAAAHAAAAB0AAAATAAAAHQAAABcAAAAUAAAAFQAAAB4AAAAVAAAAFgAAAB4AAAAVAAAAHwAAACAAAAAVAAAAIAAAACcAAAAVAAAAJwAAACEAAAAVAAAAIQAAABYAAAAaAAAAIgAAABsAAAAbAAAAIgAAACMAAAAbAAAAIwAAACQAAAAbAAAAJAAAACUAAAAbAAAAJQAAACYAAAAbAAAAJgAAABwAAAAfAAAAJgAAACUAAAAfAAAAJQAAACAAAAAgAAAAJQAAACcAAAAhAAAAJwAAACQAAAAkAAAAJwAAACUAAAA=</SharedString>
    <SharedString md5="1AGo5KJPpGqtziT6sDf9Ew==">Q1NHUEhTBwAAAAIUfQ9BrqsuPYJsBj2IxH68L87kQGrp571JE2Q9sse9QEu0HT5DTrJAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPzAAAAAEAAAA5WqVPn2Vur9OoDc9PPidvv+6sr+a8Ri/H6MpP8X2/r5RLaa/0AOcP+gmF7+qFPs91xmjPjez7L5Y/MI/8GnxvQtQhr/Mz5c/9kIkv+K81L3+pLO/sZGRv6/YD78zECE/j4hOPwu6ej9cd2u/oLkCP/jolT6VZce/0FCMPxFDDz+H9yQ/2e0vPCHG3D6VZcc/0AOcv7t/cD6K4yS963Rnv9Ooij/ovj8+HMu1vTiZqT9R7GW/NpG/Pn2Vuj+1ihI/VAAAAAAAAAABAAAAAgAAAAAAAAACAAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAABQAAAAAAAAAFAAAAAQAAAAEAAAAGAAAAAgAAAAEAAAAFAAAABwAAAAEAAAAHAAAABgAAAAIAAAAIAAAAAwAAAAIAAAAGAAAACQAAAAIAAAAJAAAACAAAAAMAAAAKAAAABAAAAAMAAAAIAAAACgAAAAQAAAALAAAABQAAAAQAAAAKAAAACwAAAAUAAAALAAAABwAAAAYAAAAHAAAADAAAAAYAAAAMAAAADQAAAAYAAAANAAAADgAAAAYAAAAOAAAACQAAAAcAAAALAAAADQAAAAcAAAANAAAADAAAAAgAAAAJAAAADgAAAAgAAAAOAAAADwAAAAgAAAAPAAAACgAAAAoAAAAPAAAACwAAAAsAAAAPAAAADQAAAA0AAAAPAAAADgAAAA==</SharedString>
    <SharedString md5="1B2M2Y8AsgTpgAmY7PhCfg=="></SharedString>
    <SharedString md5="OreJJotcO+VtooglIF8RWg==">Q1NHUEhTBwAAAAH6QjNFPx2SvshQDsFA+rc+SwPNSP0mnEXHwL1EHXAQR4bQw8VLlcxIEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAP04AAAAEAAAA1K5ctAAAyMEWmd5A8fjSNP7/x8EWmd7Ai8bAQP7/x8EZmV7Ai8bAwP7/x8EUmV5Ai8bAwP7/x8EamV7AisbAQP7/x8ETmV5Aqz5kwFO+BEHf6m1AqTqMP58PukGURKg/1xgIwDzEBEGripFA70GlP6iXuEGGmuG+P40Jv/4zsUE8VxFAa/M9P/7/x0ETV9s+cl41tP7/x0GbVls/GhTMswAAyEGhVVu/cvM9v/7/x0EdV9s+EtHfv0hTukFZBq6+nEnPv4IGu0EAwJg/GG7Evn7cuEEgx6+/a/M9P/7/x0EkVdu+6COHwOSghsA3A4dAcvM9v/7/x0EpVdu+BSkSwDCehsB31qpAd2KqvkfyukEwF/o/iSBkwNjjBEHQawNA8F/uv+JLsUHBGr8/e9X6v9+DsEFuiYW9kAAAAAAAAAABAAAAAgAAAAMAAAABAAAAAAAAAAQAAAABAAAAAwAAAAUAAAAAAAAAAgAAAAYAAAAEAAAAAwAAAAcAAAAAAAAABQAAAAgAAAAAAAAABwAAAAkAAAAFAAAAAgAAAAkAAAAHAAAABQAAAAkAAAACAAAAAQAAAAoAAAAGAAAACAAAAAoAAAAIAAAABwAAAAsAAAAMAAAABwAAAAsAAAAHAAAACQAAAAsAAAANAAAADAAAAA4AAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAANAAAACQAAABEAAAAJAAAAAQAAABEAAAABAAAABAAAABEAAAAEAAAADwAAABIAAAAJAAAADQAAABIAAAANAAAACwAAABIAAAALAAAACQAAABMAAAAIAAAABgAAABMAAAADAAAAAAAAABMAAAAGAAAAAwAAABQAAAANAAAAEQAAABQAAAARAAAADwAAABQAAAAPAAAADgAAABQAAAAOAAAADQAAABUAAAAAAAAACAAAABUAAAAIAAAAEwAAABUAAAATAAAAAAAAABYAAAAMAAAADgAAABYAAAAOAAAAEAAAABYAAAAHAAAADAAAABYAAAAKAAAABwAAABcAAAAEAAAABgAAABgAAAAKAAAAFgAAABgAAAAWAAAAEAAAABgAAAAGAAAACgAAABgAAAAQAAAADwAAABkAAAAGAAAAGAAAABkAAAAYAAAADwAAABkAAAAPAAAABAAAABkAAAAEAAAAFwAAABkAAAAXAAAABgAAAA==</SharedString>
  </SharedStrings>
</roblox>